.TH LVCREATE 8 "LVM TOOLS #VERSION#" "Red Hat, Inc."
.SH NAME
lvcreate - Create a logical volume
.
.SH SYNOPSIS
\fBlvcreate\fP \fIoption_args\fP \fIposition_args\fP
.br
    [ \fIoption_args\fP ]
.br
    [ \fIposition_args\fP ]
.br
.P
.ad l
 \fB-a\fP|\fB--activate\fP \fBy\fP|\fBn\fP|\fBay\fP
.ad b
.br
.ad l
    \fB--addtag\fP \fITag\fP
.ad b
.br
.ad l
    \fB--alloc\fP \fBcontiguous\fP|\fBcling\fP|\fBcling_by_tags\fP|\fBnormal\fP|\fBanywhere\fP|\fBinherit\fP
.ad b
.br
.ad l
 \fB-A\fP|\fB--autobackup\fP \fBy\fP|\fBn\fP
.ad b
.br
.ad l
 \fB-H\fP|\fB--cache\fP
.ad b
.br
.ad l
    \fB--cachemetadataformat\fP \fBauto\fP|\fB1\fP|\fB2\fP
.ad b
.br
.ad l
    \fB--cachemode\fP \fBwritethrough\fP|\fBwriteback\fP|\fBpassthrough\fP
.ad b
.br
.ad l
    \fB--cachepolicy\fP \fIString\fP
.ad b
.br
.ad l
    \fB--cachepool\fP \fILV\fP
.ad b
.br
.ad l
    \fB--cachesettings\fP \fIString\fP
.ad b
.br
.ad l
 \fB-c\fP|\fB--chunksize\fP \fISize\fP[k|UNIT]
.ad b
.br
.ad l
    \fB--commandprofile\fP \fIString\fP
.ad b
.br
.ad l
    \fB--compression\fP \fBy\fP|\fBn\fP
.ad b
.br
.ad l
    \fB--config\fP \fIString\fP
.ad b
.br
.ad l
 \fB-C\fP|\fB--contiguous\fP \fBy\fP|\fBn\fP
.ad b
.br
.ad l
 \fB-d\fP|\fB--debug\fP
.ad b
.br
.ad l
    \fB--deduplication\fP \fBy\fP|\fBn\fP
.ad b
.br
.ad l
    \fB--discards\fP \fBpassdown\fP|\fBnopassdown\fP|\fBignore\fP
.ad b
.br
.ad l
    \fB--driverloaded\fP \fBy\fP|\fBn\fP
.ad b
.br
.ad l
    \fB--errorwhenfull\fP \fBy\fP|\fBn\fP
.ad b
.br
.ad l
 \fB-l\fP|\fB--extents\fP \fINumber\fP[PERCENT]
.ad b
.br
.ad l
 \fB-h\fP|\fB--help\fP
.ad b
.br
.ad l
 \fB-K\fP|\fB--ignoreactivationskip\fP
.ad b
.br
.ad l
    \fB--ignoremonitoring\fP
.ad b
.br
.ad l
    \fB--lockopt\fP \fIString\fP
.ad b
.br
.ad l
    \fB--longhelp\fP
.ad b
.br
.ad l
 \fB-j\fP|\fB--major\fP \fINumber\fP
.ad b
.br
.ad l
    \fB--[raid]maxrecoveryrate\fP \fISize\fP[k|UNIT]
.ad b
.br
.ad l
    \fB--metadataprofile\fP \fIString\fP
.ad b
.br
.ad l
    \fB--minor\fP \fINumber\fP
.ad b
.br
.ad l
    \fB--[raid]minrecoveryrate\fP \fISize\fP[k|UNIT]
.ad b
.br
.ad l
    \fB--mirrorlog\fP \fBcore\fP|\fBdisk\fP
.ad b
.br
.ad l
 \fB-m\fP|\fB--mirrors\fP \fINumber\fP
.ad b
.br
.ad l
    \fB--monitor\fP \fBy\fP|\fBn\fP
.ad b
.br
.ad l
 \fB-n\fP|\fB--name\fP \fIString\fP
.ad b
.br
.ad l
    \fB--nolocking\fP
.ad b
.br
.ad l
    \fB--nosync\fP
.ad b
.br
.ad l
    \fB--noudevsync\fP
.ad b
.br
.ad l
 \fB-p\fP|\fB--permission\fP \fBrw\fP|\fBr\fP
.ad b
.br
.ad l
 \fB-M\fP|\fB--persistent\fP \fBy\fP|\fBn\fP
.ad b
.br
.ad l
    \fB--poolmetadatasize\fP \fISize\fP[m|UNIT]
.ad b
.br
.ad l
    \fB--poolmetadataspare\fP \fBy\fP|\fBn\fP
.ad b
.br
.ad l
    \fB--profile\fP \fIString\fP
.ad b
.br
.ad l
 \fB-q\fP|\fB--quiet\fP
.ad b
.br
.ad l
 \fB-r\fP|\fB--readahead\fP \fBauto\fP|\fBnone\fP|\fINumber\fP
.ad b
.br
.ad l
 \fB-R\fP|\fB--regionsize\fP \fISize\fP[m|UNIT]
.ad b
.br
.ad l
    \fB--reportformat\fP \fBbasic\fP|\fBjson\fP
.ad b
.br
.ad l
 \fB-k\fP|\fB--setactivationskip\fP \fBy\fP|\fBn\fP
.ad b
.br
.ad l
 \fB-L\fP|\fB--size\fP \fISize\fP[m|UNIT]
.ad b
.br
.ad l
 \fB-s\fP|\fB--snapshot\fP
.ad b
.br
.ad l
 \fB-i\fP|\fB--stripes\fP \fINumber\fP
.ad b
.br
.ad l
 \fB-I\fP|\fB--stripesize\fP \fISize\fP[k|UNIT]
.ad b
.br
.ad l
 \fB-t\fP|\fB--test\fP
.ad b
.br
.ad l
 \fB-T\fP|\fB--thin\fP
.ad b
.br
.ad l
    \fB--thinpool\fP \fILV\fP
.ad b
.br
.ad l
    \fB--type\fP \fBlinear\fP|\fBstriped\fP|\fBsnapshot\fP|\fBmirror\fP|\fBraid\fP|\fBthin\fP|\fBcache\fP|\fBvdo\fP|\fBthin-pool\fP|\fBcache-pool\fP|\fBvdo-pool\fP
.ad b
.br
.ad l
    \fB--vdo\fP
.ad b
.br
.ad l
    \fB--vdopool\fP \fILV\fP
.ad b
.br
.ad l
 \fB-v\fP|\fB--verbose\fP
.ad b
.br
.ad l
    \fB--version\fP
.ad b
.br
.ad l
 \fB-V\fP|\fB--virtualsize\fP \fISize\fP[m|UNIT]
.ad b
.br
.ad l
 \fB-W\fP|\fB--wipesignatures\fP \fBy\fP|\fBn\fP
.ad b
.br
.ad l
 \fB-y\fP|\fB--yes\fP
.ad b
.br
.ad l
 \fB-Z\fP|\fB--zero\fP \fBy\fP|\fBn\fP
.ad b
.SH DESCRIPTION
lvcreate creates a new LV in a VG. For standard LVs, this requires
allocating logical extents from the VG's free physical extents. If there
is not enough free space, the VG can be extended with other PVs
(\fBvgextend\fP(8)), or existing LVs can be reduced or removed
(\fBlvremove\fP(8), \fBlvreduce\fP(8).)

To control which PVs a new LV will use, specify one or more PVs as
position args at the end of the command line. lvcreate will allocate
physical extents only from the specified PVs.

lvcreate can also create snapshots of existing LVs, e.g. for backup
purposes. The data in a new snapshot LV represents the content of the
original LV from the time the snapshot was created.

RAID LVs can be created by specifying an LV type when creating the LV (see
\fBlvmraid\fP(7)). Different RAID levels require different numbers of
unique PVs be available in the VG for allocation.

Thin pools (for thin provisioning) and cache pools (for caching) are
represented by special LVs with types thin-pool and cache-pool (see
\fBlvmthin\fP(7) and \fBlvmcache\fP(7)). The pool LVs are not usable as
standard block devices, but the LV names act as references to the pools.

Thin LVs are thinly provisioned from a thin pool, and are created with a
virtual size rather than a physical size. A cache LV is the combination of
a standard LV with a cache pool, used to cache active portions of the LV
to improve performance.

VDO LVs are also provisioned volumes from a VDO pool, and are created with a
virtual size rather than a physical size (see \fBlvmvdo\fP(7)).

.SS Usage notes
In the usage section below, \fB--size\fP \fISize\fP can be replaced
with \fB--extents\fP \fINumber\fP. See descriptions in the options section.

In the usage section below, \fB--name\fP is omitted from the required
options, even though it is typically used. When the name is not
specified, a new LV name is generated with the "lvol" prefix and a unique
numeric suffix.

In the usage section below, when creating a pool and the name is omitted
the new LV pool name is generated with the
"vpool" for vdo-pools  for prefix and a unique numeric suffix.

Pool name can be specified together with \fIVG\fP name i.e.:
vg00/mythinpool.
.SH USAGE
Create a linear LV.
.br
.P
\fBlvcreate\fP \fB-L\fP|\fB--size\fP \fISize\fP[m|UNIT] \fIVG\fP
.br
.RS 4
.ad l
[ \fB-l\fP|\fB--extents\fP \fINumber\fP[PERCENT] ]
.ad b
.br
.ad l
[    \fB--type\fP \fBlinear\fP ]
.ad b
.br
[ COMMON_OPTIONS ]
.RE
.br
.RS 4
[ \fIPV\fP ... ]
.RE
-

Create a striped LV (infers --type striped).
.br
.P
\fBlvcreate\fP \fB-i\fP|\fB--stripes\fP \fINumber\fP \fB-L\fP|\fB--size\fP \fISize\fP[m|UNIT] \fIVG\fP
.br
.RS 4
.ad l
[ \fB-l\fP|\fB--extents\fP \fINumber\fP[PERCENT] ]
.ad b
.br
.ad l
[ \fB-I\fP|\fB--stripesize\fP \fISize\fP[k|UNIT] ]
.ad b
.br
[ COMMON_OPTIONS ]
.RE
.br
.RS 4
[ \fIPV\fP ... ]
.RE
-

Create a raid1 or mirror LV (infers --type raid1|mirror).
.br
.P
\fBlvcreate\fP \fB-m\fP|\fB--mirrors\fP \fINumber\fP \fB-L\fP|\fB--size\fP \fISize\fP[m|UNIT] \fIVG\fP
.br
.RS 4
.ad l
[ \fB-l\fP|\fB--extents\fP \fINumber\fP[PERCENT] ]
.ad b
.br
.ad l
[ \fB-R\fP|\fB--regionsize\fP \fISize\fP[m|UNIT] ]
.ad b
.br
.ad l
[    \fB--mirrorlog\fP \fBcore\fP|\fBdisk\fP ]
.ad b
.br
.ad l
[    \fB--[raid]minrecoveryrate\fP \fISize\fP[k|UNIT] ]
.ad b
.br
.ad l
[    \fB--[raid]maxrecoveryrate\fP \fISize\fP[k|UNIT] ]
.ad b
.br
[ COMMON_OPTIONS ]
.RE
.br
.RS 4
[ \fIPV\fP ... ]
.RE
-

Create a raid LV (a specific raid level must be used, e.g. raid1).
.br
.P
\fBlvcreate\fP \fB--type\fP \fBraid\fP \fB-L\fP|\fB--size\fP \fISize\fP[m|UNIT] \fIVG\fP
.br
.RS 4
.ad l
[ \fB-l\fP|\fB--extents\fP \fINumber\fP[PERCENT] ]
.ad b
.br
.ad l
[ \fB-m\fP|\fB--mirrors\fP \fINumber\fP ]
.ad b
.br
.ad l
[ \fB-i\fP|\fB--stripes\fP \fINumber\fP ]
.ad b
.br
.ad l
[ \fB-I\fP|\fB--stripesize\fP \fISize\fP[k|UNIT] ]
.ad b
.br
.ad l
[ \fB-R\fP|\fB--regionsize\fP \fISize\fP[m|UNIT] ]
.ad b
.br
.ad l
[    \fB--[raid]minrecoveryrate\fP \fISize\fP[k|UNIT] ]
.ad b
.br
.ad l
[    \fB--[raid]maxrecoveryrate\fP \fISize\fP[k|UNIT] ]
.ad b
.br
[ COMMON_OPTIONS ]
.RE
.br
.RS 4
[ \fIPV\fP ... ]
.RE
-

Create a raid10 LV.
.br
.P
\fBlvcreate\fP \fB-m\fP|\fB--mirrors\fP \fINumber\fP \fB-i\fP|\fB--stripes\fP \fINumber\fP
.RS 5
 \fB-L\fP|\fB--size\fP \fISize\fP[m|UNIT] \fIVG\fP
.RE
.br
.RS 4
.ad l
[ \fB-l\fP|\fB--extents\fP \fINumber\fP[PERCENT] ]
.ad b
.br
.ad l
[ \fB-I\fP|\fB--stripesize\fP \fISize\fP[k|UNIT] ]
.ad b
.br
.ad l
[ \fB-R\fP|\fB--regionsize\fP \fISize\fP[m|UNIT] ]
.ad b
.br
.ad l
[    \fB--[raid]minrecoveryrate\fP \fISize\fP[k|UNIT] ]
.ad b
.br
.ad l
[    \fB--[raid]maxrecoveryrate\fP \fISize\fP[k|UNIT] ]
.ad b
.br
[ COMMON_OPTIONS ]
.RE
.br
.RS 4
[ \fIPV\fP ... ]
.RE
-

Create a COW snapshot LV of an origin LV.
.br
.P
\fBlvcreate\fP \fB-s\fP|\fB--snapshot\fP \fB-L\fP|\fB--size\fP \fISize\fP[m|UNIT] \fILV\fP
.br
.RS 4
.ad l
[ \fB-l\fP|\fB--extents\fP \fINumber\fP[PERCENT] ]
.ad b
.br
.ad l
[ \fB-i\fP|\fB--stripes\fP \fINumber\fP ]
.ad b
.br
.ad l
[ \fB-I\fP|\fB--stripesize\fP \fISize\fP[k|UNIT] ]
.ad b
.br
.ad l
[ \fB-c\fP|\fB--chunksize\fP \fISize\fP[k|UNIT] ]
.ad b
.br
.ad l
[    \fB--type\fP \fBsnapshot\fP ]
.ad b
.br
[ COMMON_OPTIONS ]
.RE
.br
.RS 4
[ \fIPV\fP ... ]
.RE
-

Create a thin pool.
.br
.P
\fBlvcreate\fP \fB--type\fP \fBthin-pool\fP \fB-L\fP|\fB--size\fP \fISize\fP[m|UNIT] \fIVG\fP
.br
.RS 4
.ad l
[ \fB-l\fP|\fB--extents\fP \fINumber\fP[PERCENT] ]
.ad b
.br
.ad l
[ \fB-c\fP|\fB--chunksize\fP \fISize\fP[k|UNIT] ]
.ad b
.br
.ad l
[ \fB-i\fP|\fB--stripes\fP \fINumber\fP ]
.ad b
.br
.ad l
[ \fB-I\fP|\fB--stripesize\fP \fISize\fP[k|UNIT] ]
.ad b
.br
.ad l
[    \fB--thinpool\fP \fILV\fP\fI_new\fP ]
.ad b
.br
.ad l
[    \fB--poolmetadatasize\fP \fISize\fP[m|UNIT] ]
.ad b
.br
.ad l
[    \fB--poolmetadataspare\fP \fBy\fP|\fBn\fP ]
.ad b
.br
.ad l
[    \fB--discards\fP \fBpassdown\fP|\fBnopassdown\fP|\fBignore\fP ]
.ad b
.br
.ad l
[    \fB--errorwhenfull\fP \fBy\fP|\fBn\fP ]
.ad b
.br
[ COMMON_OPTIONS ]
.RE
.br
.RS 4
[ \fIPV\fP ... ]
.RE
-

Create a cache pool.
.br
.P
\fBlvcreate\fP \fB--type\fP \fBcache-pool\fP \fB-L\fP|\fB--size\fP \fISize\fP[m|UNIT] \fIVG\fP
.br
.RS 4
.ad l
[ \fB-l\fP|\fB--extents\fP \fINumber\fP[PERCENT] ]
.ad b
.br
.ad l
[ \fB-H\fP|\fB--cache\fP ]
.ad b
.br
.ad l
[ \fB-c\fP|\fB--chunksize\fP \fISize\fP[k|UNIT] ]
.ad b
.br
.ad l
[    \fB--poolmetadatasize\fP \fISize\fP[m|UNIT] ]
.ad b
.br
.ad l
[    \fB--poolmetadataspare\fP \fBy\fP|\fBn\fP ]
.ad b
.br
.ad l
[    \fB--cachemode\fP \fBwritethrough\fP|\fBwriteback\fP|\fBpassthrough\fP ]
.ad b
.br
.ad l
[    \fB--cachepolicy\fP \fIString\fP ]
.ad b
.br
.ad l
[    \fB--cachesettings\fP \fIString\fP ]
.ad b
.br
.ad l
[    \fB--cachemetadataformat\fP \fBauto\fP|\fB1\fP|\fB2\fP ]
.ad b
.br
[ COMMON_OPTIONS ]
.RE
.br
.RS 4
[ \fIPV\fP ... ]
.RE
-

Create a thin LV in a thin pool (infers --type thin).
.br
.P
\fBlvcreate\fP \fB-V\fP|\fB--virtualsize\fP \fISize\fP[m|UNIT] \fB--thinpool\fP \fILV\fP\fI_thinpool\fP \fIVG\fP
.br
.RS 4
.ad l
[ \fB-T\fP|\fB--thin\fP ]
.ad b
.br
.ad l
[    \fB--type\fP \fBthin\fP ]
.ad b
.br
.ad l
[    \fB--discards\fP \fBpassdown\fP|\fBnopassdown\fP|\fBignore\fP ]
.ad b
.br
.ad l
[    \fB--errorwhenfull\fP \fBy\fP|\fBn\fP ]
.ad b
.br
[ COMMON_OPTIONS ]
.RE
.br
-

Create a thin LV that is a snapshot of an existing thin LV 
.br
(infers --type thin).
.br
.P
\fBlvcreate\fP \fB-s\fP|\fB--snapshot\fP \fILV\fP\fI_thin\fP
.br
.RS 4
.ad l
[    \fB--type\fP \fBthin\fP ]
.ad b
.br
.ad l
[    \fB--discards\fP \fBpassdown\fP|\fBnopassdown\fP|\fBignore\fP ]
.ad b
.br
.ad l
[    \fB--errorwhenfull\fP \fBy\fP|\fBn\fP ]
.ad b
.br
[ COMMON_OPTIONS ]
.RE
.br
-

Create a thin LV that is a snapshot of an external origin LV.
.br
.P
\fBlvcreate\fP \fB--type\fP \fBthin\fP \fB--thinpool\fP \fILV\fP\fI_thinpool\fP \fILV\fP
.br
.RS 4
.ad l
[ \fB-T\fP|\fB--thin\fP ]
.ad b
.br
.ad l
[ \fB-c\fP|\fB--chunksize\fP \fISize\fP[k|UNIT] ]
.ad b
.br
.ad l
[    \fB--poolmetadatasize\fP \fISize\fP[m|UNIT] ]
.ad b
.br
.ad l
[    \fB--poolmetadataspare\fP \fBy\fP|\fBn\fP ]
.ad b
.br
.ad l
[    \fB--discards\fP \fBpassdown\fP|\fBnopassdown\fP|\fBignore\fP ]
.ad b
.br
.ad l
[    \fB--errorwhenfull\fP \fBy\fP|\fBn\fP ]
.ad b
.br
[ COMMON_OPTIONS ]
.RE
.br
-

Create a LV that returns VDO when used.
.br
.P
\fBlvcreate\fP \fB--type\fP \fBvdo\fP \fB-L\fP|\fB--size\fP \fISize\fP[m|UNIT] \fIVG\fP
.br
.RS 4
.ad l
[ \fB-l\fP|\fB--extents\fP \fINumber\fP[PERCENT] ]
.ad b
.br
.ad l
[ \fB-V\fP|\fB--virtualsize\fP \fISize\fP[m|UNIT] ]
.ad b
.br
.ad l
[ \fB-i\fP|\fB--stripes\fP \fINumber\fP ]
.ad b
.br
.ad l
[ \fB-I\fP|\fB--stripesize\fP \fISize\fP[k|UNIT] ]
.ad b
.br
.ad l
[    \fB--vdo\fP ]
.ad b
.br
.ad l
[    \fB--vdopool\fP \fILV\fP\fI_new\fP ]
.ad b
.br
.ad l
[    \fB--compression\fP \fBy\fP|\fBn\fP ]
.ad b
.br
.ad l
[    \fB--deduplication\fP \fBy\fP|\fBn\fP ]
.ad b
.br
[ COMMON_OPTIONS ]
.RE
.br
.RS 4
[ \fIPV\fP ... ]
.RE
-

Create a thin LV, first creating a thin pool for it, 
.br
where the new thin pool is named by the --thinpool arg.
.br
.P
\fBlvcreate\fP \fB--type\fP \fBthin\fP \fB-V\fP|\fB--virtualsize\fP \fISize\fP[m|UNIT]
.RS 5
 \fB-L\fP|\fB--size\fP \fISize\fP[m|UNIT] \fB--thinpool\fP \fILV\fP\fI_new\fP
.RE
.br
.RS 4
.ad l
[ \fB-l\fP|\fB--extents\fP \fINumber\fP[PERCENT] ]
.ad b
.br
.ad l
[ \fB-T\fP|\fB--thin\fP ]
.ad b
.br
.ad l
[ \fB-c\fP|\fB--chunksize\fP \fISize\fP[k|UNIT] ]
.ad b
.br
.ad l
[ \fB-i\fP|\fB--stripes\fP \fINumber\fP ]
.ad b
.br
.ad l
[ \fB-I\fP|\fB--stripesize\fP \fISize\fP[k|UNIT] ]
.ad b
.br
.ad l
[    \fB--poolmetadatasize\fP \fISize\fP[m|UNIT] ]
.ad b
.br
.ad l
[    \fB--poolmetadataspare\fP \fBy\fP|\fBn\fP ]
.ad b
.br
.ad l
[    \fB--discards\fP \fBpassdown\fP|\fBnopassdown\fP|\fBignore\fP ]
.ad b
.br
.ad l
[    \fB--errorwhenfull\fP \fBy\fP|\fBn\fP ]
.ad b
.br
[ COMMON_OPTIONS ]
.RE
.br
.RS 4
[ \fIPV\fP ... ]
.RE
-

Create a cache LV, first creating a new origin LV, 
.br
then combining it with the existing cache pool named 
.br
by the --cachepool arg.
.br
.P
\fBlvcreate\fP \fB--type\fP \fBcache\fP \fB-L\fP|\fB--size\fP \fISize\fP[m|UNIT]
.RS 5
 \fB--cachepool\fP \fILV\fP\fI_cachepool\fP \fIVG\fP
.RE
.br
.RS 4
.ad l
[ \fB-l\fP|\fB--extents\fP \fINumber\fP[PERCENT] ]
.ad b
.br
.ad l
[ \fB-H\fP|\fB--cache\fP ]
.ad b
.br
.ad l
[ \fB-c\fP|\fB--chunksize\fP \fISize\fP[k|UNIT] ]
.ad b
.br
.ad l
[ \fB-i\fP|\fB--stripes\fP \fINumber\fP ]
.ad b
.br
.ad l
[ \fB-I\fP|\fB--stripesize\fP \fISize\fP[k|UNIT] ]
.ad b
.br
.ad l
[    \fB--poolmetadatasize\fP \fISize\fP[m|UNIT] ]
.ad b
.br
.ad l
[    \fB--poolmetadataspare\fP \fBy\fP|\fBn\fP ]
.ad b
.br
.ad l
[    \fB--cachemode\fP \fBwritethrough\fP|\fBwriteback\fP|\fBpassthrough\fP ]
.ad b
.br
.ad l
[    \fB--cachepolicy\fP \fIString\fP ]
.ad b
.br
.ad l
[    \fB--cachesettings\fP \fIString\fP ]
.ad b
.br
.ad l
[    \fB--cachemetadataformat\fP \fBauto\fP|\fB1\fP|\fB2\fP ]
.ad b
.br
[ COMMON_OPTIONS ]
.RE
.br
.RS 4
[ \fIPV\fP ... ]
.RE
-

Common options for command:
.
.RS 4
.ad l
[ \fB-a\fP|\fB--activate\fP \fBy\fP|\fBn\fP|\fBay\fP ]
.ad b
.br
.ad l
[ \fB-A\fP|\fB--autobackup\fP \fBy\fP|\fBn\fP ]
.ad b
.br
.ad l
[ \fB-C\fP|\fB--contiguous\fP \fBy\fP|\fBn\fP ]
.ad b
.br
.ad l
[ \fB-K\fP|\fB--ignoreactivationskip\fP ]
.ad b
.br
.ad l
[ \fB-j\fP|\fB--major\fP \fINumber\fP ]
.ad b
.br
.ad l
[ \fB-n\fP|\fB--name\fP \fIString\fP ]
.ad b
.br
.ad l
[ \fB-p\fP|\fB--permission\fP \fBrw\fP|\fBr\fP ]
.ad b
.br
.ad l
[ \fB-M\fP|\fB--persistent\fP \fBy\fP|\fBn\fP ]
.ad b
.br
.ad l
[ \fB-r\fP|\fB--readahead\fP \fBauto\fP|\fBnone\fP|\fINumber\fP ]
.ad b
.br
.ad l
[ \fB-k\fP|\fB--setactivationskip\fP \fBy\fP|\fBn\fP ]
.ad b
.br
.ad l
[ \fB-W\fP|\fB--wipesignatures\fP \fBy\fP|\fBn\fP ]
.ad b
.br
.ad l
[ \fB-Z\fP|\fB--zero\fP \fBy\fP|\fBn\fP ]
.ad b
.br
.ad l
[    \fB--addtag\fP \fITag\fP ]
.ad b
.br
.ad l
[    \fB--alloc\fP \fBcontiguous\fP|\fBcling\fP|\fBcling_by_tags\fP|\fBnormal\fP|\fBanywhere\fP|\fBinherit\fP ]
.ad b
.br
.ad l
[    \fB--ignoremonitoring\fP ]
.ad b
.br
.ad l
[    \fB--metadataprofile\fP \fIString\fP ]
.ad b
.br
.ad l
[    \fB--minor\fP \fINumber\fP ]
.ad b
.br
.ad l
[    \fB--monitor\fP \fBy\fP|\fBn\fP ]
.ad b
.br
.ad l
[    \fB--nosync\fP ]
.ad b
.br
.ad l
[    \fB--noudevsync\fP ]
.ad b
.br
.ad l
[    \fB--reportformat\fP \fBbasic\fP|\fBjson\fP ]
.ad b
.RE

Common options for lvm:
.
.RS 4
.ad l
[ \fB-d\fP|\fB--debug\fP ]
.ad b
.br
.ad l
[ \fB-h\fP|\fB--help\fP ]
.ad b
.br
.ad l
[ \fB-q\fP|\fB--quiet\fP ]
.ad b
.br
.ad l
[ \fB-t\fP|\fB--test\fP ]
.ad b
.br
.ad l
[ \fB-v\fP|\fB--verbose\fP ]
.ad b
.br
.ad l
[ \fB-y\fP|\fB--yes\fP ]
.ad b
.br
.ad l
[    \fB--commandprofile\fP \fIString\fP ]
.ad b
.br
.ad l
[    \fB--config\fP \fIString\fP ]
.ad b
.br
.ad l
[    \fB--driverloaded\fP \fBy\fP|\fBn\fP ]
.ad b
.br
.ad l
[    \fB--lockopt\fP \fIString\fP ]
.ad b
.br
.ad l
[    \fB--longhelp\fP ]
.ad b
.br
.ad l
[    \fB--nolocking\fP ]
.ad b
.br
.ad l
[    \fB--profile\fP \fIString\fP ]
.ad b
.br
.ad l
[    \fB--version\fP ]
.ad b
.RE
.SH OPTIONS
.HP
.ad l
\fB-a\fP|\fB--activate\fP \fBy\fP|\fBn\fP|\fBay\fP
.br
Controls the active state of the new LV.
\fBy\fP makes the LV active, or available.
New LVs are made active by default.
\fBn\fP makes the LV inactive, or unavailable, only when possible.
In some cases, creating an LV requires it to be active.
For example, COW snapshots of an active origin LV can only
be created in the active state (this does not apply to thin snapshots).
The --zero option normally requires the LV to be active.
If autoactivation \fBay\fP is used, the LV is only activated
if it matches an item in lvm.conf activation/auto_activation_volume_list.
\fBay\fP implies --zero n and --wipesignatures n.
See \fBlvmlockd\fP(8) for more information about activation options for shared VGs.
.ad b
.HP
.ad l
\fB--addtag\fP \fITag\fP
.br
Adds a tag to a PV, VG or LV. This option can be repeated to add
multiple tags at once. See \fBlvm\fP(8) for information about tags.
.ad b
.HP
.ad l
\fB--alloc\fP \fBcontiguous\fP|\fBcling\fP|\fBcling_by_tags\fP|\fBnormal\fP|\fBanywhere\fP|\fBinherit\fP
.br
Determines the allocation policy when a command needs to allocate
Physical Extents (PEs) from the VG. Each VG and LV has an allocation policy
which can be changed with vgchange/lvchange, or overriden on the
command line.
\fBnormal\fP applies common sense rules such as not placing parallel stripes
on the same PV.
\fBinherit\fP applies the VG policy to an LV.
\fBcontiguous\fP requires new PEs be placed adjacent to existing PEs.
\fBcling\fP places new PEs on the same PV as existing PEs in the same
stripe of the LV.
If there are sufficient PEs for an allocation, but normal does not
use them, \fBanywhere\fP will use them even if it reduces performance,
e.g. by placing two stripes on the same PV.
Optional positional PV args on the command line can also be used to limit
which PVs the command will use for allocation.
See \fBlvm\fP(8) for more information about allocation.
.ad b
.HP
.ad l
\fB-A\fP|\fB--autobackup\fP \fBy\fP|\fBn\fP
.br
Specifies if metadata should be backed up automatically after a change.
Enabling this is strongly advised! See \fBvgcfgbackup\fP(8) for more information.
.ad b
.HP
.ad l
\fB-H\fP|\fB--cache\fP
.br
Specifies the command is handling a cache LV or cache pool.
See --type cache and --type cache-pool.
See \fBlvmcache\fP(7) for more information about LVM caching.
.ad b
.HP
.ad l
\fB--cachemetadataformat\fP \fBauto\fP|\fB1\fP|\fB2\fP
.br
Specifies the cache metadata format used by cache target.
.ad b
.HP
.ad l
\fB--cachemode\fP \fBwritethrough\fP|\fBwriteback\fP|\fBpassthrough\fP
.br
Specifies when writes to a cache LV should be considered complete.
\fBwriteback\fP considers a write complete as soon as it is
stored in the cache pool.
\fBwritethough\fP considers a write complete only when it has
been stored in both the cache pool and on the origin LV.
While writethrough may be slower for writes, it is more
resilient if something should happen to a device associated with the
cache pool LV. With \fBpassthrough\fP, all reads are served
from the origin LV (all reads miss the cache) and all writes are
forwarded to the origin LV; additionally, write hits cause cache
block invalidates. See \fBlvmcache\fP(7) for more information.
.ad b
.HP
.ad l
\fB--cachepolicy\fP \fIString\fP
.br
Specifies the cache policy for a cache LV.
See \fBlvmcache\fP(7) for more information.
.ad b
.HP
.ad l
\fB--cachepool\fP \fILV\fP
.br
The name of a cache pool.
.ad b
.HP
.ad l
\fB--cachesettings\fP \fIString\fP
.br
Specifies tunable values for a cache LV in "Key = Value" form.
Repeat this option to specify multiple values.
(The default values should usually be adequate.)
The special string value \fBdefault\fP switches
settings back to their default kernel values and removes
them from the list of settings stored in LVM metadata.
See \fBlvmcache\fP(7) for more information.
.ad b
.HP
.ad l
\fB-c\fP|\fB--chunksize\fP \fISize\fP[k|UNIT]
.br
The size of chunks in a snapshot, cache pool or thin pool.
For snapshots, the value must be a power of 2 between 4KiB and 512KiB
and the default value is 4.
For a cache pool the value must be between 32KiB and 1GiB
and the default value is 64.
For a thin pool the value must be between 64KiB and 1GiB
and the default value starts with 64 and scales up to fit the
pool metadata size within 128MiB, if the pool metadata size is not specified.
The value must be a multiple of 64KiB.
See \fBlvmthin\fP(7) and \fBlvmcache\fP(7) for more information.
.ad b
.HP
.ad l
\fB--commandprofile\fP \fIString\fP
.br
The command profile to use for command configuration.
See \fBlvm.conf\fP(5) for more information about profiles.
.ad b
.HP
.ad l
\fB--compression\fP \fBy\fP|\fBn\fP
.br
Controls whether compression is enabled or disable for VDO volume.
See \fBlvmvdo\fP(7) for more information about VDO usage.
.ad b
.HP
.ad l
\fB--config\fP \fIString\fP
.br
Config settings for the command. These override lvm.conf settings.
The String arg uses the same format as lvm.conf,
or may use section/field syntax.
See \fBlvm.conf\fP(5) for more information about config.
.ad b
.HP
.ad l
\fB-C\fP|\fB--contiguous\fP \fBy\fP|\fBn\fP
.br
Sets or resets the contiguous allocation policy for LVs.
Default is no contiguous allocation based on a next free principle.
It is only possible to change a non-contiguous allocation policy
to contiguous if all of the allocated physical extents in the LV
are already contiguous.
.ad b
.HP
.ad l
\fB-d\fP|\fB--debug\fP ...
.br
Set debug level. Repeat from 1 to 6 times to increase the detail of
messages sent to the log file and/or syslog (if configured).
.ad b
.HP
.ad l
\fB--deduplication\fP \fBy\fP|\fBn\fP
.br
Controls whether deduplication is enabled or disable for VDO volume.
See \fBlvmvdo\fP(7) for more information about VDO usage.
.ad b
.HP
.ad l
\fB--discards\fP \fBpassdown\fP|\fBnopassdown\fP|\fBignore\fP
.br
Specifies how the device-mapper thin pool layer in the kernel should
handle discards.
\fBignore\fP causes the thin pool to ignore discards.
\fBnopassdown\fP causes the thin pool to process discards itself to
allow reuse of unneeded extents in the thin pool.
\fBpassdown\fP causes the thin pool to process discards itself
(like nopassdown) and pass the discards to the underlying device.
See \fBlvmthin\fP(7) for more information.
.ad b
.HP
.ad l
\fB--driverloaded\fP \fBy\fP|\fBn\fP
.br
If set to no, the command will not attempt to use device-mapper.
For testing and debugging.
.ad b
.HP
.ad l
\fB--errorwhenfull\fP \fBy\fP|\fBn\fP
.br
Specifies thin pool behavior when data space is exhausted.
When yes, device-mapper will immediately return an error
when a thin pool is full and an I/O request requires space.
When no, device-mapper will queue these I/O requests for a
period of time to allow the thin pool to be extended.
Errors are returned if no space is available after the timeout.
(Also see dm-thin-pool kernel module option no_space_timeout.)
See \fBlvmthin\fP(7) for more information.
.ad b
.HP
.ad l
\fB-l\fP|\fB--extents\fP \fINumber\fP[PERCENT]
.br
Specifies the size of the new LV in logical extents.
The --size and --extents options are alternate methods of specifying size.
The total number of physical extents used will be
greater when redundant data is needed for RAID levels.
An alternate syntax allows the size to be determined indirectly
as a percentage of the size of a related VG, LV, or set of PVs. The
suffix \fB%VG\fP denotes the total size of the VG, the suffix \fB%FREE\fP
the remaining free space in the VG, and the suffix \fB%PVS\fP the free
space in the specified PVs.  For a snapshot, the size
can be expressed as a percentage of the total size of the origin LV
with the suffix \fB%ORIGIN\fP (\fB100%ORIGIN\fP provides space for
the whole origin).
When expressed as a percentage, the size defines an upper limit for the
number of logical extents in the new LV. The precise number of logical
extents in the new LV is not determined until the command has completed.
.ad b
.HP
.ad l
\fB-h\fP|\fB--help\fP
.br
Display help text.
.ad b
.HP
.ad l
\fB-K\fP|\fB--ignoreactivationskip\fP
.br
Ignore the "activation skip" LV flag during activation
to allow LVs with the flag set to be activated.
.ad b
.HP
.ad l
\fB--ignoremonitoring\fP
.br
Do not interact with dmeventd unless --monitor is specified.
Do not use this if dmeventd is already monitoring a device.
.ad b
.HP
.ad l
\fB--lockopt\fP \fIString\fP
.br
Used to pass options for special cases to lvmlockd.
See \fBlvmlockd\fP(8) for more information.
.ad b
.HP
.ad l
\fB--longhelp\fP
.br
Display long help text.
.ad b
.HP
.ad l
\fB-j\fP|\fB--major\fP \fINumber\fP
.br
Sets the major number of an LV block device.
.ad b
.HP
.ad l
\fB--[raid]maxrecoveryrate\fP \fISize\fP[k|UNIT]
.br
Sets the maximum recovery rate for a RAID LV.  The rate value
is an amount of data per second for each device in the array.
Setting the rate to 0 means it will be unbounded.
See \fBlvmraid\fP(7) for more information.
.ad b
.HP
.ad l
\fB--metadataprofile\fP \fIString\fP
.br
The metadata profile to use for command configuration.
See \fBlvm.conf\fP(5) for more information about profiles.
.ad b
.HP
.ad l
\fB--minor\fP \fINumber\fP
.br
Sets the minor number of an LV block device.
.ad b
.HP
.ad l
\fB--[raid]minrecoveryrate\fP \fISize\fP[k|UNIT]
.br
Sets the minimum recovery rate for a RAID LV.  The rate value
is an amount of data per second for each device in the array.
Setting the rate to 0 means it will be unbounded.
See \fBlvmraid\fP(7) for more information.
.ad b
.HP
.ad l
\fB--mirrorlog\fP \fBcore\fP|\fBdisk\fP
.br
Specifies the type of mirror log for LVs with the "mirror" type
(does not apply to the "raid1" type.)
\fBdisk\fP is a persistent log and requires a small amount of
storage space, usually on a separate device from the data being mirrored.
\fBcore\fP is not persistent; the log is kept only in memory.
In this case, the mirror must be synchronized (by copying LV data from
the first device to others) each time the LV is activated, e.g. after reboot.
\fBmirrored\fP is a persistent log that is itself mirrored, but
should be avoided. Instead, use the raid1 type for log redundancy.
.ad b
.HP
.ad l
\fB-m\fP|\fB--mirrors\fP \fINumber\fP
.br
Specifies the number of mirror images in addition to the original LV
image, e.g. --mirrors 1 means there are two images of the data, the
original and one mirror image.
Optional positional PV args on the command line can specify the devices
the images should be placed on.
There are two mirroring implementations: "raid1" and "mirror".
These are the names of the corresponding LV types, or "segment types".
Use the --type option to specify which to use (raid1 is default,
and mirror is legacy)
Use lvm.conf global/mirror_segtype_default and
global/raid10_segtype_default to configure the default types.
See the --nosync option for avoiding initial image synchronization.
See \fBlvmraid\fP(7) for more information.
.ad b
.HP
.ad l
\fB--monitor\fP \fBy\fP|\fBn\fP
.br
Start (yes) or stop (no) monitoring an LV with dmeventd.
dmeventd monitors kernel events for an LV, and performs
automated maintenance for the LV in reponse to specific events.
See \fBdmeventd\fP(8) for more information.
.ad b
.HP
.ad l
\fB-n\fP|\fB--name\fP \fIString\fP
.br
Specifies the name of a new LV.
When unspecified, a default name of "lvol#" is
generated, where # is a number generated by LVM.
.ad b
.HP
.ad l
\fB--nolocking\fP
.br
Disable locking.
.ad b
.HP
.ad l
\fB--nosync\fP
.br
Causes the creation of mirror, raid1, raid4, raid5 and raid10 to skip the
initial synchronization. In case of mirror, raid1 and raid10, any data
written afterwards will be mirrored, but the original contents will not be
copied. In case of raid4 and raid5, no parity blocks will be written,
though any data written afterwards will cause parity blocks to be stored.
This is useful for skipping a potentially long and resource intensive initial
sync of an empty mirror/raid1/raid4/raid5 and raid10 LV.
This option is not valid for raid6, because raid6 relies on proper parity
(P and Q Syndromes) being created during initial synchronization in order
to reconstruct proper user date in case of device failures.
raid0 and raid0_meta do not provide any data copies or parity support
and thus do not support initial synchronization.
.ad b
.HP
.ad l
\fB--noudevsync\fP
.br
Disables udev synchronisation. The process will not wait for notification
from udev. It will continue irrespective of any possible udev processing
in the background. Only use this if udev is not running or has rules that
ignore the devices LVM creates.
.ad b
.HP
.ad l
\fB-p\fP|\fB--permission\fP \fBrw\fP|\fBr\fP
.br
Set access permission to read only \fBr\fP or read and write \fBrw\fP.
.ad b
.HP
.ad l
\fB-M\fP|\fB--persistent\fP \fBy\fP|\fBn\fP
.br
When yes, makes the specified minor number persistent.
.ad b
.HP
.ad l
\fB--poolmetadatasize\fP \fISize\fP[m|UNIT]
.br
Specifies the size of the new pool metadata LV.
.ad b
.HP
.ad l
\fB--poolmetadataspare\fP \fBy\fP|\fBn\fP
.br
Enable or disable the automatic creation and management of a
spare pool metadata LV in the VG. A spare metadata LV is reserved
space that can be used when repairing a pool.
.ad b
.HP
.ad l
\fB--profile\fP \fIString\fP
.br
An alias for --commandprofile or --metadataprofile, depending
on the command.
.ad b
.HP
.ad l
\fB-q\fP|\fB--quiet\fP ...
.br
Suppress output and log messages. Overrides --debug and --verbose.
Repeat once to also suppress any prompts with answer 'no'.
.ad b
.HP
.ad l
\fB-r\fP|\fB--readahead\fP \fBauto\fP|\fBnone\fP|\fINumber\fP
.br
Sets read ahead sector count of an LV.
\fBauto\fP is the default which allows the kernel to choose
a suitable value automatically.
\fBnone\fP is equivalent to zero.
.ad b
.HP
.ad l
\fB-R\fP|\fB--regionsize\fP \fISize\fP[m|UNIT]
.br
Size of each raid or mirror synchronization region.
lvm.conf activation/raid_region_size can be used to
configure a default.
.ad b
.HP
.ad l
\fB--reportformat\fP \fBbasic\fP|\fBjson\fP
.br
Overrides current output format for reports which is defined globally by
the report/output_format setting in lvm.conf.
\fBbasic\fP is the original format with columns and rows.
If there is more than one report per command, each report is prefixed
with the report name for identification. \fBjson\fP produces report
output in JSON format. See \fBlvmreport\fP(7) for more information.
.ad b
.HP
.ad l
\fB-k\fP|\fB--setactivationskip\fP \fBy\fP|\fBn\fP
.br
Persistently sets (yes) or clears (no) the "activation skip" flag on an LV.
An LV with this flag set is not activated unless the
--ignoreactivationskip option is used by the activation command.
This flag is set by default on new thin snapshot LVs.
The flag is not applied to deactivation.
The current value of the flag is indicated in the lvs lv_attr bits.
.ad b
.HP
.ad l
\fB-L\fP|\fB--size\fP \fISize\fP[m|UNIT]
.br
Specifies the size of the new LV.
The --size and --extents options are alternate methods of specifying size.
The total number of physical extents used will be
greater when redundant data is needed for RAID levels.
.ad b
.HP
.ad l
\fB-s\fP|\fB--snapshot\fP
.br
Create a snapshot. Snapshots provide a "frozen image" of an origin LV.
The snapshot LV can be used, e.g. for backups, while the origin LV
continues to be used.
This option can create a COW (copy on write) snapshot,
or a thin snapshot (in a thin pool.)
Thin snapshots are created when the origin is a thin LV and
the size option is NOT specified. Thin snapshots share the same blocks
in the thin pool, and do not allocate new space from the VG.
Thin snapshots are created with the "activation skip" flag,
see --setactivationskip.
A thin snapshot of a non-thin "external origin" LV is created
when a thin pool is specified. Unprovisioned blocks in the thin snapshot
LV are read from the external origin LV. The external origin LV must
be read-only.
See \fBlvmthin\fP(7) for more information about LVM thin provisioning.
COW snapshots are created when a size is specified. The size is allocated
from space in the VG, and is the amount of space that can be used
for saving COW blocks as writes occur to the origin or snapshot.
The size chosen should depend upon the amount of writes that are expected;
often 20% of the origin LV is enough. If COW space runs low, it can
be extended with lvextend (shrinking is also allowed with lvreduce.)
A small amount of the COW snapshot LV size is used to track COW block
locations, so the full size is not available for COW data blocks.
Use lvs to check how much space is used, and see --monitor to
to automatically extend the size to avoid running out of space.
.ad b
.HP
.ad l
\fB-i\fP|\fB--stripes\fP \fINumber\fP
.br
Specifies the number of stripes in a striped LV. This is the number of
PVs (devices) that a striped LV is spread across. Data that
appears sequential in the LV is spread across multiple devices in units of
the stripe size (see --stripesize). This does not change existing
allocated space, but only applies to space being allocated by the command.
When creating a RAID 4/5/6 LV, this number does not include the extra
devices that are required for parity. The largest number depends on
the RAID type (raid0: 64, raid10: 32, raid4/5: 63, raid6: 62), and
when unspecified, the default depends on the RAID type
(raid0: 2, raid10: 2, raid4/5: 3, raid6: 5.)
To stripe a new raid LV across all PVs by default,
see lvm.conf allocation/raid_stripe_all_devices.
.ad b
.HP
.ad l
\fB-I\fP|\fB--stripesize\fP \fISize\fP[k|UNIT]
.br
The amount of data that is written to one device before
moving to the next in a striped LV.
.ad b
.HP
.ad l
\fB-t\fP|\fB--test\fP
.br
Run in test mode. Commands will not update metadata.
This is implemented by disabling all metadata writing but nevertheless
returning success to the calling function. This may lead to unusual
error messages in multi-stage operations if a tool relies on reading
back metadata it believes has changed but hasn't.
.ad b
.HP
.ad l
\fB-T\fP|\fB--thin\fP
.br
Specifies the command is handling a thin LV or thin pool.
See --type thin, --type thin-pool, and --virtualsize.
See \fBlvmthin\fP(7) for more information about LVM thin provisioning.
.ad b
.HP
.ad l
\fB--thinpool\fP \fILV\fP
.br
The name of a thin pool LV.
.ad b
.HP
.ad l
\fB--type\fP \fBlinear\fP|\fBstriped\fP|\fBsnapshot\fP|\fBmirror\fP|\fBraid\fP|\fBthin\fP|\fBcache\fP|\fBvdo\fP|\fBthin-pool\fP|\fBcache-pool\fP|\fBvdo-pool\fP
.br
The LV type, also known as "segment type" or "segtype".
See usage descriptions for the specific ways to use these types.
For more information about redundancy and performance (\fBraid\fP<N>, \fBmirror\fP, \fBstriped\fP, \fBlinear\fP) see \fBlvmraid\fP(7).
For thin provisioning (\fBthin\fP, \fBthin-pool\fP) see \fBlvmthin\fP(7).
For performance caching (\fBcache\fP, \fBcache-pool\fP) see \fBlvmcache\fP(7).
For copy-on-write snapshots (\fBsnapshot\fP) see usage definitions.
For VDO (\fBvdo\fP) see \fBlvmvdo\fP(7).
Several commands omit an explicit type option because the type
is inferred from other options or shortcuts
(e.g. --stripes, --mirrors, --snapshot, --virtualsize, --thin, --cache, --vdo).
Use inferred types with care because it can lead to unexpected results.
.ad b
.HP
.ad l
\fB--vdo\fP
.br
Specifies the command is handling VDO LV.
See --type vdo.
See \fBlvmvdo\fP(7) for more information about VDO usage.
.ad b
.HP
.ad l
\fB--vdopool\fP \fILV\fP
.br
The name of a VDO pool LV.
See \fBlvmvdo\fP(7) for more information about VDO usage.
.ad b
.HP
.ad l
\fB-v\fP|\fB--verbose\fP ...
.br
Set verbose level. Repeat from 1 to 4 times to increase the detail
of messages sent to stdout and stderr.
.ad b
.HP
.ad l
\fB--version\fP
.br
Display version information.
.ad b
.HP
.ad l
\fB-V\fP|\fB--virtualsize\fP \fISize\fP[m|UNIT]
.br
The virtual size of a new thin LV.
See \fBlvmthin\fP(7) for more information about LVM thin provisioning.
Using virtual size (-V) and actual size (-L) together creates
a sparse LV.
lvm.conf global/sparse_segtype_default determines the
default segment type used to create a sparse LV.
Anything written to a sparse LV will be returned when reading from it.
Reading from other areas of the LV will return blocks of zeros.
When using a snapshot to create a sparse LV, a hidden virtual device
is created using the zero target, and the LV has the suffix _vorigin.
Snapshots are less efficient than thin provisioning when creating
large sparse LVs (GiB).
.ad b
.HP
.ad l
\fB-W\fP|\fB--wipesignatures\fP \fBy\fP|\fBn\fP
.br
Controls detection and subsequent wiping of signatures on new LVs.
There is a prompt for each signature detected to confirm its wiping
(unless --yes is used to override confirmations.)
When not specified, signatures are wiped whenever zeroing is done
(see --zero). This behaviour can be configured with
lvm.conf allocation/wipe_signatures_when_zeroing_new_lvs.
If blkid wiping is used (lvm.conf allocation/use_blkid_wiping)
and LVM is compiled with blkid wiping support, then the blkid(8)
library is used to detect the signatures (use blkid -k to list the
signatures that are recognized).
Otherwise, native LVM code is used to detect signatures
(only MD RAID, swap and LUKS signatures are detected in this case.)
The LV is not wiped if the read only flag is set.
.ad b
.HP
.ad l
\fB-y\fP|\fB--yes\fP
.br
Do not prompt for confirmation interactively but always assume the
answer yes. Use with extreme caution.
(For automatic no, see -qq.)
.ad b
.HP
.ad l
\fB-Z\fP|\fB--zero\fP \fBy\fP|\fBn\fP
.br
Controls zeroing of the first 4KiB of data in the new LV.
Default is \fBy\fP.
Snapshot COW volumes are always zeroed.
For thin pools, this controls zeroing of provisioned blocks.
LV is not zeroed if the read only flag is set.
Warning: trying to mount an unzeroed LV can cause the system to hang.
.ad b
.SH VARIABLES
.HP
\fIVG\fP
.br
Volume Group name.  See \fBlvm\fP(8) for valid names.
For lvcreate, the required VG positional arg may be
omitted when the VG name is included in another option,
e.g. --name VG/LV.
.HP
\fILV\fP
.br
Logical Volume name.  See \fBlvm\fP(8) for valid names.
An LV positional arg generally includes the VG name and LV name, e.g. VG/LV.
LV followed by _<type> indicates that an LV of the
given type is required. (raid represents raid<N> type)
.HP
\fIPV\fP
.br
Physical Volume name, a device path under /dev.
For commands managing physical extents, a PV positional arg
generally accepts a suffix indicating a range (or multiple ranges)
of physical extents (PEs). When the first PE is omitted, it defaults
to the start of the device, and when the last PE is omitted it defaults to end.
Start and end range (inclusive): \fIPV\fP[\fB:\fP\fIPE\fP\fB-\fP\fIPE\fP]...
Start and length range (counting from 0): \fIPV\fP[\fB:\fP\fIPE\fP\fB+\fP\fIPE\fP]...
.HP
\fIString\fP
.br
See the option description for information about the string content.
.HP
\fISize\fP[UNIT]
.br
Size is an input number that accepts an optional unit.
Input units are always treated as base two values, regardless of
capitalization, e.g. 'k' and 'K' both refer to 1024.
The default input unit is specified by letter, followed by |UNIT.
UNIT represents other possible input units: \fBbBsSkKmMgGtTpPeE\fP.
b|B is bytes, s|S is sectors of 512 bytes, k|K is kilobytes,
m|M is megabytes, g|G is gigabytes, t|T is terabytes,
p|P is petabytes, e|E is exabytes.
(This should not be confused with the output control --units, where
capital letters mean multiple of 1000.)
.SH ENVIRONMENT VARIABLES
See \fBlvm\fP(8) for information about environment variables used by lvm.
For example, LVM_VG_NAME can generally be substituted for a required VG parameter.
.SH ADVANCED USAGE
Alternate command forms, advanced command usage, and listing of all valid syntax for completeness.
.P
Create an LV that returns errors when used.
.br
.P
\fBlvcreate\fP \fB--type\fP \fBerror\fP \fB-L\fP|\fB--size\fP \fISize\fP[m|UNIT] \fIVG\fP
.br
.RS 4
.ad l
[ \fB-l\fP|\fB--extents\fP \fINumber\fP[PERCENT] ]
.ad b
.br
[ COMMON_OPTIONS ]
.RE
.br
-

Create an LV that returns zeros when read.
.br
.P
\fBlvcreate\fP \fB--type\fP \fBzero\fP \fB-L\fP|\fB--size\fP \fISize\fP[m|UNIT] \fIVG\fP
.br
.RS 4
.ad l
[ \fB-l\fP|\fB--extents\fP \fINumber\fP[PERCENT] ]
.ad b
.br
[ COMMON_OPTIONS ]
.RE
.br
-

Create a linear LV.
.br
.P
\fBlvcreate\fP \fB--type\fP \fBlinear\fP \fB-L\fP|\fB--size\fP \fISize\fP[m|UNIT] \fIVG\fP
.br
.RS 4
.ad l
[ \fB-l\fP|\fB--extents\fP \fINumber\fP[PERCENT] ]
.ad b
.br
[ COMMON_OPTIONS ]
.RE
.br
.RS 4
[ \fIPV\fP ... ]
.RE
-

Create a striped LV (also see lvcreate --stripes).
.br
.P
\fBlvcreate\fP \fB--type\fP \fBstriped\fP \fB-L\fP|\fB--size\fP \fISize\fP[m|UNIT] \fIVG\fP
.br
.RS 4
.ad l
[ \fB-l\fP|\fB--extents\fP \fINumber\fP[PERCENT] ]
.ad b
.br
.ad l
[ \fB-i\fP|\fB--stripes\fP \fINumber\fP ]
.ad b
.br
.ad l
[ \fB-I\fP|\fB--stripesize\fP \fISize\fP[k|UNIT] ]
.ad b
.br
[ COMMON_OPTIONS ]
.RE
.br
.RS 4
[ \fIPV\fP ... ]
.RE
-

Create a mirror LV (also see --type raid1).
.br
.P
\fBlvcreate\fP \fB--type\fP \fBmirror\fP \fB-L\fP|\fB--size\fP \fISize\fP[m|UNIT] \fIVG\fP
.br
.RS 4
.ad l
[ \fB-l\fP|\fB--extents\fP \fINumber\fP[PERCENT] ]
.ad b
.br
.ad l
[ \fB-m\fP|\fB--mirrors\fP \fINumber\fP ]
.ad b
.br
.ad l
[ \fB-R\fP|\fB--regionsize\fP \fISize\fP[m|UNIT] ]
.ad b
.br
.ad l
[ \fB-i\fP|\fB--stripes\fP \fINumber\fP ]
.ad b
.br
.ad l
[ \fB-I\fP|\fB--stripesize\fP \fISize\fP[k|UNIT] ]
.ad b
.br
.ad l
[    \fB--mirrorlog\fP \fBcore\fP|\fBdisk\fP ]
.ad b
.br
[ COMMON_OPTIONS ]
.RE
.br
.RS 4
[ \fIPV\fP ... ]
.RE
-

Create a COW snapshot LV of an origin LV 
.br
(also see --snapshot).
.br
.P
\fBlvcreate\fP \fB--type\fP \fBsnapshot\fP \fB-L\fP|\fB--size\fP \fISize\fP[m|UNIT] \fILV\fP
.br
.RS 4
.ad l
[ \fB-l\fP|\fB--extents\fP \fINumber\fP[PERCENT] ]
.ad b
.br
.ad l
[ \fB-s\fP|\fB--snapshot\fP ]
.ad b
.br
.ad l
[ \fB-i\fP|\fB--stripes\fP \fINumber\fP ]
.ad b
.br
.ad l
[ \fB-I\fP|\fB--stripesize\fP \fISize\fP[k|UNIT] ]
.ad b
.br
.ad l
[ \fB-c\fP|\fB--chunksize\fP \fISize\fP[k|UNIT] ]
.ad b
.br
[ COMMON_OPTIONS ]
.RE
.br
.RS 4
[ \fIPV\fP ... ]
.RE
-

Create a sparse COW snapshot LV of a virtual origin LV 
.br
(also see --snapshot).
.br
.P
\fBlvcreate\fP \fB--type\fP \fBsnapshot\fP \fB-L\fP|\fB--size\fP \fISize\fP[m|UNIT]
.RS 5
 \fB-V\fP|\fB--virtualsize\fP \fISize\fP[m|UNIT] \fIVG\fP
.RE
.br
.RS 4
.ad l
[ \fB-l\fP|\fB--extents\fP \fINumber\fP[PERCENT] ]
.ad b
.br
.ad l
[ \fB-s\fP|\fB--snapshot\fP ]
.ad b
.br
.ad l
[ \fB-c\fP|\fB--chunksize\fP \fISize\fP[k|UNIT] ]
.ad b
.br
[ COMMON_OPTIONS ]
.RE
.br
.RS 4
[ \fIPV\fP ... ]
.RE
-

Create a sparse COW snapshot LV of a virtual origin LV.
.br
.P
\fBlvcreate\fP \fB-s\fP|\fB--snapshot\fP \fB-L\fP|\fB--size\fP \fISize\fP[m|UNIT]
.RS 5
 \fB-V\fP|\fB--virtualsize\fP \fISize\fP[m|UNIT] \fIVG\fP
.RE
.br
.RS 4
.ad l
[ \fB-l\fP|\fB--extents\fP \fINumber\fP[PERCENT] ]
.ad b
.br
.ad l
[ \fB-c\fP|\fB--chunksize\fP \fISize\fP[k|UNIT] ]
.ad b
.br
.ad l
[    \fB--type\fP \fBsnapshot\fP ]
.ad b
.br
[ COMMON_OPTIONS ]
.RE
.br
.RS 4
[ \fIPV\fP ... ]
.RE
-

Create a thin pool (infers --type thin-pool).
.br
.P
\fBlvcreate\fP \fB-T\fP|\fB--thin\fP \fB-L\fP|\fB--size\fP \fISize\fP[m|UNIT] \fIVG\fP
.br
.RS 4
.ad l
[ \fB-l\fP|\fB--extents\fP \fINumber\fP[PERCENT] ]
.ad b
.br
.ad l
[ \fB-c\fP|\fB--chunksize\fP \fISize\fP[k|UNIT] ]
.ad b
.br
.ad l
[ \fB-i\fP|\fB--stripes\fP \fINumber\fP ]
.ad b
.br
.ad l
[ \fB-I\fP|\fB--stripesize\fP \fISize\fP[k|UNIT] ]
.ad b
.br
.ad l
[    \fB--type\fP \fBthin-pool\fP ]
.ad b
.br
.ad l
[    \fB--poolmetadatasize\fP \fISize\fP[m|UNIT] ]
.ad b
.br
.ad l
[    \fB--poolmetadataspare\fP \fBy\fP|\fBn\fP ]
.ad b
.br
.ad l
[    \fB--discards\fP \fBpassdown\fP|\fBnopassdown\fP|\fBignore\fP ]
.ad b
.br
.ad l
[    \fB--errorwhenfull\fP \fBy\fP|\fBn\fP ]
.ad b
.br
[ COMMON_OPTIONS ]
.RE
.br
.RS 4
[ \fIPV\fP ... ]
.RE
-

Create a thin pool named by the --thinpool arg 
.br
(infers --type thin-pool).
.br
.P
\fBlvcreate\fP \fB-L\fP|\fB--size\fP \fISize\fP[m|UNIT] \fB--thinpool\fP \fILV\fP\fI_new\fP \fIVG\fP
.br
.RS 4
.ad l
[ \fB-l\fP|\fB--extents\fP \fINumber\fP[PERCENT] ]
.ad b
.br
.ad l
[ \fB-T\fP|\fB--thin\fP ]
.ad b
.br
.ad l
[ \fB-c\fP|\fB--chunksize\fP \fISize\fP[k|UNIT] ]
.ad b
.br
.ad l
[ \fB-i\fP|\fB--stripes\fP \fINumber\fP ]
.ad b
.br
.ad l
[ \fB-I\fP|\fB--stripesize\fP \fISize\fP[k|UNIT] ]
.ad b
.br
.ad l
[    \fB--type\fP \fBthin-pool\fP ]
.ad b
.br
.ad l
[    \fB--poolmetadatasize\fP \fISize\fP[m|UNIT] ]
.ad b
.br
.ad l
[    \fB--poolmetadataspare\fP \fBy\fP|\fBn\fP ]
.ad b
.br
.ad l
[    \fB--discards\fP \fBpassdown\fP|\fBnopassdown\fP|\fBignore\fP ]
.ad b
.br
.ad l
[    \fB--errorwhenfull\fP \fBy\fP|\fBn\fP ]
.ad b
.br
[ COMMON_OPTIONS ]
.RE
.br
.RS 4
[ \fIPV\fP ... ]
.RE
-

Create a cache pool named by the --cachepool arg 
.br
(variant, uses --cachepool in place of --name).
.br
.P
\fBlvcreate\fP \fB--type\fP \fBcache-pool\fP \fB-L\fP|\fB--size\fP \fISize\fP[m|UNIT]
.RS 5
 \fB--cachepool\fP \fILV\fP\fI_new\fP \fIVG\fP
.RE
.br
.RS 4
.ad l
[ \fB-l\fP|\fB--extents\fP \fINumber\fP[PERCENT] ]
.ad b
.br
.ad l
[ \fB-H\fP|\fB--cache\fP ]
.ad b
.br
.ad l
[ \fB-c\fP|\fB--chunksize\fP \fISize\fP[k|UNIT] ]
.ad b
.br
.ad l
[    \fB--poolmetadatasize\fP \fISize\fP[m|UNIT] ]
.ad b
.br
.ad l
[    \fB--poolmetadataspare\fP \fBy\fP|\fBn\fP ]
.ad b
.br
.ad l
[    \fB--cachemode\fP \fBwritethrough\fP|\fBwriteback\fP|\fBpassthrough\fP ]
.ad b
.br
.ad l
[    \fB--cachepolicy\fP \fIString\fP ]
.ad b
.br
.ad l
[    \fB--cachesettings\fP \fIString\fP ]
.ad b
.br
.ad l
[    \fB--cachemetadataformat\fP \fBauto\fP|\fB1\fP|\fB2\fP ]
.ad b
.br
[ COMMON_OPTIONS ]
.RE
.br
.RS 4
[ \fIPV\fP ... ]
.RE
-

Create a thin LV in a thin pool.
.br
.P
\fBlvcreate\fP \fB--type\fP \fBthin\fP \fB-V\fP|\fB--virtualsize\fP \fISize\fP[m|UNIT]
.RS 5
 \fB--thinpool\fP \fILV\fP\fI_thinpool\fP \fIVG\fP
.RE
.br
.RS 4
.ad l
[ \fB-T\fP|\fB--thin\fP ]
.ad b
.br
.ad l
[ \fB-c\fP|\fB--chunksize\fP \fISize\fP[k|UNIT] ]
.ad b
.br
.ad l
[    \fB--poolmetadatasize\fP \fISize\fP[m|UNIT] ]
.ad b
.br
.ad l
[    \fB--poolmetadataspare\fP \fBy\fP|\fBn\fP ]
.ad b
.br
.ad l
[    \fB--discards\fP \fBpassdown\fP|\fBnopassdown\fP|\fBignore\fP ]
.ad b
.br
.ad l
[    \fB--errorwhenfull\fP \fBy\fP|\fBn\fP ]
.ad b
.br
[ COMMON_OPTIONS ]
.RE
.br
-

Create a thin LV in a thin pool named in the first arg 
.br
(variant, also see --thinpool for naming pool).
.br
.P
\fBlvcreate\fP \fB--type\fP \fBthin\fP \fB-V\fP|\fB--virtualsize\fP \fISize\fP[m|UNIT] \fILV\fP\fI_thinpool\fP
.br
.RS 4
.ad l
[ \fB-T\fP|\fB--thin\fP ]
.ad b
.br
.ad l
[    \fB--discards\fP \fBpassdown\fP|\fBnopassdown\fP|\fBignore\fP ]
.ad b
.br
.ad l
[    \fB--errorwhenfull\fP \fBy\fP|\fBn\fP ]
.ad b
.br
[ COMMON_OPTIONS ]
.RE
.br
-

Create a thin LV in the thin pool named in the first arg 
.br
(variant, infers --type thin, also see --thinpool for 
.br
naming pool.)
.br
.P
\fBlvcreate\fP \fB-V\fP|\fB--virtualsize\fP \fISize\fP[m|UNIT] \fILV\fP\fI_thinpool\fP
.br
.RS 4
.ad l
[ \fB-T\fP|\fB--thin\fP ]
.ad b
.br
.ad l
[    \fB--type\fP \fBthin\fP ]
.ad b
.br
.ad l
[    \fB--discards\fP \fBpassdown\fP|\fBnopassdown\fP|\fBignore\fP ]
.ad b
.br
.ad l
[    \fB--errorwhenfull\fP \fBy\fP|\fBn\fP ]
.ad b
.br
[ COMMON_OPTIONS ]
.RE
.br
-

Create a thin LV that is a snapshot of an existing thin LV.
.br
.P
\fBlvcreate\fP \fB--type\fP \fBthin\fP \fILV\fP\fI_thin\fP
.br
.RS 4
.ad l
[ \fB-T\fP|\fB--thin\fP ]
.ad b
.br
.ad l
[    \fB--discards\fP \fBpassdown\fP|\fBnopassdown\fP|\fBignore\fP ]
.ad b
.br
.ad l
[    \fB--errorwhenfull\fP \fBy\fP|\fBn\fP ]
.ad b
.br
[ COMMON_OPTIONS ]
.RE
.br
-

Create a thin LV that is a snapshot of an existing thin LV 
.br
(infers --type thin).
.br
.P
\fBlvcreate\fP \fB-T\fP|\fB--thin\fP \fILV\fP\fI_thin\fP
.br
.RS 4
.ad l
[    \fB--type\fP \fBthin\fP ]
.ad b
.br
.ad l
[    \fB--discards\fP \fBpassdown\fP|\fBnopassdown\fP|\fBignore\fP ]
.ad b
.br
.ad l
[    \fB--errorwhenfull\fP \fBy\fP|\fBn\fP ]
.ad b
.br
[ COMMON_OPTIONS ]
.RE
.br
-

Create a thin LV that is a snapshot of an external origin LV 
.br
(infers --type thin).
.br
.P
\fBlvcreate\fP \fB-s\fP|\fB--snapshot\fP \fB--thinpool\fP \fILV\fP\fI_thinpool\fP \fILV\fP
.br
.RS 4
.ad l
[    \fB--type\fP \fBthin\fP ]
.ad b
.br
.ad l
[    \fB--discards\fP \fBpassdown\fP|\fBnopassdown\fP|\fBignore\fP ]
.ad b
.br
.ad l
[    \fB--errorwhenfull\fP \fBy\fP|\fBn\fP ]
.ad b
.br
[ COMMON_OPTIONS ]
.RE
.br
-

Create a VDO LV with VDO pool.
.br
.P
\fBlvcreate\fP \fB--vdo\fP \fB-L\fP|\fB--size\fP \fISize\fP[m|UNIT] \fIVG\fP
.br
.RS 4
.ad l
[ \fB-l\fP|\fB--extents\fP \fINumber\fP[PERCENT] ]
.ad b
.br
.ad l
[ \fB-V\fP|\fB--virtualsize\fP \fISize\fP[m|UNIT] ]
.ad b
.br
.ad l
[ \fB-i\fP|\fB--stripes\fP \fINumber\fP ]
.ad b
.br
.ad l
[ \fB-I\fP|\fB--stripesize\fP \fISize\fP[k|UNIT] ]
.ad b
.br
.ad l
[    \fB--vdopool\fP \fILV\fP\fI_new\fP ]
.ad b
.br
.ad l
[    \fB--compression\fP \fBy\fP|\fBn\fP ]
.ad b
.br
.ad l
[    \fB--deduplication\fP \fBy\fP|\fBn\fP ]
.ad b
.br
[ COMMON_OPTIONS ]
.RE
.br
.RS 4
[ \fIPV\fP ... ]
.RE
-

Create a VDO LV with VDO pool.
.br
.P
\fBlvcreate\fP \fB--vdopool\fP \fILV\fP\fI_new\fP \fB-L\fP|\fB--size\fP \fISize\fP[m|UNIT] \fIVG\fP
.br
.RS 4
.ad l
[ \fB-l\fP|\fB--extents\fP \fINumber\fP[PERCENT] ]
.ad b
.br
.ad l
[ \fB-V\fP|\fB--virtualsize\fP \fISize\fP[m|UNIT] ]
.ad b
.br
.ad l
[ \fB-i\fP|\fB--stripes\fP \fINumber\fP ]
.ad b
.br
.ad l
[ \fB-I\fP|\fB--stripesize\fP \fISize\fP[k|UNIT] ]
.ad b
.br
.ad l
[    \fB--vdo\fP ]
.ad b
.br
.ad l
[    \fB--type\fP \fBvdo\fP ]
.ad b
.br
.ad l
[    \fB--compression\fP \fBy\fP|\fBn\fP ]
.ad b
.br
.ad l
[    \fB--deduplication\fP \fBy\fP|\fBn\fP ]
.ad b
.br
[ COMMON_OPTIONS ]
.RE
.br
.RS 4
[ \fIPV\fP ... ]
.RE
-

Create a thin LV, first creating a thin pool for it, 
.br
where the new thin pool is named by the --thinpool arg 
.br
(variant, infers --type thin).
.br
.P
\fBlvcreate\fP \fB-V\fP|\fB--virtualsize\fP \fISize\fP[m|UNIT] \fB-L\fP|\fB--size\fP \fISize\fP[m|UNIT]
.RS 5
 \fB--thinpool\fP \fILV\fP\fI_new\fP
.RE
.br
.RS 4
.ad l
[ \fB-l\fP|\fB--extents\fP \fINumber\fP[PERCENT] ]
.ad b
.br
.ad l
[ \fB-T\fP|\fB--thin\fP ]
.ad b
.br
.ad l
[ \fB-c\fP|\fB--chunksize\fP \fISize\fP[k|UNIT] ]
.ad b
.br
.ad l
[ \fB-i\fP|\fB--stripes\fP \fINumber\fP ]
.ad b
.br
.ad l
[ \fB-I\fP|\fB--stripesize\fP \fISize\fP[k|UNIT] ]
.ad b
.br
.ad l
[    \fB--poolmetadatasize\fP \fISize\fP[m|UNIT] ]
.ad b
.br
.ad l
[    \fB--poolmetadataspare\fP \fBy\fP|\fBn\fP ]
.ad b
.br
.ad l
[    \fB--discards\fP \fBpassdown\fP|\fBnopassdown\fP|\fBignore\fP ]
.ad b
.br
.ad l
[    \fB--errorwhenfull\fP \fBy\fP|\fBn\fP ]
.ad b
.br
[ COMMON_OPTIONS ]
.RE
.br
.RS 4
[ \fIPV\fP ... ]
.RE
-

Create a thin LV, first creating a thin pool for it, 
.br
where the new thin pool is named by the --thinpool arg 
.br
(variant, infers --type thin).
.br
.P
\fBlvcreate\fP \fB-V\fP|\fB--virtualsize\fP \fISize\fP[m|UNIT] \fB-L\fP|\fB--size\fP \fISize\fP[m|UNIT]
.RS 5
 \fB--thinpool\fP \fILV\fP\fI_new\fP \fIVG\fP
.RE
.br
.RS 4
.ad l
[ \fB-l\fP|\fB--extents\fP \fINumber\fP[PERCENT] ]
.ad b
.br
.ad l
[ \fB-T\fP|\fB--thin\fP ]
.ad b
.br
.ad l
[ \fB-c\fP|\fB--chunksize\fP \fISize\fP[k|UNIT] ]
.ad b
.br
.ad l
[ \fB-i\fP|\fB--stripes\fP \fINumber\fP ]
.ad b
.br
.ad l
[ \fB-I\fP|\fB--stripesize\fP \fISize\fP[k|UNIT] ]
.ad b
.br
.ad l
[    \fB--poolmetadatasize\fP \fISize\fP[m|UNIT] ]
.ad b
.br
.ad l
[    \fB--poolmetadataspare\fP \fBy\fP|\fBn\fP ]
.ad b
.br
.ad l
[    \fB--discards\fP \fBpassdown\fP|\fBnopassdown\fP|\fBignore\fP ]
.ad b
.br
.ad l
[    \fB--errorwhenfull\fP \fBy\fP|\fBn\fP ]
.ad b
.br
[ COMMON_OPTIONS ]
.RE
.br
.RS 4
[ \fIPV\fP ... ]
.RE
-

Create a thin LV, first creating a thin pool for it, 
.br
where the new thin pool is named in the first arg, 
.br
or the new thin pool name is generated when the first 
.br
arg is a VG name.
.br
.P
\fBlvcreate\fP \fB--type\fP \fBthin\fP \fB-V\fP|\fB--virtualsize\fP \fISize\fP[m|UNIT]
.RS 5
 \fB-L\fP|\fB--size\fP \fISize\fP[m|UNIT] \fIVG\fP|\fILV\fP\fI_new\fP
.RE
.br
.RS 4
.ad l
[ \fB-l\fP|\fB--extents\fP \fINumber\fP[PERCENT] ]
.ad b
.br
.ad l
[ \fB-T\fP|\fB--thin\fP ]
.ad b
.br
.ad l
[ \fB-c\fP|\fB--chunksize\fP \fISize\fP[k|UNIT] ]
.ad b
.br
.ad l
[ \fB-i\fP|\fB--stripes\fP \fINumber\fP ]
.ad b
.br
.ad l
[ \fB-I\fP|\fB--stripesize\fP \fISize\fP[k|UNIT] ]
.ad b
.br
.ad l
[    \fB--poolmetadatasize\fP \fISize\fP[m|UNIT] ]
.ad b
.br
.ad l
[    \fB--poolmetadataspare\fP \fBy\fP|\fBn\fP ]
.ad b
.br
.ad l
[    \fB--discards\fP \fBpassdown\fP|\fBnopassdown\fP|\fBignore\fP ]
.ad b
.br
.ad l
[    \fB--errorwhenfull\fP \fBy\fP|\fBn\fP ]
.ad b
.br
[ COMMON_OPTIONS ]
.RE
.br
.RS 4
[ \fIPV\fP ... ]
.RE
-

Create a thin LV, first creating a thin pool for it, 
.br
where the new thin pool is named in the first arg, 
.br
or the new thin pool name is generated when the first 
.br
arg is a VG name (variant, infers --type thin).
.br
.P
\fBlvcreate\fP \fB-T\fP|\fB--thin\fP \fB-V\fP|\fB--virtualsize\fP \fISize\fP[m|UNIT]
.RS 5
 \fB-L\fP|\fB--size\fP \fISize\fP[m|UNIT] \fIVG\fP|\fILV\fP\fI_new\fP
.RE
.br
.RS 4
.ad l
[ \fB-l\fP|\fB--extents\fP \fINumber\fP[PERCENT] ]
.ad b
.br
.ad l
[ \fB-c\fP|\fB--chunksize\fP \fISize\fP[k|UNIT] ]
.ad b
.br
.ad l
[ \fB-i\fP|\fB--stripes\fP \fINumber\fP ]
.ad b
.br
.ad l
[ \fB-I\fP|\fB--stripesize\fP \fISize\fP[k|UNIT] ]
.ad b
.br
.ad l
[    \fB--poolmetadatasize\fP \fISize\fP[m|UNIT] ]
.ad b
.br
.ad l
[    \fB--poolmetadataspare\fP \fBy\fP|\fBn\fP ]
.ad b
.br
.ad l
[    \fB--discards\fP \fBpassdown\fP|\fBnopassdown\fP|\fBignore\fP ]
.ad b
.br
.ad l
[    \fB--errorwhenfull\fP \fBy\fP|\fBn\fP ]
.ad b
.br
[ COMMON_OPTIONS ]
.RE
.br
.RS 4
[ \fIPV\fP ... ]
.RE
-

Create a thin LV, first creating a thin pool for it 
.br
(infers --type thin). 
.br
Create a sparse snapshot of a virtual origin LV 
.br
(infers --type snapshot). 
.br
Chooses --type thin or --type snapshot according to 
.br
config setting sparse_segtype_default.
.br
.P
\fBlvcreate\fP \fB-L\fP|\fB--size\fP \fISize\fP[m|UNIT] \fB-V\fP|\fB--virtualsize\fP \fISize\fP[m|UNIT] \fIVG\fP
.br
.RS 4
.ad l
[ \fB-l\fP|\fB--extents\fP \fINumber\fP[PERCENT] ]
.ad b
.br
.ad l
[ \fB-s\fP|\fB--snapshot\fP ]
.ad b
.br
.ad l
[ \fB-c\fP|\fB--chunksize\fP \fISize\fP[k|UNIT] ]
.ad b
.br
.ad l
[ \fB-i\fP|\fB--stripes\fP \fINumber\fP ]
.ad b
.br
.ad l
[ \fB-I\fP|\fB--stripesize\fP \fISize\fP[k|UNIT] ]
.ad b
.br
.ad l
[    \fB--type\fP \fBsnapshot\fP ]
.ad b
.br
.ad l
[    \fB--poolmetadatasize\fP \fISize\fP[m|UNIT] ]
.ad b
.br
.ad l
[    \fB--poolmetadataspare\fP \fBy\fP|\fBn\fP ]
.ad b
.br
.ad l
[    \fB--discards\fP \fBpassdown\fP|\fBnopassdown\fP|\fBignore\fP ]
.ad b
.br
.ad l
[    \fB--errorwhenfull\fP \fBy\fP|\fBn\fP ]
.ad b
.br
[ COMMON_OPTIONS ]
.RE
.br
.RS 4
[ \fIPV\fP ... ]
.RE
-

Create a cache LV, first creating a new origin LV, 
.br
then combining it with the existing cache pool named 
.br
by the --cachepool arg (variant, infers --type cache).
.br
.P
\fBlvcreate\fP \fB-L\fP|\fB--size\fP \fISize\fP[m|UNIT] \fB--cachepool\fP \fILV\fP\fI_cachepool\fP \fIVG\fP
.br
.RS 4
.ad l
[ \fB-l\fP|\fB--extents\fP \fINumber\fP[PERCENT] ]
.ad b
.br
.ad l
[ \fB-H\fP|\fB--cache\fP ]
.ad b
.br
.ad l
[ \fB-c\fP|\fB--chunksize\fP \fISize\fP[k|UNIT] ]
.ad b
.br
.ad l
[ \fB-i\fP|\fB--stripes\fP \fINumber\fP ]
.ad b
.br
.ad l
[ \fB-I\fP|\fB--stripesize\fP \fISize\fP[k|UNIT] ]
.ad b
.br
.ad l
[    \fB--type\fP \fBcache\fP ]
.ad b
.br
.ad l
[    \fB--cachemode\fP \fBwritethrough\fP|\fBwriteback\fP|\fBpassthrough\fP ]
.ad b
.br
.ad l
[    \fB--cachepolicy\fP \fIString\fP ]
.ad b
.br
.ad l
[    \fB--cachesettings\fP \fIString\fP ]
.ad b
.br
.ad l
[    \fB--cachemetadataformat\fP \fBauto\fP|\fB1\fP|\fB2\fP ]
.ad b
.br
[ COMMON_OPTIONS ]
.RE
.br
.RS 4
[ \fIPV\fP ... ]
.RE
-

Create a cache LV, first creating a new origin LV, 
.br
then combining it with the existing cache pool named 
.br
in the first arg (variant, also use --cachepool).
.br
.P
\fBlvcreate\fP \fB--type\fP \fBcache\fP \fB-L\fP|\fB--size\fP \fISize\fP[m|UNIT] \fILV\fP\fI_cachepool\fP
.br
.RS 4
.ad l
[ \fB-l\fP|\fB--extents\fP \fINumber\fP[PERCENT] ]
.ad b
.br
.ad l
[ \fB-H\fP|\fB--cache\fP ]
.ad b
.br
.ad l
[ \fB-c\fP|\fB--chunksize\fP \fISize\fP[k|UNIT] ]
.ad b
.br
.ad l
[ \fB-i\fP|\fB--stripes\fP \fINumber\fP ]
.ad b
.br
.ad l
[ \fB-I\fP|\fB--stripesize\fP \fISize\fP[k|UNIT] ]
.ad b
.br
.ad l
[    \fB--poolmetadatasize\fP \fISize\fP[m|UNIT] ]
.ad b
.br
.ad l
[    \fB--poolmetadataspare\fP \fBy\fP|\fBn\fP ]
.ad b
.br
.ad l
[    \fB--cachemode\fP \fBwritethrough\fP|\fBwriteback\fP|\fBpassthrough\fP ]
.ad b
.br
.ad l
[    \fB--cachepolicy\fP \fIString\fP ]
.ad b
.br
.ad l
[    \fB--cachesettings\fP \fIString\fP ]
.ad b
.br
.ad l
[    \fB--cachemetadataformat\fP \fBauto\fP|\fB1\fP|\fB2\fP ]
.ad b
.br
[ COMMON_OPTIONS ]
.RE
.br
.RS 4
[ \fIPV\fP ... ]
.RE
-

When LV is a cache pool, create a cache LV, 
.br
first creating a new origin LV, then combining it with 
.br
the existing cache pool named in the first arg 
.br
(variant, infers --type cache, also use --cachepool). 
.br
When LV is not a cache pool, convert the specified LV 
.br
to type cache after creating a new cache pool LV to use 
.br
(use lvconvert).
.br
.P
\fBlvcreate\fP \fB-H\fP|\fB--cache\fP \fB-L\fP|\fB--size\fP \fISize\fP[m|UNIT] \fILV\fP
.br
.RS 4
.ad l
[ \fB-l\fP|\fB--extents\fP \fINumber\fP[PERCENT] ]
.ad b
.br
.ad l
[ \fB-c\fP|\fB--chunksize\fP \fISize\fP[k|UNIT] ]
.ad b
.br
.ad l
[ \fB-i\fP|\fB--stripes\fP \fINumber\fP ]
.ad b
.br
.ad l
[ \fB-I\fP|\fB--stripesize\fP \fISize\fP[k|UNIT] ]
.ad b
.br
.ad l
[    \fB--cachemode\fP \fBwritethrough\fP|\fBwriteback\fP|\fBpassthrough\fP ]
.ad b
.br
.ad l
[    \fB--cachepolicy\fP \fIString\fP ]
.ad b
.br
.ad l
[    \fB--cachesettings\fP \fIString\fP ]
.ad b
.br
.ad l
[    \fB--cachemetadataformat\fP \fBauto\fP|\fB1\fP|\fB2\fP ]
.ad b
.br
.ad l
[    \fB--poolmetadatasize\fP \fISize\fP[m|UNIT] ]
.ad b
.br
.ad l
[    \fB--poolmetadataspare\fP \fBy\fP|\fBn\fP ]
.ad b
.br
[ COMMON_OPTIONS ]
.RE
.br
.RS 4
[ \fIPV\fP ... ]
.RE
-

.SH EXAMPLES

Create a striped LV with 3 stripes, a stripe size of 8KiB and a size of 100MiB.
The LV name is chosen by lvcreate.
.br
.B lvcreate -i 3 -I 8 -L 100m vg00

Create a raid1 LV with two images, and a useable size of 500 MiB. This
operation requires two devices, one for each mirror image. RAID metadata
(superblock and bitmap) is also included on the two devices.
.br
.B lvcreate --type raid1 -m1 -L 500m -n mylv vg00

Create a mirror LV with two images, and a useable size of 500 MiB.
This operation requires three devices: two for mirror images and
one for a disk log.
.br
.B lvcreate --type mirror -m1 -L 500m -n mylv vg00

Create a mirror LV with 2 images, and a useable size of 500 MiB.
This operation requires 2 devices because the log is in memory.
.br
.B lvcreate --type mirror -m1 --mirrorlog core -L 500m -n mylv vg00

Create a copy-on-write snapshot of an LV:
.br
.B lvcreate --snapshot --size 100m --name mysnap vg00/mylv

Create a copy-on-write snapshot with a size sufficient
for overwriting 20% of the size of the original LV.
.br
.B lvcreate -s -l 20%ORIGIN -n mysnap vg00/mylv

Create a sparse LV with 1TiB of virtual space, and actual space just under
100MiB.
.br
.B lvcreate --snapshot --virtualsize 1t --size 100m --name mylv vg00

Create a linear LV with a usable size of 64MiB on specific physical extents.
.br
.B lvcreate -L 64m -n mylv vg00 /dev/sda:0-7 /dev/sdb:0-7

Create a RAID5 LV with a usable size of 5GiB, 3 stripes, a stripe size of
64KiB, using a total of 4 devices (including one for parity).
.br
.B lvcreate --type raid5 -L 5G -i 3 -I 64 -n mylv vg00

Create a RAID5 LV using all of the free space in the VG and spanning all the
PVs in the VG (note that the command will fail if there are more than 8 PVs in
the VG, in which case \fB-i 7\fP must be used to get to the current maximum of
8 devices including parity for RaidLVs).
.br
.B lvcreate --config allocation/raid_stripe_all_devices=1
.RS
.B --type raid5 -l 100%FREE -n mylv vg00
.RE

Create RAID10 LV with a usable size of 5GiB, using 2 stripes, each on
a two-image mirror. (Note that the \fB-i\fP and \fB-m\fP arguments behave
differently:
\fB-i\fP specifies the total number of stripes,
but \fB-m\fP specifies the number of images in addition
to the first image).
.br
.B lvcreate --type raid10 -L 5G -i 2 -m 1 -n mylv vg00

Create a 1TiB thin LV mythin, with 256GiB thinpool tpool0 in vg00.
.br
.B lvcreate --T --size 256G --name mythin vg00/tpool0

Create a 1TiB thin LV, first creating a new thin pool for it, where
the thin pool has 100MiB of space, uses 2 stripes, has a 64KiB stripe
size, and 256KiB chunk size.
.br
.B lvcreate --type thin --name mylv --thinpool mypool
.RS
.B -V 1t -L 100m -i 2 -I 64 -c 256 vg00
.RE

Create a thin snapshot of a thin LV (the size option must not be
used, otherwise a copy-on-write snapshot would be created).
.br
.B lvcreate --snapshot --name mysnap vg00/thinvol

Create a thin snapshot of the read-only inactive LV named "origin"
which becomes an external origin for the thin snapshot LV.
.br
.B lvcreate --snapshot --name mysnap --thinpool mypool vg00/origin

Create a cache pool from a fast physical device. The cache pool can
then be used to cache an LV.
.br
.B lvcreate --type cache-pool -L 1G -n my_cpool vg00 /dev/fast1

Create a cache LV, first creating a new origin LV on a slow physical device,
then combining the new origin LV with an existing cache pool.
.br
.B lvcreate --type cache --cachepool my_cpool
.RS
.B -L 100G -n mylv vg00 /dev/slow1
.RE

Create a VDO LV vdo0 with VDOPoolLV size of 10GiB and name vpool1.
.br
.B lvcreate --vdo --size 10G --name vdo0 vg00/vpool1
.SH SEE ALSO

.BR lvm (8)
.BR lvm.conf (5)
.BR lvmconfig (8)

.BR pvchange (8)
.BR pvck (8)
.BR pvcreate (8)
.BR pvdisplay (8)
.BR pvmove (8)
.BR pvremove (8)
.BR pvresize (8)
.BR pvs (8)
.BR pvscan (8) 

.BR vgcfgbackup (8)
.BR vgcfgrestore (8)
.BR vgchange (8)
.BR vgck (8)
.BR vgcreate (8)
.BR vgconvert (8)
.BR vgdisplay (8)
.BR vgexport (8)
.BR vgextend (8)
.BR vgimport (8)
.BR vgimportclone (8)
.BR vgmerge (8)
.BR vgmknodes (8)
.BR vgreduce (8)
.BR vgremove (8)
.BR vgrename (8)
.BR vgs (8)
.BR vgscan (8)
.BR vgsplit (8) 

.BR lvcreate (8)
.BR lvchange (8)
.BR lvconvert (8)
.BR lvdisplay (8)
.BR lvextend (8)
.BR lvreduce (8)
.BR lvremove (8)
.BR lvrename (8)
.BR lvresize (8)
.BR lvs (8)
.BR lvscan (8)

.BR lvm-fullreport (8)
.BR lvm-lvpoll (8)
.BR lvm2-activation-generator (8)
.BR blkdeactivate (8)
.BR lvmdump (8)

.BR dmeventd (8)
.BR lvmpolld (8)
.BR lvmlockd (8)
.BR lvmlockctl (8)
.BR cmirrord (8)
.BR lvmdbusd (8)

.BR lvmsystemid (7)
.BR lvmreport (7)
.BR lvmraid (7)
.BR lvmthin (7)
.BR lvmcache (7)
