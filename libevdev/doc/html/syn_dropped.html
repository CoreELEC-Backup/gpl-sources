<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.15"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>libevdev: SYN_DROPPED handling</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="bootstrap.css" rel="stylesheet" type="text/css"/>
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
<link href="libevdevdoxygen.css" rel="stylesheet" type="text/css"/>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="doxy-boot.js"></script>
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">libevdev 1.8.0</a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel panel-default" style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">SYN_DROPPED handling </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This page describes how libevdev handles SYN_DROPPED events.</p>
<h1>Receiving SYN_DROPPED events </h1>
<p>The kernel sends evdev events separated by an event of type EV_SYN and code SYN_REPORT. Such an event marks the end of a frame of hardware events. The number of events between SYN_REPORT events is arbitrary and depends on the hardware. An example event sequence may look like this: </p><div class="fragment"><div class="line">EV_ABS   ABS_X        9</div><div class="line">EV_ABS   ABS_Y        8</div><div class="line">EV_SYN   SYN_REPORT   0</div><div class="line">------------------------</div><div class="line">EV_ABS   ABS_X        10</div><div class="line">EV_ABS   ABS_Y        10</div><div class="line">EV_KEY   BTN_TOUCH    1</div><div class="line">EV_SYN   SYN_REPORT   0</div><div class="line">------------------------</div><div class="line">EV_ABS   ABS_X        11</div><div class="line">EV_SYN   SYN_REPORT   0</div></div><!-- fragment --><p>Events are handed to the client buffer as they appear, the kernel adjusts the buffer size to handle at least one full event. In the normal case, the client reads the event and the kernel can place the next event in the buffer. If the client is not fast enough, the kernel places an event of type EV_SYN and code SYN_DROPPED into the buffer, effectively notifying the client that some events were lost. The above example event sequence may look like this (note the missing/repeated events): </p><div class="fragment"><div class="line">EV_ABS   ABS_X        9</div><div class="line">EV_ABS   ABS_Y        8</div><div class="line">EV_SYN   SYN_REPORT   0</div><div class="line">------------------------</div><div class="line">EV_ABS   ABS_X        10</div><div class="line">EV_ABS   ABS_Y        10</div><div class="line">EV_SYN   SYN_DROPPED  0</div><div class="line">EV_ABS   ABS_Y        15</div><div class="line">EV_SYN   SYN_REPORT   0</div><div class="line">------------------------</div><div class="line">EV_ABS   ABS_X        11</div><div class="line">EV_KEY   BTN_TOUCH    0</div><div class="line">EV_SYN   SYN_REPORT   0</div></div><!-- fragment --><p>A SYN_DROPPED event may be recieved at any time in the event sequence. When a SYN_DROPPED event is received, the client must:</p><ul>
<li>discard all events since the last SYN_REPORT</li>
<li>discard all events until including the next SYN_REPORT These event are part of incomplete event frames.</li>
</ul>
<h1>Synchronizing the state of the device </h1>
<p>The handling of the device after a SYN_DROPPED depends on the available event codes. For all event codes of type EV_REL, no handling is necessary, there is no state attached. For all event codes of type EV_KEY, EV_SW, EV_LED and EV_SND, the matching <a class="el" href="ioctls.html">evdev ioctls</a> retrieve the current state. The caller must then compare the last-known state to the retrieved state and handle the deltas accordingly. libevdev simplifies this approach: if the state of the device has changed, libevdev generates an event for each code with the new value and passes it to the caller during <a class="el" href="group__events.html#gabb96c864e836c0b98788f4ab771c3a76" title="Get the next event from the device.">libevdev_next_event()</a> if <a class="el" href="group__events.html#gga56c288d9f2e4c1632986c4e218c494e9a1f13a19641d6dafcf01a86a6389800f8">LIBEVDEV_READ_FLAG_SYNC</a> is set.</p>
<p>For events of type EV_ABS and an event code less than ABS_MT_SLOT, the handling of state changes is as described above. For events between ABS_MT_SLOT and ABS_MAX, the event handling differs. Slots are the vehicles to transport information for multiple simultaneous touchpoints on a device. Slots are re-used once a touchpoint has ended. The kernel sends an ABS_MT_SLOT event whenever the current slot changes; any event in the above axis range applies only to the currently active slot. Thus, an event sequence from a slot-capable device may look like this: </p><div class="fragment"><div class="line">EV_ABS   ABS_MT_POSITION_Y   10</div><div class="line">EV_ABS   ABS_MT_SLOT         1</div><div class="line">EV_ABS   ABS_MT_POSITION_X   100</div><div class="line">EV_ABS   ABS_MT_POSITION_Y   80</div><div class="line">EV_SYN   SYN_REPORT          0</div></div><!-- fragment --><p> Note the lack of ABS_MT_SLOT: the first ABS_MT_POSITION_Y applies to a slot opened previously, and is the only axis that changed for that slot. The touchpoint in slot 1 now has position 100/80. The kernel does not provide events if a value does not change, and does not send ABS_MT_SLOT events if the slot does not change, or none of the values within a slot changes. A client must thus keep the state for each slot.</p>
<p>If a SYN_DROPPED is received, the client must sync all slots individually and update its internal state. libevdev simplifies this by generating multiple events:</p><ul>
<li>for each slot on the device, libevdev generates an ABS_MT_SLOT event with the value set to the slot number</li>
<li>for each event code between ABS_MT_SLOT + 1 and ABS_MAX that changed state for this slot, libevdev generates an event for the new state</li>
<li>libevdev sends a final ABS_MT_SLOT event for the current slot as seen by the kernel</li>
<li>libevdev terminates this sequence with an EV_SYN SYN_REPORT event</li>
</ul>
<p>An example event sequence for such a sync may look like this: </p><div class="fragment"><div class="line">EV_ABS   ABS_MT_SLOT         0</div><div class="line">EV_ABS   ABS_MT_POSITION_Y   10</div><div class="line">EV_ABS   ABS_MT_SLOT         1</div><div class="line">EV_ABS   ABS_MT_POSITION_X   100</div><div class="line">EV_ABS   ABS_MT_POSITION_Y   80</div><div class="line">EV_ABS   ABS_MT_SLOT         2</div><div class="line">EV_ABS   ABS_MT_POSITION_Y   8</div><div class="line">EV_ABS   ABS_MT_PRESSURE     12</div><div class="line">EV_ABS   ABS_MT_SLOT         1</div><div class="line">EV_SYN   SYN_REPORT          0</div></div><!-- fragment --><p> Note the terminating ABS_MT_SLOT event, this indicates that the kernel currently has slot 1 active.</p>
<h1>Synchronizing ABS_MT_TRACKING_ID </h1>
<p>The event code ABS_MT_TRACKING_ID is used to denote the start and end of a touch point within a slot. An ABS_MT_TRACKING_ID of zero or greater denotes the start of a touchpoint, an ABS_MT_TRACKING_ID of -1 denotes the end of a touchpoint within this slot. During SYN_DROPPED, a touch point may have ended and re-started within a slot - a client must check the ABS_MT_TRACKING_ID. libevdev simplifies this by emulating extra events if the ABS_MT_TRACKING_ID has changed:</p><ul>
<li>if the ABS_MT_TRACKING_ID was valid and is -1, libevdev enqueues an ABS_MT_TRACKING_ID event with value -1.</li>
<li>if the ABS_MT_TRACKING_ID was -1 and is now a valid ID, libevdev enqueues an ABS_MT_TRACKING_ID event with the current value.</li>
<li>if the ABS_MT_TRACKING_ID was a valid ID and is now a different valid ID, libevev enqueues an ABS_MT_TRACKING_ID event with value -1 and another ABS_MT_TRACKING_ID event with the new value.</li>
</ul>
<p>An example event sequence for such a sync may look like this: </p><div class="fragment"><div class="line">EV_ABS   ABS_MT_SLOT         0</div><div class="line">EV_ABS   ABS_MT_TRACKING_ID  -1</div><div class="line">EV_ABS   ABS_MT_SLOT         2</div><div class="line">EV_ABS   ABS_MT_TRACKING_ID  -1</div><div class="line">EV_SYN   SYN_REPORT          0</div><div class="line">------------------------</div><div class="line">EV_ABS   ABS_MT_SLOT         1</div><div class="line">EV_ABS   ABS_MT_POSITION_X   100</div><div class="line">EV_ABS   ABS_MT_POSITION_Y   80</div><div class="line">EV_ABS   ABS_MT_SLOT         2</div><div class="line">EV_ABS   ABS_MT_TRACKING_ID  45</div><div class="line">EV_ABS   ABS_MT_POSITION_Y   8</div><div class="line">EV_ABS   ABS_MT_PRESSURE     12</div><div class="line">EV_ABS   ABS_MT_SLOT         1</div><div class="line">EV_SYN   SYN_REPORT          0</div></div><!-- fragment --><p> Note how the touchpoint in slot 0 was terminated, the touchpoint in slot 2 was terminated and then started with a new ABS_MT_TRACKING_ID. The touchpoint in slot 1 maintained the same ABS_MT_TRACKING_ID and only updated the coordinates. Slot 1 is the currently active slot.</p>
<p>In the case of a SYN_DROPPED event, a touch point may be invisible to a client if it started after SYN_DROPPED and finished before the client handles events again. The below example shows an example event sequence and what libevdev sees in the case of a SYN_DROPPED event: </p><div class="fragment"><div class="line">          kernel                  |              userspace</div><div class="line">                                  |</div><div class="line">EV_ABS   ABS_MT_SLOT         0    |    EV_ABS   ABS_MT_SLOT         0</div><div class="line">EV_ABS   ABS_MT_TRACKING_ID  -1   |    EV_ABS   ABS_MT_TRACKING_ID  -1</div><div class="line">EV_SYN   SYN_REPORT          0    |    EV_SYN   SYN_REPORT          0</div><div class="line">------------------------          |    ------------------------</div><div class="line">EV_ABS   ABS_MT_TRACKING_ID  30   |</div><div class="line">EV_ABS   ABS_MT_POSITION_X   100  |</div><div class="line">EV_ABS   ABS_MT_POSITION_Y   80   |</div><div class="line">EV_SYN   SYN_REPORT          0    |           SYN_DROPPED</div><div class="line">------------------------          |</div><div class="line">EV_ABS   ABS_MT_TRACKING_ID  -1   |</div><div class="line">EV_SYN   SYN_REPORT          0    |</div><div class="line">------------------------          |    ------------------------</div><div class="line">EV_ABS   ABS_MT_SLOT         1    |    EV_ABS   ABS_MT_SLOT         1</div><div class="line">EV_ABS   ABS_MT_POSITION_X   90   |    EV_ABS   ABS_MT_POSITION_X   90</div><div class="line">EV_ABS   ABS_MT_POSITION_Y   10   |    EV_ABS   ABS_MT_POSITION_Y   10</div><div class="line">EV_SYN   SYN_REPORT          0    |    EV_SYN   SYN_REPORT          0</div></div><!-- fragment --><p> If such an event sequence occurs, libevdev will send all updated axes during the sync process. Axis events may thus be generated for devices without a currently valid ABS_MT_TRACKING_ID. Specifically for the above example, the client would receive the following event sequence: </p><div class="fragment"><div class="line">EV_ABS   ABS_MT_SLOT         0       ← <a class="code" href="group__events.html#gga56c288d9f2e4c1632986c4e218c494e9ac0d6ee19551eecf76f1ede4f36252418">LIBEVDEV_READ_FLAG_NORMAL</a></div><div class="line">EV_ABS   ABS_MT_TRACKING_ID  -1</div><div class="line">EV_SYN   SYN_REPORT          0</div><div class="line">------------------------</div><div class="line">EV_SYN   SYN_DROPPED         0       → <a class="code" href="group__events.html#gga4a96221b3c7f54dfb86035d952154e3aa8d70b14a38204fde4ad433023baa545a">LIBEVDEV_READ_STATUS_SYNC</a></div><div class="line">------------------------</div><div class="line">EV_ABS   ABS_MT_POSITION_X   100     ← <a class="code" href="group__events.html#gga56c288d9f2e4c1632986c4e218c494e9a1f13a19641d6dafcf01a86a6389800f8">LIBEVDEV_READ_FLAG_SYNC</a></div><div class="line">EV_ABS   ABS_MT_POSITION_Y   80</div><div class="line">EV_SYN   SYN_REPORT          0</div><div class="line">-----------------------------        → -EGAIN</div><div class="line">EV_ABS   ABS_MT_SLOT         1       ← <a class="code" href="group__events.html#gga56c288d9f2e4c1632986c4e218c494e9ac0d6ee19551eecf76f1ede4f36252418">LIBEVDEV_READ_FLAG_NORMAL</a></div><div class="line">EV_ABS   ABS_MT_POSITION_X   90</div><div class="line">EV_ABS   ABS_MT_POSITION_Y   10</div><div class="line">EV_SYN   SYN_REPORT          0</div><div class="line">-------------------</div></div><!-- fragment --><p> The axis events do not reflect the position of a current touch point, a client must take care not to generate a new touch point based on those updates.</p>
<h1>Discarding events before synchronizing </h1>
<p>The kernel implements the client buffer as a ring buffer. SYN_DROPPED events are handled when the buffer is full and a new event is received from a device. All existing events are discarded, a SYN_DROPPED is added to the buffer followed by the actual device event. Further events will be appended to the buffer until it is either read by the client, or filled again, at which point the sequence repeats.</p>
<p>When the client reads the buffer, the buffer will thus always consist of exactly one SYN_DROPPED event followed by an unspecified number of real events. The data the ioctls return is the current state of the device, i.e. the state after all these events have been processed. For example, assume the buffer contains the following sequence:</p>
<div class="fragment"><div class="line">EV_SYN   SYN_DROPPED</div><div class="line">EV_ABS   ABS_X               1</div><div class="line">EV_SYN   SYN_REPORT          0</div><div class="line">EV_ABS   ABS_X               2</div><div class="line">EV_SYN   SYN_REPORT          0</div><div class="line">EV_ABS   ABS_X               3</div><div class="line">EV_SYN   SYN_REPORT          0</div><div class="line">EV_ABS   ABS_X               4</div><div class="line">EV_SYN   SYN_REPORT          0</div><div class="line">EV_ABS   ABS_X               5</div><div class="line">EV_SYN   SYN_REPORT          0</div><div class="line">EV_ABS   ABS_X               6</div><div class="line">EV_SYN   SYN_REPORT          0</div></div><!-- fragment --><p> An ioctl at any time in this sequence will return a value of 6 for ABS_X.</p>
<p>libevdev discards all events after a SYN_DROPPED to ensure the events during <a class="el" href="group__events.html#gga56c288d9f2e4c1632986c4e218c494e9a1f13a19641d6dafcf01a86a6389800f8">LIBEVDEV_READ_FLAG_SYNC</a> represent the last known state of the device. This loses some granularity of the events especially as the time between the SYN_DROPPED and the sync process increases. It does however avoid spurious cursor movements. In the above example, the event sequence by libevdev is: </p><div class="fragment"><div class="line">EV_SYN   SYN_DROPPED</div><div class="line">EV_ABS   ABS_X               6</div><div class="line">EV_SYN   SYN_REPORT          0</div></div><!-- fragment --> </div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
