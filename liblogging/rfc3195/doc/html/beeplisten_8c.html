<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>liblogging: beeplisten.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Compound&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Compound&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>beeplisten.c File Reference</h1>Implementation of the (BEEP) listener Object.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;assert.h&gt;</code><br>
<code>#include "<a class="el" href="config_8h-source.html">config.h</a>"</code><br>
<code>#include "<a class="el" href="liblogging_8h-source.html">liblogging.h</a>"</code><br>
<code>#include "<a class="el" href="sockets_8h-source.html">sockets.h</a>"</code><br>
<code>#include "<a class="el" href="beepsession_8h-source.html">beepsession.h</a>"</code><br>
<code>#include "<a class="el" href="beepchannel_8h-source.html">beepchannel.h</a>"</code><br>
<code>#include "<a class="el" href="beepframe_8h-source.html">beepframe.h</a>"</code><br>
<code>#include "<a class="el" href="beeplisten_8h-source.html">beeplisten.h</a>"</code><br>
<code>#include "<a class="el" href="namevaluetree_8h-source.html">namevaluetree.h</a>"</code><br>
<code>#include "<a class="el" href="stringbuf_8h-source.html">stringbuf.h</a>"</code><br>
<code>#include "<a class="el" href="syslogmessage_8h-source.html">syslogmessage.h</a>"</code><br>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="beeplisten_8c.html#a2">sbLstnOnFramRcvd</a> (<a class="el" href="structsbLstnObject.html">sbLstnObj</a> *pThis, int *pbAbort, <a class="el" href="structsbSessObject.html">sbSessObj</a> *pSess, <a class="el" href="structsbFramObject.html">sbFramObj</a> *pFram)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lowest level event handler when a new frame arrived. </em> <a href="#a2"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="beeplisten_8c.html#a3">sbLstnBuildFrame</a> (<a class="el" href="structsbLstnObject.html">sbLstnObj</a> *pThis, <a class="el" href="structsbSessObject.html">sbSessObj</a> *pSess, char c, int *pbAbort)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method build a frame by processing one character at a time. </em> <a href="#a3"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="beeplisten_8c.html#a4">sbLstnDoIncomingData</a> (<a class="el" href="structsbLstnObject.html">sbLstnObj</a> *pThis, <a class="el" href="structsbSessObject.html">sbSessObj</a> *pSess)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive all incoming data that is available. </em> <a href="#a4"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a6" doxytag="beeplisten.c::sbSessAddActiveSession"></a>
<a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="beeplisten_8c.html#a6">sbSessAddActiveSession</a> (<a class="el" href="structsbLstnObject.html">sbLstnObj</a> *pThis, <a class="el" href="structsbSessObject.html">sbSessObj</a> *pSess)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a session to the list of active sessions. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="beeplisten_8c.html#a8">sbLstnSendFram</a> (<a class="el" href="structsbLstnObject.html">sbLstnObj</a> *pThis, <a class="el" href="structsbSessObject.html">sbSessObj</a> *pSess)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Actually send a frame over the socket. </em> <a href="#a8"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="beeplisten_8c.html#a9">sbLstnServerLoop</a> (<a class="el" href="structsbLstnObject.html">sbLstnObj</a> *pThis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the main server/IO handler. </em> <a href="#a9"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structsbLstnObject.html">sbLstnObj</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="beeplisten_8c.html#a10">sbLstnConstruct</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a sbLstnObj. </em> <a href="#a10"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a11" doxytag="beeplisten.c::sbLstnDestroy"></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="beeplisten_8c.html#a11">sbLstnDestroy</a> (<a class="el" href="structsbLstnObject.html">sbLstnObj</a> *pThis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor for the beep listener object. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="beeplisten_8c.html#a12">sbLstnInit</a> (<a class="el" href="structsbLstnObject.html">sbLstnObj</a> *pThis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a listener. </em> <a href="#a12"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="beeplisten_8c.html#a13">sbLstnRun</a> (<a class="el" href="structsbLstnObject.html">sbLstnObj</a> *pThis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">THE listener process. </em> <a href="#a13"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="beeplisten_8c.html#a14">sbLstnExit</a> (<a class="el" href="structsbLstnObject.html">sbLstnObj</a> *pThis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exit the listener. </em> <a href="#a14"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a16" doxytag="beeplisten.c::sbLstnAddProfile"></a>
<a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><b>sbLstnAddProfile</b> (<a class="el" href="structsbLstnObject.html">sbLstnObj</a> *pThis, <a class="el" href="structsbProfObject.html">sbProfObj</a> *pProf)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Implementation of the (BEEP) listener Object. 
<p>
Actually, this module implements all the listeners. The initial release did only care about BEEP, but starting with 0.6.0 additional listeners are supported. In 0.6.0 at least a standard UDP listener has been added. Other listeners (eventually not implemented by the time you read this) are the simple syslog over TCP (aka "SELP") and the local /var/log "listener" on *nix.<p>
Please see <a class="el" href="architecture_8c.html">architecture::c</a> for more details.<p>
<dl compact><dt><b>Author:</b></dt><dd>Rainer Gerhards &lt;<a href="mailto:rgerhards@adiscon.com">rgerhards@adiscon.com</a>&gt; </dd></dl>
<dl compact><dt><b>Date:</b></dt><dd>2003-08-13 File initially created. <p>
2003-09-26 Changed the logical meaning of this module. It is no longer the BEEP listener, only. It is now *the* listener for all supported protocols. This allows us to keep all listeners on a single thread.</dd></dl>
Copyright 2002-2003 Rainer Gerhards and Adiscon GmbH. All Rights Reserved.<p>
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:<p>
* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.<p>
* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.<p>
* Neither the name of Adiscon GmbH or Rainer Gerhards nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.<p>
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<hr><h2>Function Documentation</h2>
<a name="a3" doxytag="beeplisten.c::sbLstnBuildFrame"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="liblogging_8h.html#a6">srRetVal</a> sbLstnBuildFrame </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsbLstnObject.html">sbLstnObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pThis</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structsbSessObject.html">sbSessObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pSess</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char&nbsp;</td>
          <td class="mdname" nowrap> <em>c</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>pbAbort</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This method build a frame by processing one character at a time. 
<p>
It operates on a continuous stream of data. It is a state machine.<p>
As soon as a full frame is detected, the frame handler is called which then should pass the data to his upper layer - or whatever he intends to do with it. This is not the business of this method. For each new frame, new memory is allocated, so the frame handler (or its upper layers) are responsible for deleting the frame.<p>
This method calls itself recursively if it needed to peek at a character and now needs to do the actual processing.<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>improve!</dd></dl>
    </td>
  </tr>
</table>
<a name="a10" doxytag="beeplisten.c::sbLstnConstruct"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structsbLstnObject.html">sbLstnObj</a>* sbLstnConstruct </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Construct a sbLstnObj. 
<p>
This MUST be the first call a server makes. After the server has obtained the sbLstnObj, it can set the parameters and THEN call <a class="el" href="beeplisten_8c.html#a12">sbLstnInit()</a>.<p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pointer</em>&nbsp;</td><td>to constructed object or NULL, if error occurred. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a4" doxytag="beeplisten.c::sbLstnDoIncomingData"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="liblogging_8h.html#a6">srRetVal</a> sbLstnDoIncomingData </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsbLstnObject.html">sbLstnObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pThis</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structsbSessObject.html">sbSessObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pSess</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Receive all incoming data that is available. 
<p>
This method reads all available incoming data and processes it. It will call receive state machine to form new frames. That machine, in turn, will fire off Receive events as full frames are completely received. Please note that it is possible for a single run of this method to receive no, one or more full frames.<p>
&lt; actual number of bytes received<p>
&lt; set by lower layer methods if a fatal error occured. in this case, the session should be aborted and such the full buffer needs not to be processed.<p>
&lt; receive buffer - this could be any size, we have selected this size so that an ethernet frame fits. Feel free to tune.     </td>
  </tr>
</table>
<a name="a14" doxytag="beeplisten.c::sbLstnExit"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="liblogging_8h.html#a6">srRetVal</a> sbLstnExit </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsbLstnObject.html">sbLstnObj</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>pThis</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Exit the listener. 
<p>
Will do all cleanup necessary.     </td>
  </tr>
</table>
<a name="a12" doxytag="beeplisten.c::sbLstnInit"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="liblogging_8h.html#a6">srRetVal</a> sbLstnInit </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsbLstnObject.html">sbLstnObj</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>pThis</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize a listener. 
<p>
The listener socket is created, but it is not yet set to listen() to incoming calls.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pThis</em>&nbsp;</td><td>{out] Pointer to a pointer to the object. On return, it contains a pointer to a new BEEP listener object or NULL, if an error occured. Consult the return value to learn more in the later case. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a2" doxytag="beeplisten.c::sbLstnOnFramRcvd"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="liblogging_8h.html#a6">srRetVal</a> sbLstnOnFramRcvd </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsbLstnObject.html">sbLstnObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pThis</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>pbAbort</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structsbSessObject.html">sbSessObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pSess</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structsbFramObject.html">sbFramObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pFram</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Lowest level event handler when a new frame arrived. 
<p>
This handler must first verify if it is a good packet (checks like seqno sequence and thus) and if so, find the profile that it should send data to. SEQ frames are directly processed and channel 0 protocol is mapped to fixed handlers in this object itself.<p>
Please note: the message object created here is passed on to the upper layers. However, these upper layers MUST NOT destroy the Mesg Object - this will be done once this method finishes!<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pSess</em>&nbsp;</td><td>Pointer to the current session object. </td></tr>
    <tr><td valign=top><em>pFram</em>&nbsp;</td><td>Pointer to the just received frame. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a13" doxytag="beeplisten.c::sbLstnRun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="liblogging_8h.html#a6">srRetVal</a> sbLstnRun </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsbLstnObject.html">sbLstnObj</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>pThis</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
THE listener process. 
<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>think of a smart way to handle iRet down here... For now, we just make sure BEEP is closed last, as this has the highest potential for errors. </dd></dl>
    </td>
  </tr>
</table>
<a name="a8" doxytag="beeplisten.c::sbLstnSendFram"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="liblogging_8h.html#a6">srRetVal</a> sbLstnSendFram </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsbLstnObject.html">sbLstnObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pThis</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structsbSessObject.html">sbSessObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pSess</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Actually send a frame over the socket. 
<p>
If the method would block, we could only send a partial frame.<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>We need to upgrade either this method (or create another one so that it will send multiple frames if multiple frames are in the send queue. Right now, this is done by the select() loop anyhow, but it may be more efficient to do it that way (or it may be not, this needs some more thinking...). </dd></dl>
IMPORTANT: When sending SEQ frames, we do not use the "normal" window mechanism. Essentially, these SEQs are acknowledgements, so they are not to be considered as part of the data window. If we would count them, we would stall the process as the peer will abviously never acknowledge acknowledgements... ;)<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>We need to see if race conditions can occur where pChan becomes invalid but is still stored with the message. It may be a better idea to use the "normal" channel lookup methods, though they are definitely slower... For now, we use an assert and will test this well. <p>
again, referencing the channel object as done below is a little dangerous...</dd></dl>
    </td>
  </tr>
</table>
<a name="a9" doxytag="beeplisten.c::sbLstnServerLoop"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="liblogging_8h.html#a6">srRetVal</a> sbLstnServerLoop </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsbLstnObject.html">sbLstnObj</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>pThis</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This is the main server/IO handler. 
<p>
This loop is executed until termination is flagged. This is the ONLY method that is responsible for scheduling IO.<p>
The loop has three phases:<ul>
<li>check if data is to be sent and, if so, try to send it</li><li>wait for socket to become ready for read or write</li><li>process pending socket reads</li></ul>
<p>
We have some OS dependant code in here. The reason is that "original" BSD sockets need to have passed the highest numbered file descriptor. We can not properly emulate this in the socket layer. Even if we could, that would potentially cause a considerable performance hit. Thus, we implement it in this module and pass it on to the lower layer. If we run into a non BSD-sockets OS other than Windows, we might be not so happy with this decision, but lets try it...<p>
Please note that all send operations are only done in phase 1.<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>think a little about the performance implications of the below - we may think about either doubly linking the list or having the previous element at hand (e.g. in the linked list object...). <p>
log this once we have a logging subsystem <p>
think a little about the performance implications of the below - we may think about either doubly linking the list or having the previous element at hand (e.g. in the linked list object...). <p>
check &amp; act on return value!!!! (close session? most probably...)</dd></dl>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Mon Oct 3 12:29:55 2005 for liblogging by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.2 </small></address>
</body>
</html>
