diff --git a/drivers/media/dvb-frontends/m88ds3103.c b/drivers/media/dvb-frontends/m88ds3103.c
index 65d157f..4ce48ab 100644
--- a/drivers/media/dvb-frontends/m88ds3103.c
+++ b/drivers/media/dvb-frontends/m88ds3103.c
@@ -1232,9 +1232,9 @@ static void m88ds3103_release(struct dvb_frontend *fe)
 	i2c_unregister_device(client);
 }
 
-static int m88ds3103_select(struct i2c_mux_core *muxc, u32 chan)
+static int m88ds3103_select(struct i2c_adapter *adap, void *mux_priv, u32 chan)
 {
-	struct m88ds3103_dev *dev = i2c_mux_priv(muxc);
+	struct m88ds3103_dev *dev = mux_priv;
 	struct i2c_client *client = dev->client;
 	int ret;
 	struct i2c_msg msg = {
@@ -1356,7 +1356,7 @@ static struct i2c_adapter *m88ds3103_get_i2c_adapter(struct i2c_client *client)
 
 	dev_dbg(&client->dev, "\n");
 
-	return dev->muxc->adapter[0];
+	return dev->i2c_adapter;
 }
 
 static int m88ds3103_probe(struct i2c_client *client,
@@ -1456,16 +1456,13 @@ static int m88ds3103_probe(struct i2c_client *client,
 		goto err_kfree;
 
 	/* create mux i2c adapter for tuner */
-	dev->muxc = i2c_mux_alloc(client->adapter, &client->dev, 1, 0, 0,
-				  m88ds3103_select, NULL);
-	if (!dev->muxc) {
+	dev->i2c_adapter = i2c_add_mux_adapter(client->adapter, &client->dev,
+					       dev, 0, 0, 0, m88ds3103_select,
+					       NULL);
+	if (dev->i2c_adapter == NULL) {
 		ret = -ENOMEM;
 		goto err_kfree;
 	}
-	dev->muxc->priv = dev;
-	ret = i2c_mux_add_adapter(dev->muxc, 0, 0, 0);
-	if (ret)
-		goto err_kfree;
 
 	/* create dvb_frontend */
 	memcpy(&dev->fe.ops, &m88ds3103_ops, sizeof(struct dvb_frontend_ops));
@@ -1494,7 +1491,7 @@ static int m88ds3103_remove(struct i2c_client *client)
 
 	dev_dbg(&client->dev, "\n");
 
-	i2c_mux_del_adapters(dev->muxc);
+	i2c_del_mux_adapter(dev->i2c_adapter);
 
 	kfree(dev);
 	return 0;
diff --git a/drivers/media/dvb-frontends/m88ds3103_priv.h b/drivers/media/dvb-frontends/m88ds3103_priv.h
index 1ba0b79..6c7efd8 100644
--- a/drivers/media/dvb-frontends/m88ds3103_priv.h
+++ b/drivers/media/dvb-frontends/m88ds3103_priv.h
@@ -41,7 +41,7 @@ struct m88ds3103_dev {
 	enum fe_status fe_status;
 	u32 dvbv3_ber; /* for old DVBv3 API read_ber */
 	bool warm; /* FW running */
-	struct i2c_mux_core *muxc;
+	struct i2c_adapter *i2c_adapter;
 	/* auto detect chip id to do different config */
 	u8 chip_id;
 	/* main mclk is calculated for M88RS6000 dynamically */
diff --git a/drivers/media/dvb-frontends/rtl2830.c b/drivers/media/dvb-frontends/rtl2830.c
index 7bbfe11..56e9e5b 100644
--- a/drivers/media/dvb-frontends/rtl2830.c
+++ b/drivers/media/dvb-frontends/rtl2830.c
@@ -655,9 +655,9 @@ static int rtl2830_pid_filter(struct dvb_frontend *fe, u8 index, u16 pid, int on
  * adapter lock is already taken by tuner driver.
  * Gate is closed automatically after single I2C transfer.
  */
-static int rtl2830_select(struct i2c_mux_core *muxc, u32 chan_id)
+static int rtl2830_select(struct i2c_adapter *adap, void *mux_priv, u32 chan_id)
 {
-	struct i2c_client *client = i2c_mux_priv(muxc);
+	struct i2c_client *client = mux_priv;
 	struct rtl2830_dev *dev = i2c_get_clientdata(client);
 	int ret;
 
@@ -690,7 +690,7 @@ static struct i2c_adapter *rtl2830_get_i2c_adapter(struct i2c_client *client)
 
 	dev_dbg(&client->dev, "\n");
 
-	return dev->muxc->adapter[0];
+	return dev->adapter;
 }
 
 /*
@@ -842,16 +842,12 @@ static int rtl2830_probe(struct i2c_client *client,
 		goto err_regmap_exit;
 
 	/* create muxed i2c adapter for tuner */
-	dev->muxc = i2c_mux_alloc(client->adapter, &client->dev, 1, 0, 0,
-				  rtl2830_select, NULL);
-	if (!dev->muxc) {
-		ret = -ENOMEM;
+	dev->adapter = i2c_add_mux_adapter(client->adapter, &client->dev,
+			client, 0, 0, 0, rtl2830_select, NULL);
+	if (dev->adapter == NULL) {
+		ret = -ENODEV;
 		goto err_regmap_exit;
 	}
-	dev->muxc->priv = client;
-	ret = i2c_mux_add_adapter(dev->muxc, 0, 0, 0);
-	if (ret)
-		goto err_regmap_exit;
 
 	/* create dvb frontend */
 	memcpy(&dev->fe.ops, &rtl2830_ops, sizeof(dev->fe.ops));
@@ -881,7 +877,7 @@ static int rtl2830_remove(struct i2c_client *client)
 
 	dev_dbg(&client->dev, "\n");
 
-	i2c_mux_del_adapters(dev->muxc);
+	i2c_del_mux_adapter(dev->adapter);
 	regmap_exit(dev->regmap);
 	kfree(dev);
 
diff --git a/drivers/media/dvb-frontends/rtl2830_priv.h b/drivers/media/dvb-frontends/rtl2830_priv.h
index 72d3f35..dc438c4 100644
--- a/drivers/media/dvb-frontends/rtl2830_priv.h
+++ b/drivers/media/dvb-frontends/rtl2830_priv.h
@@ -30,7 +30,7 @@ struct rtl2830_dev {
 	struct rtl2830_platform_data *pdata;
 	struct i2c_client *client;
 	struct regmap *regmap;
-	struct i2c_mux_core *muxc;
+	struct i2c_adapter *adapter;
 	struct dvb_frontend fe;
 	bool sleeping;
 	unsigned long filters;
diff --git a/drivers/media/dvb-frontends/rtl2832.c b/drivers/media/dvb-frontends/rtl2832.c
index fa3b816..1c11d50 100644
--- a/drivers/media/dvb-frontends/rtl2832.c
+++ b/drivers/media/dvb-frontends/rtl2832.c
@@ -153,6 +153,43 @@ static const struct rtl2832_reg_entry registers[] = {
 	[DVBT_REG_4MSEL]	= {0x013,  0, 0},
 };
 
+/* Our regmap is bypassing I2C adapter lock, thus we do it! */
+static int rtl2832_bulk_write(struct i2c_client *client, unsigned int reg,
+			      const void *val, size_t val_count)
+{
+	struct rtl2832_dev *dev = i2c_get_clientdata(client);
+	int ret;
+
+	i2c_lock_adapter(client->adapter);
+	ret = regmap_bulk_write(dev->regmap, reg, val, val_count);
+	i2c_unlock_adapter(client->adapter);
+	return ret;
+}
+
+static int rtl2832_update_bits(struct i2c_client *client, unsigned int reg,
+			       unsigned int mask, unsigned int val)
+{
+	struct rtl2832_dev *dev = i2c_get_clientdata(client);
+	int ret;
+
+	i2c_lock_adapter(client->adapter);
+	ret = regmap_update_bits(dev->regmap, reg, mask, val);
+	i2c_unlock_adapter(client->adapter);
+	return ret;
+}
+
+static int rtl2832_bulk_read(struct i2c_client *client, unsigned int reg,
+			     void *val, size_t val_count)
+{
+	struct rtl2832_dev *dev = i2c_get_clientdata(client);
+	int ret;
+
+	i2c_lock_adapter(client->adapter);
+	ret = regmap_bulk_read(dev->regmap, reg, val, val_count);
+	i2c_unlock_adapter(client->adapter);
+	return ret;
+}
+
 static int rtl2832_rd_demod_reg(struct rtl2832_dev *dev, int reg, u32 *val)
 {
 	struct i2c_client *client = dev->client;
@@ -167,7 +204,7 @@ static int rtl2832_rd_demod_reg(struct rtl2832_dev *dev, int reg, u32 *val)
 	len = (msb >> 3) + 1;
 	mask = REG_MASK(msb - lsb);
 
-	ret = regmap_bulk_read(dev->regmap, reg_start_addr, reading, len);
+	ret = rtl2832_bulk_read(client, reg_start_addr, reading, len);
 	if (ret)
 		goto err;
 
@@ -197,7 +234,7 @@ static int rtl2832_wr_demod_reg(struct rtl2832_dev *dev, int reg, u32 val)
 	len = (msb >> 3) + 1;
 	mask = REG_MASK(msb - lsb);
 
-	ret = regmap_bulk_read(dev->regmap, reg_start_addr, reading, len);
+	ret = rtl2832_bulk_read(client, reg_start_addr, reading, len);
 	if (ret)
 		goto err;
 
@@ -211,7 +248,7 @@ static int rtl2832_wr_demod_reg(struct rtl2832_dev *dev, int reg, u32 val)
 	for (i = 0; i < len; i++)
 		writing[i] = (writing_tmp >> ((len - 1 - i) * 8)) & 0xff;
 
-	ret = regmap_bulk_write(dev->regmap, reg_start_addr, writing, len);
+	ret = rtl2832_bulk_write(client, reg_start_addr, writing, len);
 	if (ret)
 		goto err;
 
@@ -488,8 +525,7 @@ static int rtl2832_set_frontend(struct dvb_frontend *fe)
 	}
 
 	for (j = 0; j < sizeof(bw_params[0]); j++) {
-		ret = regmap_bulk_write(dev->regmap,
-					0x11c + j, &bw_params[i][j], 1);
+		ret = rtl2832_bulk_write(client, 0x11c + j, &bw_params[i][j], 1);
 		if (ret)
 			goto err;
 	}
@@ -545,11 +581,11 @@ static int rtl2832_get_frontend(struct dvb_frontend *fe,
 	if (dev->sleeping)
 		return 0;
 
-	ret = regmap_bulk_read(dev->regmap, 0x33c, buf, 2);
+	ret = rtl2832_bulk_read(client, 0x33c, buf, 2);
 	if (ret)
 		goto err;
 
-	ret = regmap_bulk_read(dev->regmap, 0x351, &buf[2], 1);
+	ret = rtl2832_bulk_read(client, 0x351, &buf[2], 1);
 	if (ret)
 		goto err;
 
@@ -680,7 +716,7 @@ static int rtl2832_read_status(struct dvb_frontend *fe, enum fe_status *status)
 	/* signal strength */
 	if (dev->fe_status & FE_HAS_SIGNAL) {
 		/* read digital AGC */
-		ret = regmap_bulk_read(dev->regmap, 0x305, &u8tmp, 1);
+		ret = rtl2832_bulk_read(client, 0x305, &u8tmp, 1);
 		if (ret)
 			goto err;
 
@@ -706,7 +742,7 @@ static int rtl2832_read_status(struct dvb_frontend *fe, enum fe_status *status)
 			{87659938, 87659938, 87885178, 88241743},
 		};
 
-		ret = regmap_bulk_read(dev->regmap, 0x33c, &u8tmp, 1);
+		ret = rtl2832_bulk_read(client, 0x33c, &u8tmp, 1);
 		if (ret)
 			goto err;
 
@@ -718,7 +754,7 @@ static int rtl2832_read_status(struct dvb_frontend *fe, enum fe_status *status)
 		if (hierarchy > HIERARCHY_NUM - 1)
 			goto err;
 
-		ret = regmap_bulk_read(dev->regmap, 0x40c, buf, 2);
+		ret = rtl2832_bulk_read(client, 0x40c, buf, 2);
 		if (ret)
 			goto err;
 
@@ -739,7 +775,7 @@ static int rtl2832_read_status(struct dvb_frontend *fe, enum fe_status *status)
 
 	/* BER */
 	if (dev->fe_status & FE_HAS_LOCK) {
-		ret = regmap_bulk_read(dev->regmap, 0x34e, buf, 2);
+		ret = rtl2832_bulk_read(client, 0x34e, buf, 2);
 		if (ret)
 			goto err;
 
@@ -789,6 +825,8 @@ static int rtl2832_read_ber(struct dvb_frontend *fe, u32 *ber)
 
 /*
  * I2C gate/mux/repeater logic
+ * We must use unlocked __i2c_transfer() here (through regmap) because of I2C
+ * adapter lock is already taken by tuner driver.
  * There is delay mechanism to avoid unneeded I2C gate open / close. Gate close
  * is delayed here a little bit in order to see if there is sequence of I2C
  * messages sent to same I2C bus.
@@ -800,7 +838,7 @@ static void rtl2832_i2c_gate_work(struct work_struct *work)
 	int ret;
 
 	/* close gate */
-	ret = regmap_update_bits(dev->regmap, 0x101, 0x08, 0x00);
+	ret = rtl2832_update_bits(dev->client, 0x101, 0x08, 0x00);
 	if (ret)
 		goto err;
 
@@ -809,16 +847,19 @@ static void rtl2832_i2c_gate_work(struct work_struct *work)
 	dev_dbg(&client->dev, "failed=%d\n", ret);
 }
 
-static int rtl2832_select(struct i2c_mux_core *muxc, u32 chan_id)
+static int rtl2832_select(struct i2c_adapter *adap, void *mux_priv, u32 chan_id)
 {
-	struct rtl2832_dev *dev = i2c_mux_priv(muxc);
+	struct rtl2832_dev *dev = mux_priv;
 	struct i2c_client *client = dev->client;
 	int ret;
 
 	/* terminate possible gate closing */
 	cancel_delayed_work(&dev->i2c_gate_work);
 
-	/* open gate */
+	/*
+	 * I2C adapter lock is already taken and due to that we will use
+	 * regmap_update_bits() which does not lock again I2C adapter.
+	 */
 	ret = regmap_update_bits(dev->regmap, 0x101, 0x08, 0x08);
 	if (ret)
 		goto err;
@@ -829,9 +870,10 @@ static int rtl2832_select(struct i2c_mux_core *muxc, u32 chan_id)
 	return ret;
 }
 
-static int rtl2832_deselect(struct i2c_mux_core *muxc, u32 chan_id)
+static int rtl2832_deselect(struct i2c_adapter *adap, void *mux_priv,
+			    u32 chan_id)
 {
-	struct rtl2832_dev *dev = i2c_mux_priv(muxc);
+	struct rtl2832_dev *dev = mux_priv;
 
 	schedule_delayed_work(&dev->i2c_gate_work, usecs_to_jiffies(100));
 	return 0;
@@ -890,6 +932,120 @@ static bool rtl2832_volatile_reg(struct device *dev, unsigned int reg)
 	return false;
 }
 
+/*
+ * We implement own I2C access routines for regmap in order to get manual access
+ * to I2C adapter lock, which is needed for I2C mux adapter.
+ */
+static int rtl2832_regmap_read(void *context, const void *reg_buf,
+			       size_t reg_size, void *val_buf, size_t val_size)
+{
+	struct i2c_client *client = context;
+	int ret;
+	struct i2c_msg msg[2] = {
+		{
+			.addr = client->addr,
+			.flags = 0,
+			.len = reg_size,
+			.buf = (u8 *)reg_buf,
+		}, {
+			.addr = client->addr,
+			.flags = I2C_M_RD,
+			.len = val_size,
+			.buf = val_buf,
+		}
+	};
+
+	ret = __i2c_transfer(client->adapter, msg, 2);
+	if (ret != 2) {
+		dev_warn(&client->dev, "i2c reg read failed %d reg %02x\n",
+			 ret, *(u8 *)reg_buf);
+		if (ret >= 0)
+			ret = -EREMOTEIO;
+		return ret;
+	}
+	return 0;
+}
+
+static int rtl2832_regmap_write(void *context, const void *data, size_t count)
+{
+	struct i2c_client *client = context;
+	int ret;
+	struct i2c_msg msg[1] = {
+		{
+			.addr = client->addr,
+			.flags = 0,
+			.len = count,
+			.buf = (u8 *)data,
+		}
+	};
+
+	ret = __i2c_transfer(client->adapter, msg, 1);
+	if (ret != 1) {
+		dev_warn(&client->dev, "i2c reg write failed %d reg %02x\n",
+			 ret, *(u8 *)data);
+		if (ret >= 0)
+			ret = -EREMOTEIO;
+		return ret;
+	}
+	return 0;
+}
+
+static int rtl2832_regmap_gather_write(void *context, const void *reg,
+				       size_t reg_len, const void *val,
+				       size_t val_len)
+{
+	struct i2c_client *client = context;
+	int ret;
+	u8 buf[256];
+	struct i2c_msg msg[1] = {
+		{
+			.addr = client->addr,
+			.flags = 0,
+			.len = 1 + val_len,
+			.buf = buf,
+		}
+	};
+
+	buf[0] = *(u8 const *)reg;
+	memcpy(&buf[1], val, val_len);
+
+	ret = __i2c_transfer(client->adapter, msg, 1);
+	if (ret != 1) {
+		dev_warn(&client->dev, "i2c reg write failed %d reg %02x\n",
+			 ret, *(u8 const *)reg);
+		if (ret >= 0)
+			ret = -EREMOTEIO;
+		return ret;
+	}
+	return 0;
+}
+
+/*
+ * FIXME: Hack. Implement own regmap locking in order to silence lockdep
+ * recursive lock warning. That happens when regmap I2C client calls I2C mux
+ * adapter, which leads demod I2C repeater enable via demod regmap. Operation
+ * takes two regmap locks recursively - but those are different regmap instances
+ * in a two different I2C drivers, so it is not deadlock. Proper fix is to make
+ * regmap aware of lockdep.
+ */
+static void rtl2832_regmap_lock(void *__dev)
+{
+	struct rtl2832_dev *dev = __dev;
+	struct i2c_client *client = dev->client;
+
+	dev_dbg(&client->dev, "\n");
+	mutex_lock(&dev->regmap_mutex);
+}
+
+static void rtl2832_regmap_unlock(void *__dev)
+{
+	struct rtl2832_dev *dev = __dev;
+	struct i2c_client *client = dev->client;
+
+	dev_dbg(&client->dev, "\n");
+	mutex_unlock(&dev->regmap_mutex);
+}
+
 static struct dvb_frontend *rtl2832_get_dvb_frontend(struct i2c_client *client)
 {
 	struct rtl2832_dev *dev = i2c_get_clientdata(client);
@@ -903,7 +1059,7 @@ static struct i2c_adapter *rtl2832_get_i2c_adapter(struct i2c_client *client)
 	struct rtl2832_dev *dev = i2c_get_clientdata(client);
 
 	dev_dbg(&client->dev, "\n");
-	return dev->muxc->adapter[0];
+	return dev->i2c_adapter_tuner;
 }
 
 static int rtl2832_slave_ts_ctrl(struct i2c_client *client, bool enable)
@@ -917,29 +1073,29 @@ static int rtl2832_slave_ts_ctrl(struct i2c_client *client, bool enable)
 		ret = rtl2832_wr_demod_reg(dev, DVBT_SOFT_RST, 0x0);
 		if (ret)
 			goto err;
-		ret = regmap_bulk_write(dev->regmap, 0x10c, "\x5f\xff", 2);
+		ret = rtl2832_bulk_write(client, 0x10c, "\x5f\xff", 2);
 		if (ret)
 			goto err;
 		ret = rtl2832_wr_demod_reg(dev, DVBT_PIP_ON, 0x1);
 		if (ret)
 			goto err;
-		ret = regmap_bulk_write(dev->regmap, 0x0bc, "\x18", 1);
+		ret = rtl2832_bulk_write(client, 0x0bc, "\x18", 1);
 		if (ret)
 			goto err;
-		ret = regmap_bulk_write(dev->regmap, 0x192, "\x7f\xf7\xff", 3);
+		ret = rtl2832_bulk_write(client, 0x192, "\x7f\xf7\xff", 3);
 		if (ret)
 			goto err;
 	} else {
-		ret = regmap_bulk_write(dev->regmap, 0x192, "\x00\x0f\xff", 3);
+		ret = rtl2832_bulk_write(client, 0x192, "\x00\x0f\xff", 3);
 		if (ret)
 			goto err;
-		ret = regmap_bulk_write(dev->regmap, 0x0bc, "\x08", 1);
+		ret = rtl2832_bulk_write(client, 0x0bc, "\x08", 1);
 		if (ret)
 			goto err;
 		ret = rtl2832_wr_demod_reg(dev, DVBT_PIP_ON, 0x0);
 		if (ret)
 			goto err;
-		ret = regmap_bulk_write(dev->regmap, 0x10c, "\x00\x00", 2);
+		ret = rtl2832_bulk_write(client, 0x10c, "\x00\x00", 2);
 		if (ret)
 			goto err;
 		ret = rtl2832_wr_demod_reg(dev, DVBT_SOFT_RST, 0x1);
@@ -971,9 +1127,9 @@ static int rtl2832_pid_filter_ctrl(struct dvb_frontend *fe, int onoff)
 		u8tmp = 0x00;
 
 	if (dev->slave_ts)
-		ret = regmap_update_bits(dev->regmap, 0x021, 0xc0, u8tmp);
+		ret = rtl2832_update_bits(client, 0x021, 0xc0, u8tmp);
 	else
-		ret = regmap_update_bits(dev->regmap, 0x061, 0xc0, u8tmp);
+		ret = rtl2832_update_bits(client, 0x061, 0xc0, u8tmp);
 	if (ret)
 		goto err;
 
@@ -1010,9 +1166,9 @@ static int rtl2832_pid_filter(struct dvb_frontend *fe, u8 index, u16 pid,
 	buf[3] = (dev->filters >> 24) & 0xff;
 
 	if (dev->slave_ts)
-		ret = regmap_bulk_write(dev->regmap, 0x022, buf, 4);
+		ret = rtl2832_bulk_write(client, 0x022, buf, 4);
 	else
-		ret = regmap_bulk_write(dev->regmap, 0x062, buf, 4);
+		ret = rtl2832_bulk_write(client, 0x062, buf, 4);
 	if (ret)
 		goto err;
 
@@ -1021,9 +1177,9 @@ static int rtl2832_pid_filter(struct dvb_frontend *fe, u8 index, u16 pid,
 	buf[1] = (pid >> 0) & 0xff;
 
 	if (dev->slave_ts)
-		ret = regmap_bulk_write(dev->regmap, 0x026 + 2 * index, buf, 2);
+		ret = rtl2832_bulk_write(client, 0x026 + 2 * index, buf, 2);
 	else
-		ret = regmap_bulk_write(dev->regmap, 0x066 + 2 * index, buf, 2);
+		ret = rtl2832_bulk_write(client, 0x066 + 2 * index, buf, 2);
 	if (ret)
 		goto err;
 
@@ -1041,6 +1197,12 @@ static int rtl2832_probe(struct i2c_client *client,
 	struct rtl2832_dev *dev;
 	int ret;
 	u8 tmp;
+	static const struct regmap_bus regmap_bus = {
+		.read = rtl2832_regmap_read,
+		.write = rtl2832_regmap_write,
+		.gather_write = rtl2832_regmap_gather_write,
+		.val_format_endian_default = REGMAP_ENDIAN_NATIVE,
+	};
 	static const struct regmap_range_cfg regmap_range_cfg[] = {
 		{
 			.selector_reg     = 0x00,
@@ -1069,35 +1231,36 @@ static int rtl2832_probe(struct i2c_client *client,
 	dev->sleeping = true;
 	INIT_DELAYED_WORK(&dev->i2c_gate_work, rtl2832_i2c_gate_work);
 	/* create regmap */
+	mutex_init(&dev->regmap_mutex);
 	dev->regmap_config.reg_bits =  8,
 	dev->regmap_config.val_bits =  8,
+	dev->regmap_config.lock = rtl2832_regmap_lock,
+	dev->regmap_config.unlock = rtl2832_regmap_unlock,
+	dev->regmap_config.lock_arg = dev,
 	dev->regmap_config.volatile_reg = rtl2832_volatile_reg,
 	dev->regmap_config.max_register = 5 * 0x100,
 	dev->regmap_config.ranges = regmap_range_cfg,
 	dev->regmap_config.num_ranges = ARRAY_SIZE(regmap_range_cfg),
 	dev->regmap_config.cache_type = REGCACHE_NONE,
-	dev->regmap = regmap_init_i2c(client, &dev->regmap_config);
+	dev->regmap = regmap_init(&client->dev, &regmap_bus, client,
+				  &dev->regmap_config);
 	if (IS_ERR(dev->regmap)) {
 		ret = PTR_ERR(dev->regmap);
 		goto err_kfree;
 	}
 
 	/* check if the demod is there */
-	ret = regmap_bulk_read(dev->regmap, 0x000, &tmp, 1);
+	ret = rtl2832_bulk_read(client, 0x000, &tmp, 1);
 	if (ret)
 		goto err_regmap_exit;
 
 	/* create muxed i2c adapter for demod tuner bus */
-	dev->muxc = i2c_mux_alloc(i2c, &i2c->dev, 1, 0, I2C_MUX_LOCKED,
-				  rtl2832_select, rtl2832_deselect);
-	if (!dev->muxc) {
-		ret = -ENOMEM;
+	dev->i2c_adapter_tuner = i2c_add_mux_adapter(i2c, &i2c->dev, dev,
+			0, 0, 0, rtl2832_select, rtl2832_deselect);
+	if (dev->i2c_adapter_tuner == NULL) {
+		ret = -ENODEV;
 		goto err_regmap_exit;
 	}
-	dev->muxc->priv = dev;
-	ret = i2c_mux_add_adapter(dev->muxc, 0, 0, 0);
-	if (ret)
-		goto err_regmap_exit;
 
 	/* create dvb_frontend */
 	memcpy(&dev->fe.ops, &rtl2832_ops, sizeof(struct dvb_frontend_ops));
@@ -1109,7 +1272,9 @@ static int rtl2832_probe(struct i2c_client *client,
 	pdata->slave_ts_ctrl = rtl2832_slave_ts_ctrl;
 	pdata->pid_filter = rtl2832_pid_filter;
 	pdata->pid_filter_ctrl = rtl2832_pid_filter_ctrl;
-	pdata->regmap = dev->regmap;
+	pdata->bulk_read = rtl2832_bulk_read;
+	pdata->bulk_write = rtl2832_bulk_write;
+	pdata->update_bits = rtl2832_update_bits;
 
 	dev_info(&client->dev, "Realtek RTL2832 successfully attached\n");
 	return 0;
@@ -1130,7 +1295,7 @@ static int rtl2832_remove(struct i2c_client *client)
 
 	cancel_delayed_work_sync(&dev->i2c_gate_work);
 
-	i2c_mux_del_adapters(dev->muxc);
+	i2c_del_mux_adapter(dev->i2c_adapter_tuner);
 
 	regmap_exit(dev->regmap);
 
diff --git a/drivers/media/dvb-frontends/rtl2832.h b/drivers/media/dvb-frontends/rtl2832.h
index 6a124ff..cb56cb2 100644
--- a/drivers/media/dvb-frontends/rtl2832.h
+++ b/drivers/media/dvb-frontends/rtl2832.h
@@ -56,7 +56,9 @@ struct rtl2832_platform_data {
 	int (*pid_filter)(struct dvb_frontend *, u8, u16, int);
 	int (*pid_filter_ctrl)(struct dvb_frontend *, int);
 /* private: Register access for SDR module use only */
-	struct regmap *regmap;
+	int (*bulk_read)(struct i2c_client *, unsigned int, void *, size_t);
+	int (*bulk_write)(struct i2c_client *, unsigned int, const void *, size_t);
+	int (*update_bits)(struct i2c_client *, unsigned int, unsigned int, unsigned int);
 };
 
 #endif /* RTL2832_H */
diff --git a/drivers/media/dvb-frontends/rtl2832_priv.h b/drivers/media/dvb-frontends/rtl2832_priv.h
index bd13d9a..6f3b69e 100644
--- a/drivers/media/dvb-frontends/rtl2832_priv.h
+++ b/drivers/media/dvb-frontends/rtl2832_priv.h
@@ -33,9 +33,10 @@
 struct rtl2832_dev {
 	struct rtl2832_platform_data *pdata;
 	struct i2c_client *client;
+	struct mutex regmap_mutex;
 	struct regmap_config regmap_config;
 	struct regmap *regmap;
-	struct i2c_mux_core *muxc;
+	struct i2c_adapter *i2c_adapter_tuner;
 	struct dvb_frontend fe;
 	enum fe_status fe_status;
 	u64 post_bit_error_prev; /* for old DVBv3 read_ber() calculation */
diff --git a/drivers/media/dvb-frontends/rtl2832_sdr.c b/drivers/media/dvb-frontends/rtl2832_sdr.c
index c6e78d8..6d2863f 100644
--- a/drivers/media/dvb-frontends/rtl2832_sdr.c
+++ b/drivers/media/dvb-frontends/rtl2832_sdr.c
@@ -35,7 +35,6 @@
 #include <linux/platform_device.h>
 #include <linux/jiffies.h>
 #include <linux/math64.h>
-#include <linux/regmap.h>
 
 static bool rtl2832_sdr_emulated_fmt;
 module_param_named(emulated_formats, rtl2832_sdr_emulated_fmt, bool, 0644);
@@ -120,7 +119,6 @@ struct rtl2832_sdr_dev {
 	unsigned long flags;
 
 	struct platform_device *pdev;
-	struct regmap *regmap;
 
 	struct video_device vdev;
 	struct v4l2_device v4l2_dev;
@@ -165,6 +163,47 @@ struct rtl2832_sdr_dev {
 	unsigned long jiffies_next;
 };
 
+/* write multiple registers */
+static int rtl2832_sdr_wr_regs(struct rtl2832_sdr_dev *dev, u16 reg,
+		const u8 *val, int len)
+{
+	struct platform_device *pdev = dev->pdev;
+	struct rtl2832_sdr_platform_data *pdata = pdev->dev.platform_data;
+	struct i2c_client *client = pdata->i2c_client;
+
+	return pdata->bulk_write(client, reg, val, len);
+}
+
+#if 0
+/* read multiple registers */
+static int rtl2832_sdr_rd_regs(struct rtl2832_sdr_dev *dev, u16 reg, u8 *val,
+		int len)
+{
+	struct platform_device *pdev = dev->pdev;
+	struct rtl2832_sdr_platform_data *pdata = pdev->dev.platform_data;
+	struct i2c_client *client = pdata->i2c_client;
+
+	return pdata->bulk_read(client, reg, val, len);
+}
+#endif
+
+/* write single register */
+static int rtl2832_sdr_wr_reg(struct rtl2832_sdr_dev *dev, u16 reg, u8 val)
+{
+	return rtl2832_sdr_wr_regs(dev, reg, &val, 1);
+}
+
+/* write single register with mask */
+static int rtl2832_sdr_wr_reg_mask(struct rtl2832_sdr_dev *dev, u16 reg,
+		u8 val, u8 mask)
+{
+	struct platform_device *pdev = dev->pdev;
+	struct rtl2832_sdr_platform_data *pdata = pdev->dev.platform_data;
+	struct i2c_client *client = pdata->i2c_client;
+
+	return pdata->update_bits(client, reg, mask, val);
+}
+
 /* Private functions */
 static struct rtl2832_sdr_frame_buf *rtl2832_sdr_get_next_fill_buf(
 		struct rtl2832_sdr_dev *dev)
@@ -518,11 +557,11 @@ static int rtl2832_sdr_set_adc(struct rtl2832_sdr_dev *dev)
 
 	f_sr = dev->f_adc;
 
-	ret = regmap_bulk_write(dev->regmap, 0x13e, "\x00\x00", 2);
+	ret = rtl2832_sdr_wr_regs(dev, 0x13e, "\x00\x00", 2);
 	if (ret)
 		goto err;
 
-	ret = regmap_bulk_write(dev->regmap, 0x115, "\x00\x00\x00\x00", 4);
+	ret = rtl2832_sdr_wr_regs(dev, 0x115, "\x00\x00\x00\x00", 4);
 	if (ret)
 		goto err;
 
@@ -548,7 +587,7 @@ static int rtl2832_sdr_set_adc(struct rtl2832_sdr_dev *dev)
 	buf[1] = (u32tmp >>  8) & 0xff;
 	buf[2] = (u32tmp >>  0) & 0xff;
 
-	ret = regmap_bulk_write(dev->regmap, 0x119, buf, 3);
+	ret = rtl2832_sdr_wr_regs(dev, 0x119, buf, 3);
 	if (ret)
 		goto err;
 
@@ -562,15 +601,15 @@ static int rtl2832_sdr_set_adc(struct rtl2832_sdr_dev *dev)
 		u8tmp2 = 0xcd; /* enable ADC I, ADC Q */
 	}
 
-	ret = regmap_write(dev->regmap, 0x1b1, u8tmp1);
+	ret = rtl2832_sdr_wr_reg(dev, 0x1b1, u8tmp1);
 	if (ret)
 		goto err;
 
-	ret = regmap_write(dev->regmap, 0x008, u8tmp2);
+	ret = rtl2832_sdr_wr_reg(dev, 0x008, u8tmp2);
 	if (ret)
 		goto err;
 
-	ret = regmap_write(dev->regmap, 0x006, 0x80);
+	ret = rtl2832_sdr_wr_reg(dev, 0x006, 0x80);
 	if (ret)
 		goto err;
 
@@ -581,169 +620,168 @@ static int rtl2832_sdr_set_adc(struct rtl2832_sdr_dev *dev)
 	buf[1] = (u32tmp >> 16) & 0xff;
 	buf[2] = (u32tmp >>  8) & 0xff;
 	buf[3] = (u32tmp >>  0) & 0xff;
-	ret = regmap_bulk_write(dev->regmap, 0x19f, buf, 4);
+	ret = rtl2832_sdr_wr_regs(dev, 0x19f, buf, 4);
 	if (ret)
 		goto err;
 
 	/* low-pass filter */
-	ret = regmap_bulk_write(dev->regmap, 0x11c,
-				"\xca\xdc\xd7\xd8\xe0\xf2\x0e\x35\x06\x50\x9c\x0d\x71\x11\x14\x71\x74\x19\x41\xa5",
-				20);
+	ret = rtl2832_sdr_wr_regs(dev, 0x11c,
+			"\xca\xdc\xd7\xd8\xe0\xf2\x0e\x35\x06\x50\x9c\x0d\x71\x11\x14\x71\x74\x19\x41\xa5",
+			20);
 	if (ret)
 		goto err;
 
-	ret = regmap_bulk_write(dev->regmap, 0x017, "\x11\x10", 2);
+	ret = rtl2832_sdr_wr_regs(dev, 0x017, "\x11\x10", 2);
 	if (ret)
 		goto err;
 
 	/* mode */
-	ret = regmap_write(dev->regmap, 0x019, 0x05);
+	ret = rtl2832_sdr_wr_regs(dev, 0x019, "\x05", 1);
 	if (ret)
 		goto err;
 
-	ret = regmap_bulk_write(dev->regmap, 0x01a,
-				"\x1b\x16\x0d\x06\x01\xff", 6);
+	ret = rtl2832_sdr_wr_regs(dev, 0x01a, "\x1b\x16\x0d\x06\x01\xff", 6);
 	if (ret)
 		goto err;
 
 	/* FSM */
-	ret = regmap_bulk_write(dev->regmap, 0x192, "\x00\xf0\x0f", 3);
+	ret = rtl2832_sdr_wr_regs(dev, 0x192, "\x00\xf0\x0f", 3);
 	if (ret)
 		goto err;
 
 	/* PID filter */
-	ret = regmap_write(dev->regmap, 0x061, 0x60);
+	ret = rtl2832_sdr_wr_regs(dev, 0x061, "\x60", 1);
 	if (ret)
 		goto err;
 
 	/* used RF tuner based settings */
 	switch (pdata->tuner) {
 	case RTL2832_SDR_TUNER_E4000:
-		ret = regmap_write(dev->regmap, 0x112, 0x5a);
-		ret = regmap_write(dev->regmap, 0x102, 0x40);
-		ret = regmap_write(dev->regmap, 0x103, 0x5a);
-		ret = regmap_write(dev->regmap, 0x1c7, 0x30);
-		ret = regmap_write(dev->regmap, 0x104, 0xd0);
-		ret = regmap_write(dev->regmap, 0x105, 0xbe);
-		ret = regmap_write(dev->regmap, 0x1c8, 0x18);
-		ret = regmap_write(dev->regmap, 0x106, 0x35);
-		ret = regmap_write(dev->regmap, 0x1c9, 0x21);
-		ret = regmap_write(dev->regmap, 0x1ca, 0x21);
-		ret = regmap_write(dev->regmap, 0x1cb, 0x00);
-		ret = regmap_write(dev->regmap, 0x107, 0x40);
-		ret = regmap_write(dev->regmap, 0x1cd, 0x10);
-		ret = regmap_write(dev->regmap, 0x1ce, 0x10);
-		ret = regmap_write(dev->regmap, 0x108, 0x80);
-		ret = regmap_write(dev->regmap, 0x109, 0x7f);
-		ret = regmap_write(dev->regmap, 0x10a, 0x80);
-		ret = regmap_write(dev->regmap, 0x10b, 0x7f);
-		ret = regmap_write(dev->regmap, 0x00e, 0xfc);
-		ret = regmap_write(dev->regmap, 0x00e, 0xfc);
-		ret = regmap_write(dev->regmap, 0x011, 0xd4);
-		ret = regmap_write(dev->regmap, 0x1e5, 0xf0);
-		ret = regmap_write(dev->regmap, 0x1d9, 0x00);
-		ret = regmap_write(dev->regmap, 0x1db, 0x00);
-		ret = regmap_write(dev->regmap, 0x1dd, 0x14);
-		ret = regmap_write(dev->regmap, 0x1de, 0xec);
-		ret = regmap_write(dev->regmap, 0x1d8, 0x0c);
-		ret = regmap_write(dev->regmap, 0x1e6, 0x02);
-		ret = regmap_write(dev->regmap, 0x1d7, 0x09);
-		ret = regmap_write(dev->regmap, 0x00d, 0x83);
-		ret = regmap_write(dev->regmap, 0x010, 0x49);
-		ret = regmap_write(dev->regmap, 0x00d, 0x87);
-		ret = regmap_write(dev->regmap, 0x00d, 0x85);
-		ret = regmap_write(dev->regmap, 0x013, 0x02);
+		ret = rtl2832_sdr_wr_regs(dev, 0x112, "\x5a", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x102, "\x40", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x103, "\x5a", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x1c7, "\x30", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x104, "\xd0", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x105, "\xbe", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x1c8, "\x18", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x106, "\x35", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x1c9, "\x21", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x1ca, "\x21", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x1cb, "\x00", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x107, "\x40", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x1cd, "\x10", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x1ce, "\x10", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x108, "\x80", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x109, "\x7f", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x10a, "\x80", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x10b, "\x7f", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x00e, "\xfc", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x00e, "\xfc", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x011, "\xd4", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x1e5, "\xf0", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x1d9, "\x00", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x1db, "\x00", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x1dd, "\x14", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x1de, "\xec", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x1d8, "\x0c", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x1e6, "\x02", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x1d7, "\x09", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x00d, "\x83", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x010, "\x49", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x00d, "\x87", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x00d, "\x85", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x013, "\x02", 1);
 		break;
 	case RTL2832_SDR_TUNER_FC0012:
 	case RTL2832_SDR_TUNER_FC0013:
-		ret = regmap_write(dev->regmap, 0x112, 0x5a);
-		ret = regmap_write(dev->regmap, 0x102, 0x40);
-		ret = regmap_write(dev->regmap, 0x103, 0x5a);
-		ret = regmap_write(dev->regmap, 0x1c7, 0x2c);
-		ret = regmap_write(dev->regmap, 0x104, 0xcc);
-		ret = regmap_write(dev->regmap, 0x105, 0xbe);
-		ret = regmap_write(dev->regmap, 0x1c8, 0x16);
-		ret = regmap_write(dev->regmap, 0x106, 0x35);
-		ret = regmap_write(dev->regmap, 0x1c9, 0x21);
-		ret = regmap_write(dev->regmap, 0x1ca, 0x21);
-		ret = regmap_write(dev->regmap, 0x1cb, 0x00);
-		ret = regmap_write(dev->regmap, 0x107, 0x40);
-		ret = regmap_write(dev->regmap, 0x1cd, 0x10);
-		ret = regmap_write(dev->regmap, 0x1ce, 0x10);
-		ret = regmap_write(dev->regmap, 0x108, 0x80);
-		ret = regmap_write(dev->regmap, 0x109, 0x7f);
-		ret = regmap_write(dev->regmap, 0x10a, 0x80);
-		ret = regmap_write(dev->regmap, 0x10b, 0x7f);
-		ret = regmap_write(dev->regmap, 0x00e, 0xfc);
-		ret = regmap_write(dev->regmap, 0x00e, 0xfc);
-		ret = regmap_bulk_write(dev->regmap, 0x011, "\xe9\xbf", 2);
-		ret = regmap_write(dev->regmap, 0x1e5, 0xf0);
-		ret = regmap_write(dev->regmap, 0x1d9, 0x00);
-		ret = regmap_write(dev->regmap, 0x1db, 0x00);
-		ret = regmap_write(dev->regmap, 0x1dd, 0x11);
-		ret = regmap_write(dev->regmap, 0x1de, 0xef);
-		ret = regmap_write(dev->regmap, 0x1d8, 0x0c);
-		ret = regmap_write(dev->regmap, 0x1e6, 0x02);
-		ret = regmap_write(dev->regmap, 0x1d7, 0x09);
+		ret = rtl2832_sdr_wr_regs(dev, 0x112, "\x5a", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x102, "\x40", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x103, "\x5a", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x1c7, "\x2c", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x104, "\xcc", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x105, "\xbe", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x1c8, "\x16", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x106, "\x35", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x1c9, "\x21", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x1ca, "\x21", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x1cb, "\x00", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x107, "\x40", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x1cd, "\x10", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x1ce, "\x10", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x108, "\x80", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x109, "\x7f", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x10a, "\x80", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x10b, "\x7f", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x00e, "\xfc", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x00e, "\xfc", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x011, "\xe9\xbf", 2);
+		ret = rtl2832_sdr_wr_regs(dev, 0x1e5, "\xf0", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x1d9, "\x00", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x1db, "\x00", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x1dd, "\x11", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x1de, "\xef", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x1d8, "\x0c", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x1e6, "\x02", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x1d7, "\x09", 1);
 		break;
 	case RTL2832_SDR_TUNER_R820T:
 	case RTL2832_SDR_TUNER_R828D:
-		ret = regmap_write(dev->regmap, 0x112, 0x5a);
-		ret = regmap_write(dev->regmap, 0x102, 0x40);
-		ret = regmap_write(dev->regmap, 0x115, 0x01);
-		ret = regmap_write(dev->regmap, 0x103, 0x80);
-		ret = regmap_write(dev->regmap, 0x1c7, 0x24);
-		ret = regmap_write(dev->regmap, 0x104, 0xcc);
-		ret = regmap_write(dev->regmap, 0x105, 0xbe);
-		ret = regmap_write(dev->regmap, 0x1c8, 0x14);
-		ret = regmap_write(dev->regmap, 0x106, 0x35);
-		ret = regmap_write(dev->regmap, 0x1c9, 0x21);
-		ret = regmap_write(dev->regmap, 0x1ca, 0x21);
-		ret = regmap_write(dev->regmap, 0x1cb, 0x00);
-		ret = regmap_write(dev->regmap, 0x107, 0x40);
-		ret = regmap_write(dev->regmap, 0x1cd, 0x10);
-		ret = regmap_write(dev->regmap, 0x1ce, 0x10);
-		ret = regmap_write(dev->regmap, 0x108, 0x80);
-		ret = regmap_write(dev->regmap, 0x109, 0x7f);
-		ret = regmap_write(dev->regmap, 0x10a, 0x80);
-		ret = regmap_write(dev->regmap, 0x10b, 0x7f);
-		ret = regmap_write(dev->regmap, 0x00e, 0xfc);
-		ret = regmap_write(dev->regmap, 0x00e, 0xfc);
-		ret = regmap_write(dev->regmap, 0x011, 0xf4);
+		ret = rtl2832_sdr_wr_regs(dev, 0x112, "\x5a", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x102, "\x40", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x115, "\x01", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x103, "\x80", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x1c7, "\x24", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x104, "\xcc", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x105, "\xbe", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x1c8, "\x14", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x106, "\x35", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x1c9, "\x21", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x1ca, "\x21", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x1cb, "\x00", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x107, "\x40", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x1cd, "\x10", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x1ce, "\x10", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x108, "\x80", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x109, "\x7f", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x10a, "\x80", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x10b, "\x7f", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x00e, "\xfc", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x00e, "\xfc", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x011, "\xf4", 1);
 		break;
 	case RTL2832_SDR_TUNER_FC2580:
-		ret = regmap_write(dev->regmap, 0x112, 0x39);
-		ret = regmap_write(dev->regmap, 0x102, 0x40);
-		ret = regmap_write(dev->regmap, 0x103, 0x5a);
-		ret = regmap_write(dev->regmap, 0x1c7, 0x2c);
-		ret = regmap_write(dev->regmap, 0x104, 0xcc);
-		ret = regmap_write(dev->regmap, 0x105, 0xbe);
-		ret = regmap_write(dev->regmap, 0x1c8, 0x16);
-		ret = regmap_write(dev->regmap, 0x106, 0x35);
-		ret = regmap_write(dev->regmap, 0x1c9, 0x21);
-		ret = regmap_write(dev->regmap, 0x1ca, 0x21);
-		ret = regmap_write(dev->regmap, 0x1cb, 0x00);
-		ret = regmap_write(dev->regmap, 0x107, 0x40);
-		ret = regmap_write(dev->regmap, 0x1cd, 0x10);
-		ret = regmap_write(dev->regmap, 0x1ce, 0x10);
-		ret = regmap_write(dev->regmap, 0x108, 0x80);
-		ret = regmap_write(dev->regmap, 0x109, 0x7f);
-		ret = regmap_write(dev->regmap, 0x10a, 0x9c);
-		ret = regmap_write(dev->regmap, 0x10b, 0x7f);
-		ret = regmap_write(dev->regmap, 0x00e, 0xfc);
-		ret = regmap_write(dev->regmap, 0x00e, 0xfc);
-		ret = regmap_bulk_write(dev->regmap, 0x011, "\xe9\xf4", 2);
+		ret = rtl2832_sdr_wr_regs(dev, 0x112, "\x39", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x102, "\x40", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x103, "\x5a", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x1c7, "\x2c", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x104, "\xcc", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x105, "\xbe", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x1c8, "\x16", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x106, "\x35", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x1c9, "\x21", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x1ca, "\x21", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x1cb, "\x00", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x107, "\x40", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x1cd, "\x10", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x1ce, "\x10", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x108, "\x80", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x109, "\x7f", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x10a, "\x9c", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x10b, "\x7f", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x00e, "\xfc", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x00e, "\xfc", 1);
+		ret = rtl2832_sdr_wr_regs(dev, 0x011, "\xe9\xf4", 2);
 		break;
 	default:
 		dev_notice(&pdev->dev, "Unsupported tuner\n");
 	}
 
 	/* software reset */
-	ret = regmap_update_bits(dev->regmap, 0x101, 0x04, 0x04);
+	ret = rtl2832_sdr_wr_reg_mask(dev, 0x101, 0x04, 0x04);
 	if (ret)
 		goto err;
 
-	ret = regmap_update_bits(dev->regmap, 0x101, 0x04, 0x00);
+	ret = rtl2832_sdr_wr_reg_mask(dev, 0x101, 0x00, 0x04);
 	if (ret)
 		goto err;
 err:
@@ -758,29 +796,29 @@ static void rtl2832_sdr_unset_adc(struct rtl2832_sdr_dev *dev)
 	dev_dbg(&pdev->dev, "\n");
 
 	/* PID filter */
-	ret = regmap_write(dev->regmap, 0x061, 0xe0);
+	ret = rtl2832_sdr_wr_regs(dev, 0x061, "\xe0", 1);
 	if (ret)
 		goto err;
 
 	/* mode */
-	ret = regmap_write(dev->regmap, 0x019, 0x20);
+	ret = rtl2832_sdr_wr_regs(dev, 0x019, "\x20", 1);
 	if (ret)
 		goto err;
 
-	ret = regmap_bulk_write(dev->regmap, 0x017, "\x11\x10", 2);
+	ret = rtl2832_sdr_wr_regs(dev, 0x017, "\x11\x10", 2);
 	if (ret)
 		goto err;
 
 	/* FSM */
-	ret = regmap_bulk_write(dev->regmap, 0x192, "\x00\x0f\xff", 3);
+	ret = rtl2832_sdr_wr_regs(dev, 0x192, "\x00\x0f\xff", 3);
 	if (ret)
 		goto err;
 
-	ret = regmap_bulk_write(dev->regmap, 0x13e, "\x40\x00", 2);
+	ret = rtl2832_sdr_wr_regs(dev, 0x13e, "\x40\x00", 2);
 	if (ret)
 		goto err;
 
-	ret = regmap_bulk_write(dev->regmap, 0x115, "\x06\x3f\xce\xcc", 4);
+	ret = rtl2832_sdr_wr_regs(dev, 0x115, "\x06\x3f\xce\xcc", 4);
 	if (ret)
 		goto err;
 err:
@@ -1360,7 +1398,6 @@ static int rtl2832_sdr_probe(struct platform_device *pdev)
 	subdev = pdata->v4l2_subdev;
 	dev->v4l2_subdev = pdata->v4l2_subdev;
 	dev->pdev = pdev;
-	dev->regmap = pdata->regmap;
 	dev->udev = pdata->dvb_usb_device->udev;
 	dev->f_adc = bands_adc[0].rangelow;
 	dev->f_tuner = bands_fm[0].rangelow;
diff --git a/drivers/media/dvb-frontends/rtl2832_sdr.h b/drivers/media/dvb-frontends/rtl2832_sdr.h
index d28735c..71b73da 100644
--- a/drivers/media/dvb-frontends/rtl2832_sdr.h
+++ b/drivers/media/dvb-frontends/rtl2832_sdr.h
@@ -52,7 +52,10 @@ struct rtl2832_sdr_platform_data {
 #define RTL2832_SDR_TUNER_R828D     0x2b
 	u8 tuner;
 
-	struct regmap *regmap;
+	struct i2c_client *i2c_client;
+	int (*bulk_read)(struct i2c_client *, unsigned int, void *, size_t);
+	int (*bulk_write)(struct i2c_client *, unsigned int, const void *, size_t);
+	int (*update_bits)(struct i2c_client *, unsigned int, unsigned int, unsigned int);
 	struct dvb_frontend *dvb_frontend;
 	struct v4l2_subdev *v4l2_subdev;
 	struct dvb_usb_device *dvb_usb_device;
diff --git a/drivers/media/dvb-frontends/si2168.c b/drivers/media/dvb-frontends/si2168.c
index 324493e..ca1637e 100644
--- a/drivers/media/dvb-frontends/si2168.c
+++ b/drivers/media/dvb-frontends/si2168.c
@@ -20,23 +20,53 @@
 
 static const struct dvb_frontend_ops si2168_ops;
 
+/* Own I2C adapter locking is needed because of I2C gate logic. */
+static int si2168_i2c_master_send_unlocked(const struct i2c_client *client,
+					   const char *buf, int count)
+{
+	int ret;
+	struct i2c_msg msg = {
+		.addr = client->addr,
+		.flags = 0,
+		.len = count,
+		.buf = (char *)buf,
+	};
+
+	ret = __i2c_transfer(client->adapter, &msg, 1);
+	return (ret == 1) ? count : ret;
+}
+
+static int si2168_i2c_master_recv_unlocked(const struct i2c_client *client,
+					   char *buf, int count)
+{
+	int ret;
+	struct i2c_msg msg = {
+		.addr = client->addr,
+		.flags = I2C_M_RD,
+		.len = count,
+		.buf = buf,
+	};
+
+	ret = __i2c_transfer(client->adapter, &msg, 1);
+	return (ret == 1) ? count : ret;
+}
+
 /* execute firmware command */
-static int si2168_cmd_execute(struct i2c_client *client, struct si2168_cmd *cmd)
+static int si2168_cmd_execute_unlocked(struct i2c_client *client,
+				       struct si2168_cmd *cmd)
 {
-	struct si2168_dev *dev = i2c_get_clientdata(client);
 	int ret;
 	unsigned long timeout;
 
-	mutex_lock(&dev->i2c_mutex);
-
 	if (cmd->wlen) {
 		/* write cmd and args for firmware */
-		ret = i2c_master_send(client, cmd->args, cmd->wlen);
+		ret = si2168_i2c_master_send_unlocked(client, cmd->args,
+						      cmd->wlen);
 		if (ret < 0) {
-			goto err_mutex_unlock;
+			goto err;
 		} else if (ret != cmd->wlen) {
 			ret = -EREMOTEIO;
-			goto err_mutex_unlock;
+			goto err;
 		}
 	}
 
@@ -45,12 +75,13 @@ static int si2168_cmd_execute(struct i2c_client *client, struct si2168_cmd *cmd)
 		#define TIMEOUT 70
 		timeout = jiffies + msecs_to_jiffies(TIMEOUT);
 		while (!time_after(jiffies, timeout)) {
-			ret = i2c_master_recv(client, cmd->args, cmd->rlen);
+			ret = si2168_i2c_master_recv_unlocked(client, cmd->args,
+							      cmd->rlen);
 			if (ret < 0) {
-				goto err_mutex_unlock;
+				goto err;
 			} else if (ret != cmd->rlen) {
 				ret = -EREMOTEIO;
-				goto err_mutex_unlock;
+				goto err;
 			}
 
 			/* firmware ready? */
@@ -65,23 +96,32 @@ static int si2168_cmd_execute(struct i2c_client *client, struct si2168_cmd *cmd)
 		/* error bit set? */
 		if ((cmd->args[0] >> 6) & 0x01) {
 			ret = -EREMOTEIO;
-			goto err_mutex_unlock;
+			goto err;
 		}
 
 		if (!((cmd->args[0] >> 7) & 0x01)) {
 			ret = -ETIMEDOUT;
-			goto err_mutex_unlock;
+			goto err;
 		}
 	}
 
-	mutex_unlock(&dev->i2c_mutex);
 	return 0;
-err_mutex_unlock:
-	mutex_unlock(&dev->i2c_mutex);
+err:
 	dev_dbg(&client->dev, "failed=%d\n", ret);
 	return ret;
 }
 
+static int si2168_cmd_execute(struct i2c_client *client, struct si2168_cmd *cmd)
+{
+	int ret;
+
+	i2c_lock_adapter(client->adapter);
+	ret = si2168_cmd_execute_unlocked(client, cmd);
+	i2c_unlock_adapter(client->adapter);
+
+	return ret;
+}
+
 static int si2168_ts_bus_ctrl(struct dvb_frontend *fe, int acquire)
 {
 	struct i2c_client *client = fe->demodulator_priv;
@@ -639,9 +679,14 @@ static int si2168_get_tune_settings(struct dvb_frontend *fe,
 	return 0;
 }
 
-static int si2168_select(struct i2c_mux_core *muxc, u32 chan)
+/*
+ * I2C gate logic
+ * We must use unlocked I2C I/O because I2C adapter lock is already taken
+ * by the caller (usually tuner driver).
+ */
+static int si2168_select(struct i2c_adapter *adap, void *mux_priv, u32 chan)
 {
-	struct i2c_client *client = i2c_mux_priv(muxc);
+	struct i2c_client *client = mux_priv;
 	int ret;
 	struct si2168_cmd cmd;
 
@@ -649,7 +694,7 @@ static int si2168_select(struct i2c_mux_core *muxc, u32 chan)
 	memcpy(cmd.args, "\xc0\x0d\x01", 3);
 	cmd.wlen = 3;
 	cmd.rlen = 0;
-	ret = si2168_cmd_execute(client, &cmd);
+	ret = si2168_cmd_execute_unlocked(client, &cmd);
 	if (ret)
 		goto err;
 
@@ -659,9 +704,9 @@ static int si2168_select(struct i2c_mux_core *muxc, u32 chan)
 	return ret;
 }
 
-static int si2168_deselect(struct i2c_mux_core *muxc, u32 chan)
+static int si2168_deselect(struct i2c_adapter *adap, void *mux_priv, u32 chan)
 {
-	struct i2c_client *client = i2c_mux_priv(muxc);
+	struct i2c_client *client = mux_priv;
 	int ret;
 	struct si2168_cmd cmd;
 
@@ -669,7 +714,7 @@ static int si2168_deselect(struct i2c_mux_core *muxc, u32 chan)
 	memcpy(cmd.args, "\xc0\x0d\x00", 3);
 	cmd.wlen = 3;
 	cmd.rlen = 0;
-	ret = si2168_cmd_execute(client, &cmd);
+	ret = si2168_cmd_execute_unlocked(client, &cmd);
 	if (ret)
 		goto err;
 
@@ -733,7 +778,6 @@ static int si2168_probe(struct i2c_client *client,
 	}
 
 	i2c_set_clientdata(client, dev);
-	mutex_init(&dev->i2c_mutex);
 
 	/* Initialize */
 	memcpy(cmd.args, "\xc0\x12\x00\x0c\x00\x0d\x16\x00\x00\x00\x00\x00\x00", 13);
@@ -786,22 +830,17 @@ static int si2168_probe(struct i2c_client *client,
 		       (cmd.args[4] - '0') << 8 | (cmd.args[5]) << 0;
 
 	/* create mux i2c adapter for tuner */
-	dev->muxc = i2c_mux_alloc(client->adapter, &client->dev,
-				  1, 0, I2C_MUX_LOCKED,
-				  si2168_select, si2168_deselect);
-	if (!dev->muxc) {
-		ret = -ENOMEM;
+	dev->adapter = i2c_add_mux_adapter(client->adapter, &client->dev,
+			client, 0, 0, 0, si2168_select, si2168_deselect);
+	if (dev->adapter == NULL) {
+		ret = -ENODEV;
 		goto err_kfree;
 	}
-	dev->muxc->priv = client;
-	ret = i2c_mux_add_adapter(dev->muxc, 0, 0, 0);
-	if (ret)
-		goto err_kfree;
 
 	/* create dvb_frontend */
 	memcpy(&dev->fe.ops, &si2168_ops, sizeof(struct dvb_frontend_ops));
 	dev->fe.demodulator_priv = client;
-	*config->i2c_adapter = dev->muxc->adapter[0];
+	*config->i2c_adapter = dev->adapter;
 	*config->fe = &dev->fe;
 	dev->ts_mode = config->ts_mode;
 	dev->ts_clock_inv = config->ts_clock_inv;
@@ -829,7 +868,7 @@ static int si2168_remove(struct i2c_client *client)
 
 	dev_dbg(&client->dev, "\n");
 
-	i2c_mux_del_adapters(dev->muxc);
+	i2c_del_mux_adapter(dev->adapter);
 
 	dev->fe.ops.release = NULL;
 	dev->fe.demodulator_priv = NULL;
diff --git a/drivers/media/dvb-frontends/si2168_priv.h b/drivers/media/dvb-frontends/si2168_priv.h
index 2d362e1..da3cdb6 100644
--- a/drivers/media/dvb-frontends/si2168_priv.h
+++ b/drivers/media/dvb-frontends/si2168_priv.h
@@ -31,8 +31,7 @@
 
 /* state struct */
 struct si2168_dev {
-	struct mutex i2c_mutex;
-	struct i2c_mux_core *muxc;
+	struct i2c_adapter *adapter;
 	struct dvb_frontend fe;
 	enum fe_delivery_system delivery_system;
 	enum fe_status fe_status;
diff --git a/drivers/media/usb/cx231xx/cx231xx-core.c b/drivers/media/usb/cx231xx/cx231xx-core.c
index 4f43668..4e34a99 100644
--- a/drivers/media/usb/cx231xx/cx231xx-core.c
+++ b/drivers/media/usb/cx231xx/cx231xx-core.c
@@ -1340,12 +1340,6 @@ int cx231xx_dev_init(struct cx231xx *dev)
 	if (errCode < 0)
 		return errCode;
 
-	errCode = cx231xx_i2c_mux_create(dev);
-	if (errCode < 0) {
-		dev_err(dev->dev,
-			"%s: Failed to create I2C mux\n", __func__);
-		return errCode;
-	}
 	errCode = cx231xx_i2c_mux_register(dev, 0);
 	if (errCode < 0)
 		return errCode;
@@ -1473,7 +1467,8 @@ EXPORT_SYMBOL_GPL(cx231xx_dev_init);
 void cx231xx_dev_uninit(struct cx231xx *dev)
 {
 	/* Un Initialize I2C bus */
-	cx231xx_i2c_mux_unregister(dev);
+	cx231xx_i2c_mux_unregister(dev, 1);
+	cx231xx_i2c_mux_unregister(dev, 0);
 	cx231xx_i2c_unregister(&dev->i2c_bus[2]);
 	cx231xx_i2c_unregister(&dev->i2c_bus[1]);
 	cx231xx_i2c_unregister(&dev->i2c_bus[0]);
diff --git a/drivers/media/usb/cx231xx/cx231xx-i2c.c b/drivers/media/usb/cx231xx/cx231xx-i2c.c
index 6e1bef2..ad4f36f 100644
--- a/drivers/media/usb/cx231xx/cx231xx-i2c.c
+++ b/drivers/media/usb/cx231xx/cx231xx-i2c.c
@@ -561,34 +561,35 @@ void cx231xx_i2c_unregister(struct cx231xx_i2c *bus)
  * cx231xx_i2c_mux_select()
  * switch i2c master number 1 between port1 and port3
  */
-static int cx231xx_i2c_mux_select(struct i2c_mux_core *muxc, u32 chan_id)
+static int cx231xx_i2c_mux_select(struct i2c_adapter *adap,
+			void *mux_priv, u32 chan_id)
 {
-	struct cx231xx *dev = i2c_mux_priv(muxc);
+	struct cx231xx *dev = mux_priv;
 
 	return cx231xx_enable_i2c_port_3(dev, chan_id);
 }
 
-int cx231xx_i2c_mux_create(struct cx231xx *dev)
-{
-	dev->muxc = i2c_mux_alloc(&dev->i2c_bus[1].i2c_adap, dev->dev, 2, 0, 0,
-				  cx231xx_i2c_mux_select, NULL);
-	if (!dev->muxc)
-		return -ENOMEM;
-	dev->muxc->priv = dev;
-	return 0;
-}
-
 int cx231xx_i2c_mux_register(struct cx231xx *dev, int mux_no)
 {
-	return i2c_mux_add_adapter(dev->muxc,
-				   0,
-				   mux_no /* chan_id */,
-				   0 /* class */);
+	struct i2c_adapter *i2c_parent = &dev->i2c_bus[1].i2c_adap;
+	/* what is the correct mux_dev? */
+	struct device *mux_dev = dev->dev;
+
+	dev->i2c_mux_adap[mux_no] = i2c_add_mux_adapter(i2c_parent,
+				mux_dev,
+				dev /* mux_priv */,
+				0,
+				mux_no /* chan_id */,
+				0 /* class */,
+				&cx231xx_i2c_mux_select,
+				NULL);
+	return dev->i2c_mux_adap[mux_no] ? 0 : -ENOMEM;
 }
 
-void cx231xx_i2c_mux_unregister(struct cx231xx *dev)
+void cx231xx_i2c_mux_unregister(struct cx231xx *dev, int mux_no)
 {
-	i2c_mux_del_adapters(dev->muxc);
+	i2c_del_mux_adapter(dev->i2c_mux_adap[mux_no]);
+	dev->i2c_mux_adap[mux_no] = NULL;
 }
 
 struct i2c_adapter *cx231xx_get_i2c_adap(struct cx231xx *dev, int i2c_port)
@@ -601,9 +602,9 @@ struct i2c_adapter *cx231xx_get_i2c_adap(struct cx231xx *dev, int i2c_port)
 	case I2C_2:
 		return &dev->i2c_bus[2].i2c_adap;
 	case I2C_1_MUX_1:
-		return dev->muxc->adapter[0];
+		return dev->i2c_mux_adap[0];
 	case I2C_1_MUX_3:
-		return dev->muxc->adapter[1];
+		return dev->i2c_mux_adap[1];
 	default:
 		BUG();
 	}
diff --git a/drivers/media/usb/cx231xx/cx231xx.h b/drivers/media/usb/cx231xx/cx231xx.h
index 6ffa4bd..fa35642 100644
--- a/drivers/media/usb/cx231xx/cx231xx.h
+++ b/drivers/media/usb/cx231xx/cx231xx.h
@@ -630,7 +630,6 @@ struct cx231xx {
 
 	/* I2C adapters: Master 1 & 2 (External) & Master 3 (Internal only) */
 	struct cx231xx_i2c i2c_bus[3];
-	struct i2c_mux_core *muxc;
 	struct i2c_adapter *i2c_mux_adap[2];
 
 	unsigned int xc_fw_load_done:1;
@@ -767,9 +766,8 @@ int cx231xx_reset_analog_tuner(struct cx231xx *dev);
 void cx231xx_do_i2c_scan(struct cx231xx *dev, int i2c_port);
 int cx231xx_i2c_register(struct cx231xx_i2c *bus);
 void cx231xx_i2c_unregister(struct cx231xx_i2c *bus);
-int cx231xx_i2c_mux_create(struct cx231xx *dev);
 int cx231xx_i2c_mux_register(struct cx231xx *dev, int mux_no);
-void cx231xx_i2c_mux_unregister(struct cx231xx *dev);
+void cx231xx_i2c_mux_unregister(struct cx231xx *dev, int mux_no);
 struct i2c_adapter *cx231xx_get_i2c_adap(struct cx231xx *dev, int i2c_port);
 
 /* Internal block control functions */
diff --git a/drivers/media/usb/dvb-usb-v2/rtl28xxu.c b/drivers/media/usb/dvb-usb-v2/rtl28xxu.c
index c76e78f..5c805f8 100644
--- a/drivers/media/usb/dvb-usb-v2/rtl28xxu.c
+++ b/drivers/media/usb/dvb-usb-v2/rtl28xxu.c
@@ -1333,7 +1333,10 @@ static int rtl2832u_tuner_attach(struct dvb_usb_adapter *adap)
 	case TUNER_RTL2832_R828D:
 		pdata.clk = dev->rtl2832_platform_data.clk;
 		pdata.tuner = dev->tuner;
-		pdata.regmap = dev->rtl2832_platform_data.regmap;
+		pdata.i2c_client = dev->i2c_client_demod;
+		pdata.bulk_read = dev->rtl2832_platform_data.bulk_read;
+		pdata.bulk_write = dev->rtl2832_platform_data.bulk_write;
+		pdata.update_bits = dev->rtl2832_platform_data.update_bits;
 		pdata.dvb_frontend = adap->fe[0];
 		pdata.dvb_usb_device = d;
 		pdata.v4l2_subdev = subdev;
diff --git a/drivers/media/dvb-frontends/lgdt3306a.c b/drivers/media/dvb-frontends/lgdt3306a.c
index ab16d3a..2988262 100644
--- a/drivers/media/dvb-frontends/lgdt3306a.c
+++ b/drivers/media/dvb-frontends/lgdt3306a.c
@@ -79,8 +79,6 @@ struct lgdt3306a_state {
 	enum fe_modulation current_modulation;
 	u32 current_frequency;
 	u32 snr;
-
-	struct i2c_mux_core *muxc;
 };
 
 /*
@@ -2182,20 +2180,142 @@ static const struct dvb_frontend_ops lgdt3306a_ops = {
 	.search               = lgdt3306a_search,
 };
 
-static int lgdt3306a_select(struct i2c_mux_core *muxc, u32 chan)
+/*
+ * I2C gate logic
+ * We must use unlocked I2C I/O because I2C adapter lock is already taken
+ * by the caller (usually tuner driver).
+ * select/unselect are unlocked versions of lgdt3306a_i2c_gate_ctrl
+ */
+static int lgdt3306a_select(struct i2c_adapter *adap, void *mux_priv, u32 chan)
 {
-	struct i2c_client *client = i2c_mux_priv(muxc);
-	struct lgdt3306a_state *state = i2c_get_clientdata(client);
+	struct i2c_client *client = mux_priv;
+	int ret;
+	u8 val;
+	u8 buf[3];
+
+	struct i2c_msg read_msg_1 = {
+		.addr = client->addr,
+		.flags = 0,
+		.buf = "\x00\x02",
+		.len = 2,
+	};
+	struct i2c_msg read_msg_2 = {
+		.addr = client->addr,
+		.flags = I2C_M_RD,
+		.buf = &val,
+		.len = 1,
+	};
+
+	struct i2c_msg write_msg = {
+		.addr = client->addr,
+		.flags = 0,
+		.len = 3,
+		.buf = buf,
+	};
+
+	ret = __i2c_transfer(client->adapter, &read_msg_1, 1);
+	if (ret != 1)
+	{
+		pr_err("error (addr %02x reg 0x002 error (ret == %i)\n",
+		       client->addr, ret);
+		if (ret < 0)
+			return ret;
+		else
+			return -EREMOTEIO;
+	}
 
-	return lgdt3306a_i2c_gate_ctrl(&state->frontend, 1);
+	ret = __i2c_transfer(client->adapter, &read_msg_2, 1);
+	if (ret != 1)
+	{
+		pr_err("error (addr %02x reg 0x002 error (ret == %i)\n",
+		       client->addr, ret);
+		if (ret < 0)
+			return ret;
+		else
+			return -EREMOTEIO;
+	}
+
+	buf[0] = 0x00;
+	buf[1] = 0x02;
+	val &= 0x7F;
+	val |= LG3306_TUNERI2C_ON;
+	buf[2] = val;
+	ret = __i2c_transfer(client->adapter, &write_msg, 1);
+	if (ret != 1) {
+		pr_err("error (addr %02x %02x <- %02x, err = %i)\n",
+		       write_msg.buf[0], write_msg.buf[1], write_msg.buf[2], ret);
+		if (ret < 0)
+			return ret;
+		else
+			return -EREMOTEIO;
+	}
+	return 0;
 }
 
-static int lgdt3306a_deselect(struct i2c_mux_core *muxc, u32 chan)
+static int lgdt3306a_deselect(struct i2c_adapter *adap, void *mux_priv, u32 chan)
 {
-	struct i2c_client *client = i2c_mux_priv(muxc);
-	struct lgdt3306a_state *state = i2c_get_clientdata(client);
+	struct i2c_client *client = mux_priv;
+	int ret;
+	u8 val;
+	u8 buf[3];
+
+	struct i2c_msg read_msg_1 = {
+		.addr = client->addr,
+		.flags = 0,
+		.buf = "\x00\x02",
+		.len = 2,
+	};
+	struct i2c_msg read_msg_2 = {
+		.addr = client->addr,
+		.flags = I2C_M_RD,
+		.buf = &val,
+		.len = 1,
+	};
 
-	return lgdt3306a_i2c_gate_ctrl(&state->frontend, 0);
+	struct i2c_msg write_msg = {
+		.addr = client->addr,
+		.flags = 0,
+		.len = 3,
+		.buf = buf,
+	};
+
+	ret = __i2c_transfer(client->adapter, &read_msg_1, 1);
+	if (ret != 1)
+	{
+		pr_err("error (addr %02x reg 0x002 error (ret == %i)\n",
+		       client->addr, ret);
+		if (ret < 0)
+			return ret;
+		else
+			return -EREMOTEIO;
+	}
+
+	ret = __i2c_transfer(client->adapter, &read_msg_2, 1);
+	if (ret != 1)
+	{
+		pr_err("error (addr %02x reg 0x002 error (ret == %i)\n",
+		       client->addr, ret);
+		if (ret < 0)
+			return ret;
+		else
+			return -EREMOTEIO;
+	}
+
+	buf[0] = 0x00;
+	buf[1] = 0x02;
+	val &= 0x7F;
+	val |= LG3306_TUNERI2C_OFF;
+	buf[2] = val;
+	ret = __i2c_transfer(client->adapter, &write_msg, 1);
+	if (ret != 1) {
+		pr_err("error (addr %02x %02x <- %02x, err = %i)\n",
+		       write_msg.buf[0], write_msg.buf[1], write_msg.buf[2], ret);
+		if (ret < 0)
+			return ret;
+		else
+			return -EREMOTEIO;
+	}
+	return 0;
 }
 
 static int lgdt3306a_probe(struct i2c_client *client,
@@ -2227,21 +2347,16 @@ static int lgdt3306a_probe(struct i2c_client *client,
 	state->frontend.ops.release = NULL;
 
 	/* create mux i2c adapter for tuner */
-	state->muxc = i2c_mux_alloc(client->adapter, &client->dev,
-				  1, 0, I2C_MUX_LOCKED,
-				  lgdt3306a_select, lgdt3306a_deselect);
-	if (!state->muxc) {
-		ret = -ENOMEM;
+	state->i2c_adap = i2c_add_mux_adapter(client->adapter, &client->dev,
+			client, 0, 0, 0, lgdt3306a_select, lgdt3306a_deselect);
+	if (state->i2c_adap == NULL) {
+		ret = -ENODEV;
 		goto err_kfree;
 	}
-	state->muxc->priv = client;
-	ret = i2c_mux_add_adapter(state->muxc, 0, 0, 0);
-	if (ret)
-		goto err_kfree;
 
 	/* create dvb_frontend */
 	fe->ops.i2c_gate_ctrl = NULL;
-	*config->i2c_adapter = state->muxc->adapter[0];
+	*config->i2c_adapter = state->i2c_adap;
 	*config->fe = fe;
 
 	dev_info(&client->dev, "LG Electronics LGDT3306A successfully identified\n");
@@ -2261,7 +2376,7 @@ static int lgdt3306a_remove(struct i2c_client *client)
 {
 	struct lgdt3306a_state *state = i2c_get_clientdata(client);
 
-	i2c_mux_del_adapters(state->muxc);
+	i2c_del_mux_adapter(state->i2c_adap);
 
 	state->frontend.ops.release = NULL;
 	state->frontend.demodulator_priv = NULL;
diff --git a/drivers/media/dvb-frontends/lgdt3306a.h b/drivers/media/dvb-frontends/lgdt3306a.h
index 8b53044..99b28be 100644
--- a/drivers/media/dvb-frontends/lgdt3306a.h
+++ b/drivers/media/dvb-frontends/lgdt3306a.h
@@ -21,6 +21,8 @@
 #include <linux/i2c.h>
 #include <media/dvb_frontend.h>
 
+#define LG3306_TUNERI2C_ON  0x00
+#define LG3306_TUNERI2C_OFF 0x80
 
 enum lgdt3306a_mpeg_mode {
 	LGDT3306A_MPEG_PARALLEL = 0,
