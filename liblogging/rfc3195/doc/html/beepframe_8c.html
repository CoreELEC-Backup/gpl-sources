<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>liblogging: beepframe.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Compound&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Compound&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>beepframe.c File Reference</h1>Implementation of the BEEP Frame object.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;assert.h&gt;</code><br>
<code>#include "<a class="el" href="config_8h-source.html">config.h</a>"</code><br>
<code>#include "<a class="el" href="liblogging_8h-source.html">liblogging.h</a>"</code><br>
<code>#include "<a class="el" href="sockets_8h-source.html">sockets.h</a>"</code><br>
<code>#include "<a class="el" href="beepmessage_8h-source.html">beepmessage.h</a>"</code><br>
<code>#include "<a class="el" href="beepframe_8h-source.html">beepframe.h</a>"</code><br>
<code>#include "<a class="el" href="beepchannel_8h-source.html">beepchannel.h</a>"</code><br>
<code>#include "<a class="el" href="beepsession_8h-source.html">beepsession.h</a>"</code><br>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>unsigned&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="beepframe_8c.html#a0">sbFramRecvUnsigned</a> (<a class="el" href="structsbSockObject.html">sbSockObj</a> *pSock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive an unsigned integer from the channel. </em> <a href="#a0"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="beepframe_8c.html#a1">sbFramActualRecvFramSEQ</a> (<a class="el" href="structsbFramObject.html">sbFramObj</a> *pThis, <a class="el" href="structsbChanObject.html">sbChanObj</a> *pChan)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper to sbFramActualRecvFram; receives an SEQ frame off the wire. </em> <a href="#a1"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="beepframe_8c.html#a2">sbFramActualRecvFramCommonHdr</a> (<a class="el" href="structsbFramObject.html">sbFramObj</a> *pThis, <a class="el" href="structsbChanObject.html">sbChanObj</a> *pChan)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper to sbFramActualRecvFramAns and *Normal; receives the common header off the wire. </em> <a href="#a2"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="beepframe_8c.html#a3">sbFramActualRecvFramCommonBody</a> (<a class="el" href="structsbFramObject.html">sbFramObj</a> *pThis, <a class="el" href="structsbChanObject.html">sbChanObj</a> *pChan)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper to sbFramActualRecvFramAns and *Normal; receives the common body off the wire. </em> <a href="#a3"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="beepframe_8c.html#a4">sbFramActualRecvFramANS</a> (<a class="el" href="structsbFramObject.html">sbFramObj</a> *pThis, <a class="el" href="structsbChanObject.html">sbChanObj</a> *pChan)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper to sbFramActualRecvFram; receives an ANS frame off the wire. </em> <a href="#a4"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="beepframe_8c.html#a5">sbFramActualRecvFramNormal</a> (<a class="el" href="structsbFramObject.html">sbFramObj</a> *pThis, <a class="el" href="structsbChanObject.html">sbChanObj</a> *pChan)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper to sbFramActualRecvFram; receives a normal (that is non-SEQ and non-ANS) frame off the wire. </em> <a href="#a5"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>BEEPHdrID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="beepframe_8c.html#a6">sbFramHdrID</a> (char *szCmd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the header ID for a given BEEP command header. </em> <a href="#a6"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="beepframe_8c.html#a7">sbFramConstruct</a> (<a class="el" href="structsbFramObject.html">sbFramObj</a> **ppThis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a frame. </em> <a href="#a7"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a8" doxytag="beepframe.c::sbFramGetHdrID"></a>
BEEPHdrID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="beepframe_8c.html#a8">sbFramGetHdrID</a> (<a class="el" href="structsbFramObject.html">sbFramObj</a> *pThis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the header id of this BEEP frame. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a9" doxytag="beepframe.c::sbFramGetFrameLen"></a>
int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="beepframe_8c.html#a9">sbFramGetFrameLen</a> (<a class="el" href="structsbFramObject.html">sbFramObj</a> *pThis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return length of frame <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a10" doxytag="beepframe.c::sbFramGetFrame"></a>
char *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="beepframe_8c.html#a10">sbFramGetFrame</a> (<a class="el" href="structsbFramObject.html">sbFramObj</a> *pThis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return frame content <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structsbFramObject.html">sbFramObj</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="beepframe_8c.html#a11">sbFramCreateFramFromMesg</a> (<a class="el" href="structsbChanObject.html">sbChanObj</a> *pChan, <a class="el" href="structsbMesgObject.html">sbMesgObj</a> *pMesg, char *pszCmd, <a class="el" href="liblogging_8h.html#a9">SBansno</a> uAnsno)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a frame from a Message. </em> <a href="#a11"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="beepframe_8c.html#a12">sbFramCreateSEQFram</a> (<a class="el" href="structsbFramObject.html">sbFramObj</a> **ppThis, <a class="el" href="structsbChanObject.html">sbChanObj</a> *pChan, <a class="el" href="liblogging_8h.html#a12">SBackno</a> uAckno, <a class="el" href="liblogging_8h.html#a13">SBwindow</a> uWindow)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a SEQ frame for a given channel with a given ackno. </em> <a href="#a12"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structsbFramObject.html">sbFramObj</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="beepframe_8c.html#a13">sbFramActualRecvFram</a> (<a class="el" href="structsbSessObject.html">sbSessObj</a> *pSess)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Actually receive a frame off the tcp stream. </em> <a href="#a13"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a14" doxytag="beepframe.c::sbFramDestroy"></a>
<a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="beepframe_8c.html#a14">sbFramDestroy</a> (<a class="el" href="structsbFramObject.html">sbFramObj</a> *pThis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">destroy a frame object <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structsbFramObject.html">sbFramObj</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="beepframe_8c.html#a15">sbFramRecvFram</a> (<a class="el" href="structsbChanObject.html">sbChanObj</a> *pChan)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Logically receive a frame. </em> <a href="#a15"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="beepframe_8c.html#a16">sbFramSendFram</a> (<a class="el" href="structsbFramObject.html">sbFramObj</a> *pThis, <a class="el" href="structsbChanObject.html">sbChanObj</a> *pChan)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send a frame on a channel (logical). </em> <a href="#a16"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a17" doxytag="beepframe.c::sbFramSetOnDestroyEvent"></a>
<a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><b>sbFramSetOnDestroyEvent</b> (<a class="el" href="structsbFramObject.html">sbFramObj</a> *pThis, void(*OnFramDestroy)(<a class="el" href="structsbFramObject.html">sbFramObj</a> *), void *pUsr)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Implementation of the BEEP Frame object. 
<p>
<dl compact><dt><b>Author:</b></dt><dd>Rainer Gerhards &lt;<a href="mailto:rgerhards@adiscon.com">rgerhards@adiscon.com</a>&gt; </dd></dl>
<dl compact><dt><b>Date:</b></dt><dd>2003-08-04</dd></dl>
Copyright 2002-2003 Rainer Gerhards and Adiscon GmbH. All Rights Reserved.<p>
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:<p>
* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.<p>
* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.<p>
* Neither the name of Adiscon GmbH or Rainer Gerhards nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.<p>
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<hr><h2>Function Documentation</h2>
<a name="a13" doxytag="beepframe.c::sbFramActualRecvFram"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structsbFramObject.html">sbFramObj</a>* sbFramActualRecvFram </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsbSessObject.html">sbSessObj</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>pSess</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Actually receive a frame off the tcp stream. 
<p>
Be sure to read <a class="el" href="architecture_8c.html">architecture::c</a> for a full explanation of what ActualRecvFram and its associated methods do in an overall context.<p>
In detail, it receives a frame off the wire and returns the resulting farme object to its caller. It detects different frame formats (like SEQ frames).<p>
This is a BLOCKING method call. It blocks until the frame is complete or a timeout occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pSess</em>&nbsp;</td><td>pointer to session object. This session is to be used to receive the frame.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pointer</em>&nbsp;</td><td>to the received frame object or NULL, if an error occured. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a4" doxytag="beepframe.c::sbFramActualRecvFramANS"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="liblogging_8h.html#a6">srRetVal</a> sbFramActualRecvFramANS </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsbFramObject.html">sbFramObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pThis</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structsbChanObject.html">sbChanObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pChan</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Helper to sbFramActualRecvFram; receives an ANS frame off the wire. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pThis</em>&nbsp;</td><td>[in/out] frame object to be filled. This is partly created by the caller. new properties read by this function are filled in. We do it that way so that we can e.g. do error checking for calloc() failures only in the caller. Saves us some code ;) </td></tr>
    <tr><td valign=top><em>pChan</em>&nbsp;</td><td>[in/out] the channel to receive the frame on. The channel object is updated, e.g. with a new seqno. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a3" doxytag="beepframe.c::sbFramActualRecvFramCommonBody"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> sbFramActualRecvFramCommonBody </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsbFramObject.html">sbFramObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pThis</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structsbChanObject.html">sbChanObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pChan</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Helper to sbFramActualRecvFramAns and *Normal; receives the common body off the wire. 
<p>
The body is defined to start WITH the CRLF in the header. As such, this method processes the<p>
<ul>
<li>header CRLF</li><li>payload</li><li>trailer</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pThis</em>&nbsp;</td><td>[in/out] frame object to be filled. This is partly created by the caller. new properties read by this function are filled in. We do it that way so that we can e.g. do error checking for calloc() failures only in the caller. Saves us some code ;) </td></tr>
    <tr><td valign=top><em>pChan</em>&nbsp;</td><td>[in/out] the channel to receive the frame on. The channel object is updated, e.g. with a new seqno. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a2" doxytag="beepframe.c::sbFramActualRecvFramCommonHdr"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="liblogging_8h.html#a6">srRetVal</a> sbFramActualRecvFramCommonHdr </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsbFramObject.html">sbFramObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pThis</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structsbChanObject.html">sbChanObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pChan</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Helper to sbFramActualRecvFramAns and *Normal; receives the common header off the wire. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pThis</em>&nbsp;</td><td>[in/out] frame object to be filled. This is partly created by the caller. new properties read by this function are filled in. We do it that way so that we can e.g. do error checking for calloc() failures only in the caller. Saves us some code ;) </td></tr>
    <tr><td valign=top><em>pChan</em>&nbsp;</td><td>[in/out] the channel to receive the frame on. The channel object is updated, e.g. with a new seqno.</td></tr>
  </table>
</dl>
<dl compact><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>improve!</dd></dl>
    </td>
  </tr>
</table>
<a name="a5" doxytag="beepframe.c::sbFramActualRecvFramNormal"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="liblogging_8h.html#a6">srRetVal</a> sbFramActualRecvFramNormal </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsbFramObject.html">sbFramObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pThis</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structsbChanObject.html">sbChanObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pChan</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Helper to sbFramActualRecvFram; receives a normal (that is non-SEQ and non-ANS) frame off the wire. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pThis</em>&nbsp;</td><td>[in/out] frame object to be filled. This is partly created by the caller. new properties read by this function are filled in. We do it that way so that we can e.g. do error checking for calloc() failures only in the caller. Saves us some code ;) </td></tr>
    <tr><td valign=top><em>pChan</em>&nbsp;</td><td>[in/out] the channel to receive the frame on. The channel object is updated, e.g. with a new seqno. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a1" doxytag="beepframe.c::sbFramActualRecvFramSEQ"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="liblogging_8h.html#a6">srRetVal</a> sbFramActualRecvFramSEQ </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsbFramObject.html">sbFramObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pThis</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structsbChanObject.html">sbChanObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pChan</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Helper to sbFramActualRecvFram; receives an SEQ frame off the wire. 
<p>
See RFC 3081, 3.1.3 for the semantics of a SEQ frame.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pThis</em>&nbsp;</td><td>[in/out] frame object to be filled. This is partly created by the caller. new properties read by this function are filled in. We do it that way so that we can e.g. do error checking for calloc() failures only in the caller. Saves us some code ;) </td></tr>
    <tr><td valign=top><em>pChan</em>&nbsp;</td><td>[in/out] the channel to receive the frame on. The channel object is updated, e.g. with a new seqno. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a7" doxytag="beepframe.c::sbFramConstruct"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="liblogging_8h.html#a6">srRetVal</a> sbFramConstruct </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsbFramObject.html">sbFramObj</a> **&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>ppThis</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Construct a frame. 
<p>
This builds the memory structure, only but does not do anything to actually populate it.     </td>
  </tr>
</table>
<a name="a11" doxytag="beepframe.c::sbFramCreateFramFromMesg"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structsbFramObject.html">sbFramObj</a>* sbFramCreateFramFromMesg </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsbChanObject.html">sbChanObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pChan</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structsbMesgObject.html">sbMesgObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pMesg</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>pszCmd</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="liblogging_8h.html#a9">SBansno</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>uAnsno</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a frame from a Message. 
<p>
With the current implementation, there is a one-to-one relationship between fram and mesg, so this is faily simple ;)<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pChan</em>&nbsp;</td><td>[in/out] Channel object that this frame will be sent on. Is updated with new SEQ number.</td></tr>
    <tr><td valign=top><em>pMesg</em>&nbsp;</td><td>[in] Pointer to the Mesg to be converted. This buffer must not be modified by Mesg after CreateFramFromMesg has been called!</td></tr>
    <tr><td valign=top><em>pszCmd</em>&nbsp;</td><td>[in] HDR-Command ("ANS", "MSG", ...) to be used.</td></tr>
    <tr><td valign=top><em>uAnso</em>&nbsp;</td><td>[in] if the HDR-Command is "ANS", this is the ansno to be used. Ignored with any other HDR-Command.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>Pointer</em>&nbsp;</td><td>to a newly created Frame object or NULL if an error occured. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a12" doxytag="beepframe.c::sbFramCreateSEQFram"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="liblogging_8h.html#a6">srRetVal</a> sbFramCreateSEQFram </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsbFramObject.html">sbFramObj</a> **&nbsp;</td>
          <td class="mdname" nowrap> <em>ppThis</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structsbChanObject.html">sbChanObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pChan</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="liblogging_8h.html#a12">SBackno</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>uAckno</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="liblogging_8h.html#a13">SBwindow</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>uWindow</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Construct a SEQ frame for a given channel with a given ackno. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pChan</em>&nbsp;</td><td>Channel this SEQ is for. </td></tr>
    <tr><td valign=top><em>uAckno</em>&nbsp;</td><td>ackno to use in the SEQ. Can not be 0. </td></tr>
    <tr><td valign=top><em>uWindow</em>&nbsp;</td><td>Window to use in the SEQ. If 0, use BEEP default. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a6" doxytag="beepframe.c::sbFramHdrID"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BEEPHdrID sbFramHdrID </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>szCmd</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the header ID for a given BEEP command header. 
<p>
This is implemented in the sbFram object as sbFram ultimately creaetes the frames and thus the IDs. One could argue if a better place would be some util helper...<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>psz</em>&nbsp;</td><td>[in] pointer to a BEEP header command ("MSG", ...) </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>matching</em>&nbsp;</td><td>header id </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a15" doxytag="beepframe.c::sbFramRecvFram"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structsbFramObject.html">sbFramObj</a>* sbFramRecvFram </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsbChanObject.html">sbChanObj</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>pChan</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Logically receive a frame. 
<p>
This method uses the session object to do the physical receive. See <a class="el" href="architecture_8c.html">architecture::c</a> for a full description of this interaction.<p>
This is just a slim wrapper to hide the implementation details.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pChan</em>&nbsp;</td><td>[in/out] associated channel </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pointer</em>&nbsp;</td><td>to new frame object or NULL, if in error. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a0" doxytag="beepframe.c::sbFramRecvUnsigned"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> unsigned sbFramRecvUnsigned </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsbSockObject.html">sbSockObj</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>pSock</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Receive an unsigned integer from the channel. 
<p>
Eats up characters as it processes them.<p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>integer</em>&nbsp;</td><td>receive. If there are no digits immediately in the input stream, 0 is returned and no character is taken from the input stream. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a16" doxytag="beepframe.c::sbFramSendFram"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="liblogging_8h.html#a6">srRetVal</a> sbFramSendFram </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsbFramObject.html">sbFramObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pThis</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structsbChanObject.html">sbChanObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pChan</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Send a frame on a channel (logical). 
<p>
This method does not directly put the data on the wire but calls the session object to initiate this. This sequence allows for limited multiprocessing inside the stack. Please see <a class="el" href="architecture_8c.html">architecture::c</a> for a full description.<p>
This is just a very thin layer in this release.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pChan</em>&nbsp;</td><td>the associated channel (where the frame is to be sent). </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Mon Oct 3 12:29:55 2005 for liblogging by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.2 </small></address>
</body>
</html>
