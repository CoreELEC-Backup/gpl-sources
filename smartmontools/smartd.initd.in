#! /bin/sh

# smartmontools init file for smartd
# Copyright (C) 2002-8 Bruce Allen
# SPDX-License-Identifier: GPL-2.0-or-later
# $Id: smartd.initd.in 4760 2018-08-19 18:45:53Z chrfranke $

# For RedHat and cousins:
# chkconfig: 2345 40 40
# description: Self Monitoring and Reporting Technology (SMART) Daemon
# processname: smartd 

# For SuSE and cousins
### BEGIN INIT INFO
# Provides:                   smartd
# Required-Start:             $syslog $remote_fs
# Should-Start:               sendmail
# Required-Stop:              $syslog $remote_fs
# Should-Stop:                sendmail
# Default-Start:              2 3 5
# Default-Stop:
# Short-Description:          Monitors disk and tape health via S.M.A.R.T.
# Description:                Start S.M.A.R.T. disk and tape monitor.
### END INIT INFO

# Uncomment the line below to pass options to smartd on startup. 
# Note that distribution specific configuration files like
# /etc/{default,sysconfig}/smartmontools might override these
#smartd_opts="--interval=1800"

SMARTD_BIN=/usr/local/sbin/smartd

report_unsupported () {
    echo "Currently the smartmontools package has no init script for"
    echo "the $1 OS/distribution. If you can provide one or this"
    echo "one works after removing some ifdefs, please contact"
    echo "smartmontools-support@listi.jpberlin.de."
    exit 1
}

# Red Hat or Yellow Dog or Mandrake
if [ -f /etc/redhat-release -o -f /etc/yellowdog-release -o -f /etc/mandrake-release -o -f /etc/whitebox-release -o -f /etc/trustix-release -o -f /etc/tinysofa-release ] ; then

    # Source function library
    . /etc/rc.d/init.d/functions

    # Source configuration file.  This should define the shell variable smartd_opts
    [ -r /etc/sysconfig/smartmontools ] && . /etc/sysconfig/smartmontools

    RETVAL=0

    prog=smartd
    pidfile=/var/lock/subsys/smartd
    config=/etc/smartd.conf

    start()
    {
	[ $UID -eq 0 ] || exit 4
	[ -x $SMARTD_BIN ] || exit 5
	[ -f $config ] || exit 6
	echo -n $"Starting $prog: "
	daemon $SMARTD_BIN $smartd_opts
	RETVAL=$?
	echo
	[ $RETVAL = 0 ] && touch $pidfile
	return $RETVAL
    }

    stop()
    {
	[ $UID -eq 0 ] || exit 4
	echo -n $"Shutting down $prog: "
	killproc $SMARTD_BIN
	RETVAL=$?
	echo
	rm -f $pidfile
	return $RETVAL
    }

    reload()
    {
	echo -n $"Reloading $prog daemon configuration: "
	killproc $SMARTD_BIN -HUP
	RETVAL=$?
	echo
	return $RETVAL
    }

    report()
    {
	echo -n $"Checking SMART devices now: "
	killproc $SMARTD_BIN -USR1
	RETVAL=$?
	echo
	return $RETVAL
    }

    case "$1" in
	start)
		start
		;;
	stop)
		stop
		;;
	reload)
		reload
		;;
	report)
		report
		;;
	restart)
		stop
		start
		;;
	condrestart|try-restart)
		if [ -f $pidfile ]; then
			stop
			start
		fi
		;;
	force-reload)
		reload || (stop; start)
		;;
	status)
		status $prog
		RETVAL=$?
		;;
	*)
		echo $"Usage: $0 {start|stop|restart|status|condrestart|try-restart|reload|force-reload|report}"
		RETVAL=2
		[ "$1" = 'usage' ] && RETVAL=0
    esac
    exit $RETVAL

# Slackware
elif [ -f /etc/slackware-version ] ; then

    # Source configuration file.  This should define the shell variable smartd_opts.
    # Email smartmontools-support mailing list if there is a better choice
    # of path for Slackware.

    [ -r /etc/sysconfig/smartmontools ] && . /etc/sysconfig/smartmontools

    RETVAL=0
    case "$1" in
	start)
	    echo -n "Starting smartd: "
	    $SMARTD_BIN $smartd_opts
	    RETVAL=$?
	    echo
	    ;;
	stop)
	    echo -n "Shutting down smartd: "
	    killall $SMARTD_BIN
	    RETVAL=$?
	    echo
	    ;;
	restart)
	    $0 stop
	    sleep 1
	    $0 start
	    RETVAL=$?
	    ;;
	try-restart)
	    if pidof $SMARTD_BIN >/dev/null; then
		$0 restart
		RETVAL=$?
	    fi
	    ;;
	force-reload)
	    $0 reload || $0 restart
	    RETVAL=$?
	    ;;
	reload)
	    echo -n "Reloading smartd configuration: "
	    killall -s HUP $SMARTD_BIN
	    RETVAL=$?
	    echo
	    ;;
	report)
	    echo -n "Checking SMART devices now: "
	    killall -s USR1 $SMARTD_BIN
	    RETVAL=$?
	    echo
	    ;;
	status)
	    if pidof $SMARTD_BIN >/dev/null; then
		echo "$SMARTD_BIN is running."
	    else
		echo "$SMARTD_BIN is not running."
		RETVAL=1
	    fi
	    ;;
	*)
	    echo "Usage: $0 {start|stop|restart|try-restart|force-reload|reload|report|status}"
	    RETVAL=1
    esac
    exit $RETVAL

# SuSE
elif [ -f /etc/SuSE-release ] ; then
    test -x $SMARTD_BIN || exit 5

    # Existence of config file is optional
    SMARTD_CONFIG=/etc/smartd.conf

    # source configuration file.
    [ -r /etc/sysconfig/smartmontools ] && . /etc/sysconfig/smartmontools
    smartd_opts=
    if test -n "$SMARTD_CHECK_INTERVAL" -a "$SMARTD_CHECK_INTERVAL" != 1800 ; then
       smartd_opts=" -i $SMARTD_CHECK_INTERVAL"
    fi
    if test -n "$SMARTD_LOG_FACILITY" -a "$SMARTD_LOG_FACILITY" != "daemon" ; then
       smartd_opts="$smartd_opts -l $SMARTD_LOG_FACILITY"
    fi
    if test -n "$SMARTD_DRIVEDB" ; then
       smartd_opts="$smartd_opts -B $SMARTD_DRIVEDB"
    fi
    if test "$SMARTD_SAVESTATES" = "no" ; then
	smartd_opts="$smartd_opts -s \"\""
    fi
    if test "$SMARTD_ATTRLOG" = "no" ; then
	smartd_opts="$smartd_opts -A \"\""
    fi
    if test -n "$SMARTD_EXTRA_OPTS" ; then
	smartd_opts="$smartd_opts $SMARTD_EXTRA_OPTS"
    fi

    # Shell functions sourced from /etc/rc.status:
    #      rc_check         check and set local and overall rc status
    #      rc_status        check and set local and overall rc status
    #      rc_status -v     be verbose in local rc status and clear it afterwards
    #      rc_status -v -r  ditto and clear both the local and overall rc status
    #      rc_status -s     display "skipped" and exit with status 3
    #      rc_status -u     display "unused" and exit with status 3
    #      rc_failed        set local and overall rc status to failed
    #      rc_failed <num>  set local and overall rc status to <num>
    #      rc_reset         clear both the local and overall rc status
    #      rc_exit          exit appropriate to overall rc status
    #      rc_active        checks whether a service is activated by symlinks
    . /etc/rc.status

    # Reset status of this service
    rc_reset

    # Return values acc. to LSB for all commands but status:
    # 0       - success
    # 1       - generic or unspecified error
    # 2       - invalid or excess argument(s)
    # 3       - unimplemented feature (e.g. "reload")
    # 4       - user had insufficient privileges
    # 5       - program is not installed
    # 6       - program is not configured
    # 7       - program is not running
    # 8--199  - reserved (8--99 LSB, 100--149 distrib, 150--199 appl)
    #
    # Note that starting an already running service, stopping
    # or restarting a not-running service as well as the restart
    # with force-reload (in case signaling is not supported) are
    # considered a success.

    case "$1" in
	start)
	    echo -n "Starting smartd "
	    ## Start daemon with startproc(8). If this fails
	    ## the return value is set appropriately by startproc.

	    # We don't use startproc - we need to check for return code 17.
	    if ! /sbin/checkproc $SMARTD_BIN ; then
		eval $SMARTD_BIN$smartd_opts
		# Remember status and be verbose
		if test $? -ne 17 ; then
		    rc_status -v
		else
		    rc_status -u
		fi
	    else
		rc_reset
		rc_status -v
	    fi
	    ;;
	stop)
	    echo -n "Shutting down smartd "
	    /sbin/killproc -TERM $SMARTD_BIN
	    # Remember status and be verbose
	    rc_status -v
	    ;;
	try-restart)
	    ## Do a restart only if the service was active before.
	    ## Note: try-restart is now part of LSB (as of 1.9).
	    $0 status
	    if test $? = 0; then
		$0 restart
	    else
		rc_reset	# Not running is not a failure.
	    fi
	    # Remember status and be quiet
	    rc_status
	    ;;
	restart)
	    $0 stop
	    $0 start
	    # Remember status and be quiet
	    rc_status
	    ;;
	force-reload|reload)
	    echo -n "Reload service smartd "
	    /sbin/killproc -HUP $SMARTD_BIN
	    rc_status -v
	    ;;
	report)
	    ## Checking SMART devices now (smartd specific function)
	    echo -n "Checking SMART devices now "
	    /sbin/killproc -USR1 $SMARTD_BIN
	    rc_status -v
	    ;;
	status)
	    echo -n "Checking for service smartd "
	    ## Check status with checkproc(8), if process is running
	    ## checkproc will return with exit status 0.

	    # Return value is slightly different for the status command:
	    # 0 - service up and running
	    # 1 - service dead, but /var/run/  pid  file exists
	    # 2 - service dead, but /var/lock/ lock file exists
	    # 3 - service not running (unused)
	    # 4 - service status unknown :-(
	    # 5--199 reserved (5--99 LSB, 100--149 distro, 150--199 appl.)

	    # NOTE: checkproc returns LSB compliant status values.
	    /sbin/checkproc $SMARTD_BIN
	    rc_status -v
	    ;;
	probe)
	    ## Optional: Probe for the necessity of a reload, print out the
	    ## argument to this init script which is required for a reload.
	    ## Note: probe is not (yet) part of LSB (as of 1.9)

	    test $SMARTD_CONFIG -nt /var/run/smartd.pid && echo reload
	    ;;
	*)
	    echo "Usage: $0 {start|stop|status|try-restart|restart|force-reload|reload|report|probe}"
	    exit 1
    esac
    rc_exit

# Debian case
elif [ -f /etc/debian_version ] ; then
    PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin
    SMARTDPID=/var/run/smartd.pid
    [ -x $SMARTD_BIN ] || exit 0
    RET=0

    # source configuration file
    [ -r /etc/default/rcS ] && . /etc/default/rcS
    [ -r /etc/default/smartmontools ] && . /etc/default/smartmontools

    smartd_opts="--pidfile $SMARTDPID $smartd_opts"

    case "$1" in
	start)
		echo -n "Starting S.M.A.R.T. daemon: smartd"
		if start-stop-daemon --start --quiet --pidfile $SMARTDPID \
			--exec $SMARTD_BIN -- $smartd_opts; then
			echo "."
		else
			echo " (failed)"
			RET=1
		fi
		;;
	stop)
		echo -n "Stopping S.M.A.R.T. daemon: smartd"
		start-stop-daemon --stop --quiet --oknodo --pidfile $SMARTDPID
		echo "."
		;;
	restart)
		$0 stop
		$0 start
		;;
	force-reload)
		$0 reload || $0 restart
		;;
	reload)
		echo -n "Reload S.M.A.R.T. daemon: smartd"
		if start-stop-daemon --stop --quiet --signal 1 \
			--pidfile $SMARTDPID; then
			echo "."
		else
			echo " (failed)"
			RET=1
		fi
		;;
	report)
		echo -n "Checking SMART devices now"
		if start-stop-daemon --stop --quiet --signal 10 \
			--pidfile $SMARTDPID; then
			echo "."
		else
			echo " (failed)"
			RET=1
		fi
		;;
	status)
		if pidof $SMARTD_BIN >/dev/null; then
			echo "$SMARTD_BIN is running."
		else
			echo "$SMARTD_BIN is not running."
			RET=1
		fi
		;;
	*)
		echo "Usage: $0 {start|stop|restart|force-reload|reload|report|status}"
		exit 1
    esac
    exit $RET

elif [ -f /etc/gentoo-release ] ; then
    report_unsupported "Gentoo"

elif [ -f /etc/turbolinux-release ] ; then
    report_unsupported "Turbolinux"

elif [ -f /etc/environment.corel ] ; then
    report_unsupported "Corel"

# PLEASE ADD OTHER LINUX DISTRIBUTIONS JUST BEFORE THIS LINE, USING elif

elif uname -a | grep SunOS > /dev/null 2>&1 ; then

    # Source configuration file.  This should define the shell variable smartd_opts.
    # Email smartmontools-support mailing list if there is a better choice
    # of path for Solaris

    [ -r /etc/default/smartmontools ] && . /etc/default/smartmontools

    PID_FILE=/var/run/smartd.pid

    case "$1" in
	start)
	    $SMARTD_BIN -p $PID_FILE $smartd_opts
	    echo -n "smartd "
	    ;;
	stop)
	    [ -f $PID_FILE ] && kill `cat $PID_FILE`
	    echo -n "smartd "
	    ;;
	restart)
	    $0 stop
	    sleep 1
	    $0 start
	    ;;
	reload)
	    kill -s HUP `cat $PID_FILE`
	    ;;
	report)
	    kill -s USR1 `cat $PID_FILE`
	    ;;
	*)
	    echo "Usage: $0 {start|stop|restart|reload|report}"
	    exit 1
    esac
    exit 0

# Add other OSes HERE, using elif...
else
    report_unsupported "Unknown"
fi

# One should NEVER arrive here, except for a badly written case above,
# that fails to exit.
echo "SOMETHING IS WRONG WITH THE SMARTD STARTUP SCRIPT"
echo "PLEASE CONTACT smartmontools-support@listi.jpberlin.de"
exit 1
