<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>liblogging: beepframe.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Compound&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Compound&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>beepframe.h File Reference</h1>The BEEP frame object.  
<a href="#_details">More...</a>
<p>
<code>#include "<a class="el" href="beepmessage_8h-source.html">beepmessage.h</a>"</code><br>
<code>#include "<a class="el" href="beepchannel_8h-source.html">beepchannel.h</a>"</code><br>

<p>
<a href="beepframe_8h-source.html">Go to the source code of this file.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Compounds</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsbFramObject.html">sbFramObject</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The BEEP frame object. </em> <a href="structsbFramObject.html#_details">More...</a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a0" doxytag="beepframe.h::__LIB3195_BEEPFRAME_H_INCLUDED__"></a>
#define&nbsp;</td><td class="memItemRight" valign=bottom><b>__LIB3195_BEEPFRAME_H_INCLUDED__</b>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a1" doxytag="beepframe.h::sbFramCHECKVALIDOBJECT"></a>
#define&nbsp;</td><td class="memItemRight" valign=bottom><b>sbFramCHECKVALIDOBJECT</b>(x)&nbsp;&nbsp;&nbsp;{assert(x != NULL); assert(x-&gt;OID == OIDsbFram);}</td></tr>

<tr><td colspan=2><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a2" doxytag="beepframe.h::sbFramState"></a>
typedef enum <a class="el" href="beepframe_8h.html#a49">sbFramState_</a>&nbsp;</td><td class="memItemRight" valign=bottom><b>sbFramState</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a3" doxytag="beepframe.h::sbFramObj"></a>
typedef <a class="el" href="structsbFramObject.html">sbFramObject</a>&nbsp;</td><td class="memItemRight" valign=bottom><b>sbFramObj</b></td></tr>

<tr><td colspan=2><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>enum &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="beepframe_8h.html#a49">sbFramState_</a> { <br>
&nbsp;&nbsp;<a class="el" href="beepframe_8h.html#a49a4">sbFRAMSTATE_WAITING_HDR1</a>, 
<a class="el" href="beepframe_8h.html#a49a5">sbFRAMSTATE_WAITING_HDR2</a>, 
<a class="el" href="beepframe_8h.html#a49a6">sbFRAMSTATE_WAITING_HDR3</a>, 
<a class="el" href="beepframe_8h.html#a49a7">sbFRAMSTATE_WAITING_SP_CHAN</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="beepframe_8h.html#a49a8">sbFRAMSTATE_IN_CHAN</a>, 
<a class="el" href="beepframe_8h.html#a49a9">sbFRAMSTATE_WAITING_SP_MSGNO</a>, 
<a class="el" href="beepframe_8h.html#a49a10">sbFRAMSTATE_IN_MSGNO</a>, 
<a class="el" href="beepframe_8h.html#a49a11">sbFRAMSTATE_WAITING_SP_MORE</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="beepframe_8h.html#a49a12">sbFRAMSTATE_IN_MORE</a>, 
<a class="el" href="beepframe_8h.html#a49a13">sbFRAMSTATE_WAITING_SP_SEQNO</a>, 
<a class="el" href="beepframe_8h.html#a49a14">sbFRAMSTATE_IN_SEQNO</a>, 
<a class="el" href="beepframe_8h.html#a49a15">sbFRAMSTATE_WAITING_SP_SIZE</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="beepframe_8h.html#a49a16">sbFRAMSTATE_IN_SIZE</a>, 
<a class="el" href="beepframe_8h.html#a49a17">sbFRAMSTATE_WAITING_SP_ANSNO</a>, 
<a class="el" href="beepframe_8h.html#a49a18">sbFRAMSTATE_IN_ANSNO</a>, 
<a class="el" href="beepframe_8h.html#a49a19">sbFRAMSTATE_WAITING_SP_ACKNO</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="beepframe_8h.html#a49a20">sbFRAMSTATE_IN_ACKNO</a>, 
<a class="el" href="beepframe_8h.html#a49a21">sbFRAMSTATE_WAITING_SP_WINDOW</a>, 
<a class="el" href="beepframe_8h.html#a49a22">sbFRAMSTATE_IN_WINDOW</a>, 
<a class="el" href="beepframe_8h.html#a49a23">sbFRAMSTATE_WAITING_HDRCR</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="beepframe_8h.html#a49a24">sbFRAMSTATE_WAITING_HDRLF</a>, 
<a class="el" href="beepframe_8h.html#a49a25">sbFRAMSTATE_IN_PAYLOAD</a>, 
<a class="el" href="beepframe_8h.html#a49a26">sbFRAMSTATE_WAITING_END1</a>, 
<a class="el" href="beepframe_8h.html#a49a27">sbFRAMSTATE_WAITING_END2</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="beepframe_8h.html#a49a28">sbFRAMSTATE_WAITING_END3</a>, 
<a class="el" href="beepframe_8h.html#a49a29">sbFRAMSTATE_WAITING_END4</a>, 
<a class="el" href="beepframe_8h.html#a49a30">sbFRAMSTATE_WAITING_END5</a>, 
<a class="el" href="beepframe_8h.html#a49a31">sbFRAMSTATE_RECEIVED</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="beepframe_8h.html#a49a32">sbFRAMSTATE_BEING_BUILD</a>, 
<a class="el" href="beepframe_8h.html#a49a33">sbFRAMSTATE_READY_TO_SEND</a>, 
<a class="el" href="beepframe_8h.html#a49a34">sbFRAMSTATE_SENDING</a>, 
<a class="el" href="beepframe_8h.html#a49a35">sbFRAMSTATE_SENT</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="beepframe_8h.html#a49a36">sbFRAMSTATE_UNKNOWN</a> =  0
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Session status. </em> <a href="#a49">More...</a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a37" doxytag="beepframe.h::sbFramGetFrame"></a>
char *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="beepframe_8h.html#a37">sbFramGetFrame</a> (<a class="el" href="structsbFramObject.html">sbFramObj</a> *pThis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return frame content <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a38" doxytag="beepframe.h::sbFramGetFrameLen"></a>
int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="beepframe_8h.html#a38">sbFramGetFrameLen</a> (<a class="el" href="structsbFramObject.html">sbFramObj</a> *pThis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return length of frame <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a39" doxytag="beepframe.h::sbFramGetHdrID"></a>
BEEPHdrID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="beepframe_8h.html#a39">sbFramGetHdrID</a> (<a class="el" href="structsbFramObject.html">sbFramObj</a> *pThis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the header id of this BEEP frame. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a40" doxytag="beepframe.h::sbFramDestroy"></a>
<a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="beepframe_8h.html#a40">sbFramDestroy</a> (<a class="el" href="structsbFramObject.html">sbFramObj</a> *pThis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">destroy a frame object <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structsbFramObject.html">sbFramObj</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="beepframe_8h.html#a41">sbFramCreateFramFromMesg</a> (<a class="el" href="structsbChanObject.html">sbChanObj</a> *pChan, <a class="el" href="structsbMesgObject.html">sbMesgObj</a> *pMesg, char *pszCmd, <a class="el" href="liblogging_8h.html#a9">SBansno</a> uAnsno)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a frame from a Message. </em> <a href="#a41"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structsbFramObject.html">sbFramObj</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="beepframe_8h.html#a42">sbFramActualRecvFram</a> (<a class="el" href="structsbSessObject.html">sbSessObj</a> *pSess)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Actually receive a frame off the tcp stream. </em> <a href="#a42"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structsbFramObject.html">sbFramObj</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="beepframe_8h.html#a43">sbFramRecvFram</a> (<a class="el" href="structsbChanObject.html">sbChanObj</a> *pChan)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Logically receive a frame. </em> <a href="#a43"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="beepframe_8h.html#a44">sbFramSendFram</a> (<a class="el" href="structsbFramObject.html">sbFramObj</a> *pThis, <a class="el" href="structsbChanObject.html">sbChanObj</a> *pChan)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send a frame on a channel (logical). </em> <a href="#a44"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>BEEPHdrID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="beepframe_8h.html#a45">sbFramHdrID</a> (char *szCmd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the header ID for a given BEEP command header. </em> <a href="#a45"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="beepframe_8h.html#a46">sbFramConstruct</a> (<a class="el" href="structsbFramObject.html">sbFramObj</a> **ppThis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a frame. </em> <a href="#a46"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="beepframe_8h.html#a47">sbFramCreateSEQFram</a> (<a class="el" href="structsbFramObject.html">sbFramObj</a> **ppThis, <a class="el" href="structsbChanObject.html">sbChanObj</a> *pChan, <a class="el" href="liblogging_8h.html#a12">SBackno</a> uAckno, <a class="el" href="liblogging_8h.html#a13">SBwindow</a> uWindow)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a SEQ frame for a given channel with a given ackno. </em> <a href="#a47"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="beepframe_8h.html#a48">sbFramSetOnDestroyEvent</a> (<a class="el" href="structsbFramObject.html">sbFramObj</a> *pThis, void(*OnFramDestroy)(struct <a class="el" href="structsbFramObject.html">sbFramObject</a> *), void *pUsr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register a callback handler to be called when the frame is sent and ready to be destroyed. </em> <a href="#a48"></a><em><br><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The BEEP frame object. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>There are frames not belonging to messages! Curently, this is the case for SEQ frames defined in RFC 3081.</dd></dl>
<dl compact><dt><b>Author:</b></dt><dd>Rainer Gerhards &lt;<a href="mailto:rgerhards@adiscon.com">rgerhards@adiscon.com</a>&gt; </dd></dl>
<dl compact><dt><b>Date:</b></dt><dd>2003-08-04</dd></dl>
Copyright 2002-2003 Rainer Gerhards and Adiscon GmbH. All Rights Reserved.<p>
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:<p>
* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.<p>
* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.<p>
* Neither the name of Adiscon GmbH or Rainer Gerhards nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.<p>
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<hr><h2>Enumeration Type Documentation</h2>
<a name="a49" doxytag="beepframe.h::sbFramState_"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> enum <a class="el" href="beepframe_8h.html#a49">sbFramState_</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Session status. 
<p>
<dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a name="a49a4" doxytag="sbFRAMSTATE_WAITING_HDR1"></a><em>sbFRAMSTATE_WAITING_HDR1</em></em>&nbsp;</td><td>
waiting for the first HDR character </td></tr>
<tr><td valign=top><em><a name="a49a5" doxytag="sbFRAMSTATE_WAITING_HDR2"></a><em>sbFRAMSTATE_WAITING_HDR2</em></em>&nbsp;</td><td>
waiting for the second HDR character </td></tr>
<tr><td valign=top><em><a name="a49a6" doxytag="sbFRAMSTATE_WAITING_HDR3"></a><em>sbFRAMSTATE_WAITING_HDR3</em></em>&nbsp;</td><td>
waiting for the third HDR character </td></tr>
<tr><td valign=top><em><a name="a49a7" doxytag="sbFRAMSTATE_WAITING_SP_CHAN"></a><em>sbFRAMSTATE_WAITING_SP_CHAN</em></em>&nbsp;</td><td>
waiting for the SP before channo </td></tr>
<tr><td valign=top><em><a name="a49a8" doxytag="sbFRAMSTATE_IN_CHAN"></a><em>sbFRAMSTATE_IN_CHAN</em></em>&nbsp;</td><td>
reading channo </td></tr>
<tr><td valign=top><em><a name="a49a9" doxytag="sbFRAMSTATE_WAITING_SP_MSGNO"></a><em>sbFRAMSTATE_WAITING_SP_MSGNO</em></em>&nbsp;</td><td>
now the space before the next header </td></tr>
<tr><td valign=top><em><a name="a49a10" doxytag="sbFRAMSTATE_IN_MSGNO"></a><em>sbFRAMSTATE_IN_MSGNO</em></em>&nbsp;</td><td>
and the next (numeric) header </td></tr>
<tr><td valign=top><em><a name="a49a11" doxytag="sbFRAMSTATE_WAITING_SP_MORE"></a><em>sbFRAMSTATE_WAITING_SP_MORE</em></em>&nbsp;</td><td>
now the space before the next header </td></tr>
<tr><td valign=top><em><a name="a49a12" doxytag="sbFRAMSTATE_IN_MORE"></a><em>sbFRAMSTATE_IN_MORE</em></em>&nbsp;</td><td>
and the next (char) header </td></tr>
<tr><td valign=top><em><a name="a49a13" doxytag="sbFRAMSTATE_WAITING_SP_SEQNO"></a><em>sbFRAMSTATE_WAITING_SP_SEQNO</em></em>&nbsp;</td><td>
now the space before the next header </td></tr>
<tr><td valign=top><em><a name="a49a14" doxytag="sbFRAMSTATE_IN_SEQNO"></a><em>sbFRAMSTATE_IN_SEQNO</em></em>&nbsp;</td><td>
and the next (numeric) header </td></tr>
<tr><td valign=top><em><a name="a49a15" doxytag="sbFRAMSTATE_WAITING_SP_SIZE"></a><em>sbFRAMSTATE_WAITING_SP_SIZE</em></em>&nbsp;</td><td>
now the space before the next header </td></tr>
<tr><td valign=top><em><a name="a49a16" doxytag="sbFRAMSTATE_IN_SIZE"></a><em>sbFRAMSTATE_IN_SIZE</em></em>&nbsp;</td><td>
and the next (numeric) header </td></tr>
<tr><td valign=top><em><a name="a49a17" doxytag="sbFRAMSTATE_WAITING_SP_ANSNO"></a><em>sbFRAMSTATE_WAITING_SP_ANSNO</em></em>&nbsp;</td><td>
now the space before the next header </td></tr>
<tr><td valign=top><em><a name="a49a18" doxytag="sbFRAMSTATE_IN_ANSNO"></a><em>sbFRAMSTATE_IN_ANSNO</em></em>&nbsp;</td><td>
and the next (numeric) header </td></tr>
<tr><td valign=top><em><a name="a49a19" doxytag="sbFRAMSTATE_WAITING_SP_ACKNO"></a><em>sbFRAMSTATE_WAITING_SP_ACKNO</em></em>&nbsp;</td><td>
now the space before the next header </td></tr>
<tr><td valign=top><em><a name="a49a20" doxytag="sbFRAMSTATE_IN_ACKNO"></a><em>sbFRAMSTATE_IN_ACKNO</em></em>&nbsp;</td><td>
and the next (char) header </td></tr>
<tr><td valign=top><em><a name="a49a21" doxytag="sbFRAMSTATE_WAITING_SP_WINDOW"></a><em>sbFRAMSTATE_WAITING_SP_WINDOW</em></em>&nbsp;</td><td>
now the space before the next header </td></tr>
<tr><td valign=top><em><a name="a49a22" doxytag="sbFRAMSTATE_IN_WINDOW"></a><em>sbFRAMSTATE_IN_WINDOW</em></em>&nbsp;</td><td>
and the next (numeric) header </td></tr>
<tr><td valign=top><em><a name="a49a23" doxytag="sbFRAMSTATE_WAITING_HDRCR"></a><em>sbFRAMSTATE_WAITING_HDRCR</em></em>&nbsp;</td><td>
awaiting the HDR's CR </td></tr>
<tr><td valign=top><em><a name="a49a24" doxytag="sbFRAMSTATE_WAITING_HDRLF"></a><em>sbFRAMSTATE_WAITING_HDRLF</em></em>&nbsp;</td><td>
awaiting the HDR's LF </td></tr>
<tr><td valign=top><em><a name="a49a25" doxytag="sbFRAMSTATE_IN_PAYLOAD"></a><em>sbFRAMSTATE_IN_PAYLOAD</em></em>&nbsp;</td><td>
reading payload area </td></tr>
<tr><td valign=top><em><a name="a49a26" doxytag="sbFRAMSTATE_WAITING_END1"></a><em>sbFRAMSTATE_WAITING_END1</em></em>&nbsp;</td><td>
waiting for the 1st HDR character </td></tr>
<tr><td valign=top><em><a name="a49a27" doxytag="sbFRAMSTATE_WAITING_END2"></a><em>sbFRAMSTATE_WAITING_END2</em></em>&nbsp;</td><td>
waiting for the 2nd HDR character </td></tr>
<tr><td valign=top><em><a name="a49a28" doxytag="sbFRAMSTATE_WAITING_END3"></a><em>sbFRAMSTATE_WAITING_END3</em></em>&nbsp;</td><td>
waiting for the 3rd HDR character </td></tr>
<tr><td valign=top><em><a name="a49a29" doxytag="sbFRAMSTATE_WAITING_END4"></a><em>sbFRAMSTATE_WAITING_END4</em></em>&nbsp;</td><td>
waiting for the 4th HDR character </td></tr>
<tr><td valign=top><em><a name="a49a30" doxytag="sbFRAMSTATE_WAITING_END5"></a><em>sbFRAMSTATE_WAITING_END5</em></em>&nbsp;</td><td>
waiting for the 5th HDR character </td></tr>
<tr><td valign=top><em><a name="a49a31" doxytag="sbFRAMSTATE_RECEIVED"></a><em>sbFRAMSTATE_RECEIVED</em></em>&nbsp;</td><td>
frame is fully received and ready for processing </td></tr>
<tr><td valign=top><em><a name="a49a32" doxytag="sbFRAMSTATE_BEING_BUILD"></a><em>sbFRAMSTATE_BEING_BUILD</em></em>&nbsp;</td><td>
frame is currently being constructed </td></tr>
<tr><td valign=top><em><a name="a49a33" doxytag="sbFRAMSTATE_READY_TO_SEND"></a><em>sbFRAMSTATE_READY_TO_SEND</em></em>&nbsp;</td><td>
frame is constructed and ready to send </td></tr>
<tr><td valign=top><em><a name="a49a34" doxytag="sbFRAMSTATE_SENDING"></a><em>sbFRAMSTATE_SENDING</em></em>&nbsp;</td><td>
frame is currently being send </td></tr>
<tr><td valign=top><em><a name="a49a35" doxytag="sbFRAMSTATE_SENT"></a><em>sbFRAMSTATE_SENT</em></em>&nbsp;</td><td>
frame has been send and can be discarded </td></tr>
<tr><td valign=top><em><a name="a49a36" doxytag="sbFRAMSTATE_UNKNOWN"></a><em>sbFRAMSTATE_UNKNOWN</em></em>&nbsp;</td><td>
should never happen 
<p>
Set after initialization. </td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a name="a42" doxytag="beepframe.h::sbFramActualRecvFram"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structsbFramObject.html">sbFramObj</a>* sbFramActualRecvFram </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsbSessObject.html">sbSessObj</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>pSess</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Actually receive a frame off the tcp stream. 
<p>
Be sure to read <a class="el" href="architecture_8c.html">architecture::c</a> for a full explanation of what ActualRecvFram and its associated methods do in an overall context.<p>
In detail, it receives a frame off the wire and returns the resulting farme object to its caller. It detects different frame formats (like SEQ frames).<p>
This is a BLOCKING method call. It blocks until the frame is complete or a timeout occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pSess</em>&nbsp;</td><td>pointer to session object. This session is to be used to receive the frame.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pointer</em>&nbsp;</td><td>to the received frame object or NULL, if an error occured. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a46" doxytag="beepframe.h::sbFramConstruct"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="liblogging_8h.html#a6">srRetVal</a> sbFramConstruct </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsbFramObject.html">sbFramObj</a> **&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>ppThis</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Construct a frame. 
<p>
This builds the memory structure, only but does not do anything to actually populate it.     </td>
  </tr>
</table>
<a name="a41" doxytag="beepframe.h::sbFramCreateFramFromMesg"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structsbFramObject.html">sbFramObj</a>* sbFramCreateFramFromMesg </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsbChanObject.html">sbChanObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pChan</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structsbMesgObject.html">sbMesgObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pMesg</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>pszCmd</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="liblogging_8h.html#a9">SBansno</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>uAnsno</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a frame from a Message. 
<p>
With the current implementation, there is a one-to-one relationship between fram and mesg, so this is faily simple ;)<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pChan</em>&nbsp;</td><td>[in/out] Channel object that this frame will be sent on. Is updated with new SEQ number.</td></tr>
    <tr><td valign=top><em>pMesg</em>&nbsp;</td><td>[in] Pointer to the Mesg to be converted. This buffer must not be modified by Mesg after CreateFramFromMesg has been called!</td></tr>
    <tr><td valign=top><em>pszCmd</em>&nbsp;</td><td>[in] HDR-Command ("ANS", "MSG", ...) to be used.</td></tr>
    <tr><td valign=top><em>uAnso</em>&nbsp;</td><td>[in] if the HDR-Command is "ANS", this is the ansno to be used. Ignored with any other HDR-Command.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>Pointer</em>&nbsp;</td><td>to a newly created Frame object or NULL if an error occured. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a47" doxytag="beepframe.h::sbFramCreateSEQFram"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="liblogging_8h.html#a6">srRetVal</a> sbFramCreateSEQFram </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsbFramObject.html">sbFramObj</a> **&nbsp;</td>
          <td class="mdname" nowrap> <em>ppThis</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structsbChanObject.html">sbChanObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pChan</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="liblogging_8h.html#a12">SBackno</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>uAckno</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="liblogging_8h.html#a13">SBwindow</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>uWindow</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Construct a SEQ frame for a given channel with a given ackno. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pChan</em>&nbsp;</td><td>Channel this SEQ is for. </td></tr>
    <tr><td valign=top><em>uAckno</em>&nbsp;</td><td>ackno to use in the SEQ. Can not be 0. </td></tr>
    <tr><td valign=top><em>uWindow</em>&nbsp;</td><td>Window to use in the SEQ. If 0, use BEEP default. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a45" doxytag="beepframe.h::sbFramHdrID"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BEEPHdrID sbFramHdrID </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>szCmd</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the header ID for a given BEEP command header. 
<p>
This is implemented in the sbFram object as sbFram ultimately creaetes the frames and thus the IDs. One could argue if a better place would be some util helper...<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>psz</em>&nbsp;</td><td>[in] pointer to a BEEP header command ("MSG", ...) </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>matching</em>&nbsp;</td><td>header id </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a43" doxytag="beepframe.h::sbFramRecvFram"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structsbFramObject.html">sbFramObj</a>* sbFramRecvFram </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsbChanObject.html">sbChanObj</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>pChan</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Logically receive a frame. 
<p>
This method uses the session object to do the physical receive. See <a class="el" href="architecture_8c.html">architecture::c</a> for a full description of this interaction.<p>
This is just a slim wrapper to hide the implementation details.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pChan</em>&nbsp;</td><td>[in/out] associated channel </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pointer</em>&nbsp;</td><td>to new frame object or NULL, if in error. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a44" doxytag="beepframe.h::sbFramSendFram"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="liblogging_8h.html#a6">srRetVal</a> sbFramSendFram </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsbFramObject.html">sbFramObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pThis</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structsbChanObject.html">sbChanObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pChan</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Send a frame on a channel (logical). 
<p>
This method does not directly put the data on the wire but calls the session object to initiate this. This sequence allows for limited multiprocessing inside the stack. Please see <a class="el" href="architecture_8c.html">architecture::c</a> for a full description.<p>
This is just a very thin layer in this release.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pChan</em>&nbsp;</td><td>the associated channel (where the frame is to be sent). </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a48" doxytag="beepframe.h::sbFramSetOnDestroyEvent"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="liblogging_8h.html#a6">srRetVal</a> sbFramSetOnDestroyEvent </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsbFramObject.html">sbFramObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pThis</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void(*&nbsp;</td>
          <td class="mdname" nowrap> <em>OnFramDestroy</em>)(struct <a class="el" href="structsbFramObject.html">sbFramObject</a> *), </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>pUsr</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Register a callback handler to be called when the frame is sent and ready to be destroyed. 
<p>
If there was already a handler set, it is REPLACED with the new one. There is no "calling-queue" of multiple handlers.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>OnFramDestroy</em>&nbsp;</td><td>Pointer to Callback. Must not be NULL. </td></tr>
    <tr><td valign=top><em>Pointer</em>&nbsp;</td><td>to user pointer (may be NULL) </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Mon Oct 3 12:29:55 2005 for liblogging by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.2 </small></address>
</body>
</html>
