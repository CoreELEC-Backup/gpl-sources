/*
 * Copyright (C) 2009-2010 Paul Bender.
 *
 * This file is part of eventlircd.
 *
 * eventlircd is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * eventlircd is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with eventlircd.  If not, see <http://www.gnu.org/licenses/>.
 */

/*
 * Single Unix Specification Version 3 headers.
 */
#include <errno.h>        /* C89 */
#include <fcntl.h>        /* POSIX */
#include <stdbool.h>      /* C99 */
#include <stddef.h>       /* C89 */
#include <stdio.h>        /* C89 */
#include <stdint.h>       /* POSIX */
#include <stdlib.h>       /* C89 */
#include <string.h>       /* C89 */
#include <sys/time.h>     /* POSIX */
#include <syslog.h>       /* XSI */
#include <unistd.h>       /* POSIX */
/*
 * Linux headers.
 */
#include <linux/input.h>  /* */
#include <linux/limits.h> /* */
#include <linux/types.h>  /* */
#include <linux/uinput.h> /* */
/*
 * libudev headers.
 */
#include <libudev.h>
/*
 * eventlircd headers (autogenerated).
 */
#include "event_name_to_code.h"
#include "evkey_code_to_name.h"
#include "evkey_type.h"
/*
 * eventlircd headers.
 */
#include "input.h"
#include "lircd.h"
#include "monitor.h"

/*
 * The lircd_handler does not use the id parameter, so we need to let gcc's
 * -Wused know that it is ok.
 */
#ifdef UNUSED
# error cannot define UNUSED because it is already defined
#endif
#if defined(__GNUC__)
# define UNUSED(x) x __attribute__((unused))
#else
# define UNUSED(x) x
#endif

#define DEVICE_NAME    "eventlircd"
#define DEVICE_BUSTYPE 0
#define DEVICE_VENDOR  0
#define DEVICE_PRODUCT 0
#define DEVICE_VERSION 0

#define EVENTLIRCD_EVMAP_LOCK_OFFSET (28)
#define EVENTLIRCD_EVMAP_LOCK_MASK   ((0x7U     ) << EVENTLIRCD_EVMAP_LOCK_OFFSET)
#define EVENTLIRCD_EVMAP_LOCK_CAPS   ((0x1U << 2) << EVENTLIRCD_EVMAP_LOCK_OFFSET)
#define EVENTLIRCD_EVMAP_LOCK_NUM    ((0x1U << 1) << EVENTLIRCD_EVMAP_LOCK_OFFSET)
#define EVENTLIRCD_EVMAP_LOCK_SCROLL ((0x1U << 0) << EVENTLIRCD_EVMAP_LOCK_OFFSET)
#define EVENTLIRCD_EVMAP_MOD_OFFSET  (24)
#define EVENTLIRCD_EVMAP_MOD_MASK    ((0xfU     ) << EVENTLIRCD_EVMAP_MOD_OFFSET)
#define EVENTLIRCD_EVMAP_MOD_CTRL    ((0x1U << 3) << EVENTLIRCD_EVMAP_MOD_OFFSET)
#define EVENTLIRCD_EVMAP_MOD_SHIFT   ((0x1U << 2) << EVENTLIRCD_EVMAP_MOD_OFFSET)
#define EVENTLIRCD_EVMAP_MOD_ALT     ((0x1U << 1) << EVENTLIRCD_EVMAP_MOD_OFFSET)
#define EVENTLIRCD_EVMAP_MOD_META    ((0x1U << 0) << EVENTLIRCD_EVMAP_MOD_OFFSET)
#define EVENTLIRCD_EVMAP_TYPE_OFFSET (16)
#define EVENTLIRCD_EVMAP_TYPE_MASK   ((0xffU    ) << EVENTLIRCD_EVMAP_TYPE_OFFSET)
#define EVENTLIRCD_EVMAP_CODE_OFFSET (0)
#define EVENTLIRCD_EVMAP_CODE_MASK   ((0xffffU  ) << EVENTLIRCD_EVMAP_CODE_OFFSET)

#if EV_MAX >= 65534
# error cannot define EVENTLIRCD_EV_NULL because EV_MAX exceeds 65534
#endif
#define EVENTLIRCD_EV_NULL 65535

#if KEY_MAX >= 65534U
# error cannot define EVENTLIRCD_EVMAP_NULL because KEY_MAX exceeds 65534
#endif
#define EVENTLIRCD_EVMAP_NULL 65535U

/*
 * Macros for reading ioctl bit fields.
 */
#define BITFIELD_BITS_PER_LONG      (sizeof(long) * 8)
#define BITFIELD_LONGS_PER_ARRAY(x) ((((x) - 1) / BITFIELD_BITS_PER_LONG) + 1)
#define BITFIELD_TEST(bit, array)   ((array[((bit) / BITFIELD_BITS_PER_LONG)] >> ((bit) % BITFIELD_BITS_PER_LONG)) & 0x1)

/*
 * The 'input_device_event' structure is used by the 'current' and
 * 'previous_list' members of the 'input_device' structure. It is used to hold
 * information associated with the current event (when used by the
 * 'input_device' structure's 'current' member) and the previous key press
 * events (when used by the 'input_device' structure's 'previous_list' member).
 * The current event is needed so that it can be forwared to either the lircd
 * socket or the mouse/joystick event output device. The previous key press
 * events are needed so that current input key repeat and release events can be
 * mapped to the same output key event used by the corresponding key press
 * event.
 */
struct input_device_event {
	struct input_event event_in;        /* The input event. */
	struct input_event event_out;       /* The output event corresponding to the input event. */
	unsigned int repeat_count;          /* The number of times the output key event has been repeated. */
	struct input_device_event *next;    /* Pointer to the next input device event. */
};

/*
 * The 'input_device_evmap' structure is used by the 'evmap' member of the
 * 'input_device' structure. It is used to hold information associated with
 * each mapping of an input keyboard shortcut key sequence code (zero or more
 * lock or modifier keys) followed by a base (non-lock and non-modifier) key
 * converted to a code) to an output key code.
 */
struct input_device_evmap {
	uint32_t code_in;                   /* The event map's input shortcut key sequence code. */
	__u16 code_out;                     /* The event map's output code. */
};

/*
 * The 'input_device' structure is used by the 'device_list' member of the
 * 'eventlircd_input' variable. It is used to hold information associated with
 * each input device handled by eventlircd. In addition to holding the evmap,
 * current event and previous key press events information for the input device,
 * it holds the information associated with the input device's mouse/joystick
 * event output device.
 */
struct input_device {
	int fd;                             /* The input device's file descriptor. */
	char *path;                         /* The input device's path in the device file system. */
	struct input_device_evmap *evmap;   /* The input device's event map table. */
	size_t evmap_size;                  /* The input device's event map table size. */
	bool repeat_filter;                 /* The input device's repeat filter flag. */
	uint32_t lock_state;                /* The input device's current lock key state. */
	uint32_t modifier_state;            /* The input device's current modifier key state. */
	struct input_device_event current;  /* The input device's current event. */
	struct input_device_event *previous_list;        /* The input device's previous key events. */
	struct {
		bool capslock;
		bool numlock;
		bool scrolllock;
	} led;
	char *remote;                       /* The remote control name used in lircd socket output. */
	struct {                            /* The input device's mouse/joystick event output device. */
		int fd;                     /* The output device's file descriptor. */
		struct uinput_user_dev dev; /* The output device. */
		bool syn_report;            /* The output device has a pending synchronization report event. */
	} output;
	struct input_device *next;          /* Pointer to the next input device in the linked list. */
};

/*
 * The 'lirudevd_input' variable holds information associated with input event
 * devices handled by eventlircd. It contains the information with associated
 * with monitoring udev for input event devices and a list of the input devices
 * currently being handled by eventlircd. The udev monitor file descriptor and
 * each of the the input device file descriptors are registered with monitor
 * so that input is notified of any udev and input device events that eventlircd
 * might need to handle.
 */
struct {
	char *evmap_dir;                    /* The name of the directory containing event map files. */
	bool repeat_filter;                 /* The flag indicating whether or not repeat filtering is enabled. */
	struct {
		int fd;
		struct udev_monitor *monitor;
	} udev;
	struct input_device *device_list;   /* The linked list of udev detected input devices. */
} eventlircd_input = {
	.evmap_dir = NULL,
	.repeat_filter = false,
	.udev = {
		.fd = -1,
		.monitor = NULL
	},
	.device_list = NULL
};

static struct input_device_event *input_device_previous_get(struct input_device *device)
{
	struct input_device_event *previous;

	if (device == NULL) {
		errno = EINVAL;
		return NULL;
	}
	for (previous = device->previous_list
		; (previous != NULL) &&
		  ((previous->event_in.type != device->current.event_in.type) ||
		   (previous->event_in.code != device->current.event_in.code))
		; previous = previous->next);

	return previous;
}

static int input_device_previous_pop(struct input_device *device)
{
	struct input_device_event **previous_ptr;
	struct input_device_event *previous;

	if (device == NULL) {
		errno = EINVAL;
		return -1;
	}

	previous_ptr = &(device->previous_list);
	while (*previous_ptr != NULL) {
		previous = *previous_ptr;
		if ((previous->event_in.type == device->current.event_in.type) &&
		    (previous->event_in.code == device->current.event_in.code)) {
			*previous_ptr = previous->next;
			free(previous);
		} else {
			previous_ptr = &((*previous_ptr)->next);
		}
	}

	return 0;
}

static int input_device_previous_push(struct input_device *device)
{
	struct input_device_event *previous;

	if (device == NULL) {
		errno = EINVAL;
		return -1;
	}

	/*
	 * Pop any events with the same type,code pair off the list. This would only
	 * occur were a previous key release event associated with this key lost.
	 * However, without this, the loss of key release events would cause the
	 * growth in the number of elements in 'previous_list' to be unbounded.
	 */
	input_device_previous_pop(device);

	if ((previous = (struct input_device_event *)malloc(sizeof(struct input_device_event))) == NULL) {
		syslog(LOG_ERR,
		       "failed to allocate memory for previous input device event: %s\n",
		       strerror(errno));
		return -1;
	}

	*previous = device->current;

	previous->next = device->previous_list;
	device->previous_list = previous;

	return 0;
}

static int input_device_send(struct input_device *device, const struct input_event *event)
{
	if (device == NULL) {
		errno = EINVAL;
		return -1;
	}
	if (event == NULL) {
		errno = EINVAL;
		return -1;
	}

	if  ((event->type  == EV_SYN) && (event->code  == SYN_REPORT) && (event->value == 0)) {
		if (device->output.syn_report == true) {
			if (write(device->output.fd, event, sizeof(*event)) != sizeof(*event)) {
				syslog(LOG_ERR,
				       "failed to flush event for %s: %s\n",
				       device->output.dev.name,
				       strerror(errno));
				return -1;
			}
			device->output.syn_report = false;
		}
	} else {
		if (write(device->output.fd, event, sizeof(*event)) != sizeof(*event)) {
			syslog(LOG_ERR,
			       "failed to send event (%u %u %d) for %s: %s\n",
			       (unsigned int)event->type,
			       (unsigned int)event->code,
			       (int)event->value,
			       device->output.dev.name,
			       strerror(errno));
			return -1;
		}
		device->output.syn_report = true;
	}

	return 0;
}

static int input_device_evmap_compare(const void *evmap_a, const void *evmap_b)
{
	__s32 code_a = (__s32)(((const struct input_device_evmap *)evmap_a)->code_in);
	__s32 code_b = (__s32)(((const struct input_device_evmap *)evmap_b)->code_in);

	return (code_a - code_b);
}

static int input_device_evmap_exit(struct input_device *device)
{
	if (device == NULL) {
		errno = EINVAL;
		return -1;
	}

	device->evmap_size = 0;

	if (device->evmap == NULL) {
		return 0;
	}

	free(device->evmap);
	device->evmap = NULL;

	return 0;
}

static int input_device_evmap_init(struct input_device *device, const char *evmap_dir, const char *evmap_file)
{
	char evmap_path[PATH_MAX + 1];
	FILE *fp;
	char *line;
	size_t line_len;
	unsigned int line_number;
	size_t evmap_index;
	char *comment;
	char name_in[128];
	char name_out[128];
	char *name_in_part;
	char *name_in_part_state;
	bool evmap_valid;
	size_t i;

	if (device == NULL) {
		errno = EINVAL;
		return -1;
	}

	device->evmap = NULL;
	device->evmap_size = 0;

	if (evmap_dir == NULL) {
		errno = EINVAL;
		return -1;
	}

	if (evmap_file == NULL) {
		return 0;
	}

	if (strnlen(evmap_dir, PATH_MAX + 1) == PATH_MAX + 1) {
		errno = ENAMETOOLONG;
		syslog(LOG_ERR,
		       "event map file directory '%s': %s\n",
		       evmap_path,
		       strerror(errno));
		return -1;
	}
	if (strnlen(evmap_file, PATH_MAX + 1) == PATH_MAX + 1) {
		errno = ENAMETOOLONG;
		syslog(LOG_ERR,
		       "event map file name '%s': %s\n",
		       evmap_file,
		       strerror(errno));
		return -1;
	}

	if (strchr(evmap_file, '/')) {
		syslog(LOG_ERR,
		       "event map file name '%s' contains a directory\n",
		       evmap_file);
		return -1;
	}

	if (evmap_dir[strlen(evmap_dir) - 1] == '/') {
		if (snprintf(evmap_path, PATH_MAX + 1, "%s%s", evmap_dir, evmap_file) > PATH_MAX) {
			errno = ENAMETOOLONG;
			syslog(LOG_ERR,
			       "event map file path name '%s%s': %s\n",
			       evmap_dir,
			       evmap_file,
			       strerror(errno));
			return -1;
		}
	} else {
		if (snprintf(evmap_path, PATH_MAX + 1, "%s/%s", evmap_dir, evmap_file) > PATH_MAX) {
			errno = ENAMETOOLONG;
			syslog(LOG_ERR,
			       "event map file path name '%s/%s': %s\n",
			       evmap_dir,
			       evmap_file,
			       strerror(errno));
			return -1;
		}
	}

	if ((fp = fopen(evmap_path, "r")) == NULL) {
		syslog(LOG_ERR,
		       "failed to open event map file '%s': %s\n",
		       evmap_path,
		       strerror(errno));
		return -1;
	}

	line_len = 0;

	evmap_index = 0;
	for (evmap_index = 0 ; getline(&line, &line_len, fp) >= 0 ; evmap_index++);
	device->evmap_size = evmap_index;
	if (device->evmap_size == 0) {
		return 0;
	}
	/*
	 * Allocate memory for the event map table.
	 */
	if ((device->evmap = (struct input_device_evmap *)malloc(device->evmap_size * sizeof(struct input_device_evmap))) == NULL) {
		syslog(LOG_ERR,
		       "failed to allocate memory for the input device map %s: %s\n",
		       evmap_path,
		       strerror(errno));
		device->evmap_size = 0;
		return -1;
	}

	rewind(fp);

	line_number = 0;
	evmap_index = 0;
	while ((evmap_index < device->evmap_size) && (getline(&line, &line_len, fp) >= 0)) {
		device->evmap[evmap_index].code_in  = 0;
		device->evmap[evmap_index].code_out = 0;

		line_number++;

		/*
		 * End the line at the first comment character.
		 */
		comment = strchr(line, '#');
		if (comment != NULL) {
			*comment = '\0';
		}
		/*
		 * Skip blank (whitespace only) lines.
		 */
		if (sscanf(line, " %127s", name_in) != 1) {
			continue;
		}
		/*
		 * Split event map line into input keyboard shortcut and output key name.
		 */
		if (sscanf(line, " %127[a-zA-Z0-9_+] = %127[a-zA-Z0-9_] ", name_in, name_out) != 2) {
			syslog(LOG_WARNING,
			       "%s:%u: format is not <name-in> = <name-out>\n",
			       evmap_path,
			       line_number);
			continue;
		}
		name_in[127]  = '\0';
		name_out[127] = '\0';
		if (strlen(name_in) < 1) {
			syslog(LOG_WARNING,
			       "%s:%u:<name-in>: name is empty",
			       evmap_path,
			       line_number);
			continue;
		}
		if (strlen(name_out) < 1) {
			syslog(LOG_WARNING,
			       "%s:%u:<name-out>: name is empty",
			       evmap_path,
			       line_number);
			continue;
		}
		/*
		 * parse input keyboard shortcut, validate lock key tockens, modifer
		 * key tokens and base key name, and determine corresponding input code.
		 * While the the tokens and names need not be treated as case sesitive,
		 * they are treated as case sesitive in order to force a more consistant
		 * file format.
		 */
		name_in_part = strtok_r(name_in, "+", &name_in_part_state);
		if (name_in_part == NULL) {
			syslog(LOG_WARNING,
			       "%s:%u:<name-in>: keyboard shortcut could not be parsed\n",
			       evmap_path,
			       line_number);
			continue;
		}
		evmap_valid = true;
		while (name_in_part) {
			if (strcmp(name_in_part, "capslock") == 0) {
				if (device->evmap[evmap_index].code_in & EVENTLIRCD_EVMAP_CODE_MASK) {
					syslog(LOG_WARNING,
					       "%s:%u:<name-in>: the '%s' lock key token appeared after the base key name\n",
					       evmap_path,
					       line_number,
					       name_in_part);
					evmap_valid = false;
					break;
				}
				if (device->evmap[evmap_index].code_in & EVENTLIRCD_EVMAP_LOCK_CAPS) {
					syslog(LOG_WARNING,
					       "%s:%u:<name-in>: the '%s' lock key token appeared more than once\n",
					       evmap_path,
					       line_number,
					       name_in_part);
					evmap_valid = false;
					break;
				}
				device->evmap[evmap_index].code_in |= EVENTLIRCD_EVMAP_LOCK_CAPS;
			} else if (strcmp(name_in_part, "numlock") == 0) {
				if (device->evmap[evmap_index].code_in & EVENTLIRCD_EVMAP_CODE_MASK)
				{
					syslog(LOG_WARNING,
					       "%s:%u:<name-in>: the '%s' lock key token appeared after the base key name\n",
					       evmap_path,
					       line_number,
					       name_in_part);
					evmap_valid = false;
					break;
				}
				if (device->evmap[evmap_index].code_in & EVENTLIRCD_EVMAP_LOCK_NUM)
				{
					syslog(LOG_WARNING,
					       "%s:%u:<name-in>: the '%s' lock key token appeared more than once\n",
					       evmap_path,
					       line_number,
					       name_in_part);
					evmap_valid = false;
					break;
				}
				device->evmap[evmap_index].code_in |= EVENTLIRCD_EVMAP_LOCK_NUM;
			} else if (strcmp(name_in_part, "scrolllock") == 0) {
				if (device->evmap[evmap_index].code_in & EVENTLIRCD_EVMAP_CODE_MASK) {
					syslog(LOG_WARNING,
					       "%s:%u:<name-in>: the '%s' lock key token appeared after the base key name\n",
					       evmap_path,
					       line_number,
					       name_in_part);
					evmap_valid = false;
					break;
				}
				if (device->evmap[evmap_index].code_in & EVENTLIRCD_EVMAP_LOCK_SCROLL) {
					syslog(LOG_WARNING,
					       "%s:%u:<name-in>: the '%s' lock key token appeared more than once\n",
					       evmap_path,
					       line_number,
					       name_in_part);
					evmap_valid = false;
					break;
				}
				device->evmap[evmap_index].code_in |= EVENTLIRCD_EVMAP_LOCK_SCROLL;
			} else if (strcmp(name_in_part, "ctrl") == 0) {
				if (device->evmap[evmap_index].code_in & EVENTLIRCD_EVMAP_CODE_MASK) {
					syslog(LOG_WARNING,
					       "%s:%u:<name-in>: the '%s' modifier key token appeared after the base key name\n",
					       evmap_path,
					       line_number,
					       name_in_part);
					evmap_valid = false;
					break;
				}
				if (device->evmap[evmap_index].code_in & EVENTLIRCD_EVMAP_MOD_CTRL) {
					syslog(LOG_WARNING,
					       "%s:%u:<name-in>: the '%s' modifier key token appeared more than once\n",
					       evmap_path,
					       line_number,
					       name_in_part);
					evmap_valid = false;
					break;
				}
				device->evmap[evmap_index].code_in |= EVENTLIRCD_EVMAP_MOD_CTRL;
			} else if (strcmp(name_in_part, "shift") == 0) {
				if (device->evmap[evmap_index].code_in & EVENTLIRCD_EVMAP_CODE_MASK) {
					syslog(LOG_WARNING,
					       "%s:%u:<name-in>: the '%s' modifier key token appeared after the base key name\n",
					       evmap_path,
					       line_number,
					       name_in_part);
					evmap_valid = false;
					break;
				}
				if (device->evmap[evmap_index].code_in & EVENTLIRCD_EVMAP_MOD_SHIFT) {
					syslog(LOG_WARNING,
					       "%s:%u:<name-in>: the '%s' modifier key token appeared more than once\n",
					       evmap_path,
					       line_number,
					       name_in_part);
					evmap_valid = false;
					break;
				}
				device->evmap[evmap_index].code_in |= EVENTLIRCD_EVMAP_MOD_SHIFT;
			} else if (strcmp(name_in_part, "alt") == 0) {
				if (device->evmap[evmap_index].code_in & EVENTLIRCD_EVMAP_CODE_MASK) {
					syslog(LOG_WARNING,
					       "%s:%u:<name-in>: the '%s' modifier key token appeared after the base key name\n",
					       evmap_path,
					       line_number,
					       name_in_part);
					evmap_valid = false;
					break;
				}
				if (device->evmap[evmap_index].code_in & EVENTLIRCD_EVMAP_MOD_ALT) {
					syslog(LOG_WARNING,
					       "%s:%u:<name-in>: the '%s' modifier key token appeared more than once\n",
					       evmap_path,
					       line_number,
					       name_in_part);
					evmap_valid = false;
					break;
				}
				device->evmap[evmap_index].code_in |= EVENTLIRCD_EVMAP_MOD_ALT;
			} else if (strcmp(name_in_part, "meta") == 0) {
				if (device->evmap[evmap_index].code_in & EVENTLIRCD_EVMAP_CODE_MASK) {
					syslog(LOG_WARNING,
					       "%s:%u:<name-in>: the '%s' modifier key token appeared after the base key name\n",
					       evmap_path,
					       line_number,
					       name_in_part);
					evmap_valid = false;
					break;
				}
				if (device->evmap[evmap_index].code_in & EVENTLIRCD_EVMAP_MOD_META) {
					syslog(LOG_WARNING,
					       "%s:%u:<name-in>: the '%s' modifier key token appeared more than once\n",
					       evmap_path,
					       line_number,
					       name_in_part);
					evmap_valid = false;
					break;
				}
				device->evmap[evmap_index].code_in |= EVENTLIRCD_EVMAP_MOD_META;
			} else {
				if (device->evmap[evmap_index].code_in & EVENTLIRCD_EVMAP_CODE_MASK) {
					evmap_valid = false;
					break;
				}
				for (i = 0 ; (event_name_to_code[i].name != NULL) && (strcmp(name_in_part, event_name_to_code[i].name) != 0) ; i++);
				if (event_name_to_code[i].name == NULL) {
					syslog(LOG_WARNING,
					       "%s:%u:<name-in>: '%s' is not a known key name\n",
					       evmap_path,
					       line_number,
					       name_in_part);
					evmap_valid = false;
					break;
				}
				if ((strcmp(name_in_part, "KEY_CAPSLOCK"  ) == 0) ||
				    (strcmp(name_in_part, "KEY_NUMLOCK"   ) == 0) ||
				    (strcmp(name_in_part, "KEY_SCROLLLOCK") == 0)) {
					syslog(LOG_WARNING,
					       "%s:%u:<name-in>: '%s' is a key name that is part of the lock key token.\n",
					       evmap_path,
					       line_number,
					       name_in_part);
					evmap_valid = false;
					break;
				}
				if ((strcmp(name_in_part, "KEY_LEFTCTRL"  ) == 0) || (strcmp(name_in_part, "KEY_RIGHTCTRL"  ) == 0) ||
				    (strcmp(name_in_part, "KEY_LEFTSHIFT" ) == 0) || (strcmp(name_in_part, "KEY_RIGHTSHIFT" ) == 0) ||
				    (strcmp(name_in_part, "KEY_LEFTALT"   ) == 0) || (strcmp(name_in_part, "KEY_RIGHTALT"   ) == 0) ||
				    (strcmp(name_in_part, "KEY_LEFTMETA"  ) == 0) || (strcmp(name_in_part, "KEY_RIGHTMETA"  ) == 0)) {
					syslog(LOG_WARNING,
					       "%s:%u:<name-in>: '%s' is a key name that is part of the modifier key token.\n",
					       evmap_path,
					       line_number,
					       name_in_part);
					evmap_valid = false;
					break;
				}
				if ((strncmp(name_in_part, "KEY_", strlen("KEY_")) != 0) &&
				    (strncmp(name_in_part, "BTN_", strlen("BTN_")) != 0)) {
					if (device->evmap[evmap_index].code_in & EVENTLIRCD_EVMAP_LOCK_MASK) {
						syslog(LOG_WARNING,
						       "%s:%u:<name-in>: '%s' lock key applied to non-key event.\n",
						       evmap_path,
						       line_number,
						       name_in_part);
						evmap_valid = false;
					}
					if (device->evmap[evmap_index].code_in & EVENTLIRCD_EVMAP_MOD_MASK) {
						syslog(LOG_WARNING,
						       "%s:%u:<name-in>: '%s' modifier key applied to non-key event.\n",
						       evmap_path,
						       line_number,
						       name_in_part);
						evmap_valid = false;
					}
					if (strcmp(name_out, "NULL") != 0) {
						syslog(LOG_WARNING,
						       "%s:%u:<name-in>: '%s' non-key event mapped to non-null value.\n",
						       evmap_path,
						       line_number,
						       name_in_part);
						evmap_valid = false;
					}
				}
				device->evmap[evmap_index].code_in |= ((uint32_t)(event_name_to_code[i].type)) << EVENTLIRCD_EVMAP_TYPE_OFFSET;
				device->evmap[evmap_index].code_in |= ((uint32_t)(event_name_to_code[i].code)) << EVENTLIRCD_EVMAP_CODE_OFFSET;
			}
			name_in_part = strtok_r(NULL, "+", &name_in_part_state);
		}
		if (evmap_valid == false) {
			continue;
		}
		if ((device->evmap[evmap_index].code_in & EVENTLIRCD_EVMAP_CODE_MASK) == 0) {
			syslog(LOG_WARNING,
			       "%s:%u:<name-in>: no key in keyboard shortcut.\n",
			       evmap_path,
			       line_number);
			evmap_valid = false;
			continue;
		}
		for (i = 0 ; i < evmap_index ; i++) {
			if (device->evmap[evmap_index].code_in == device->evmap[i].code_in) {
				syslog(LOG_WARNING,
				       "%s:%u:<name-in>: duplicate keyboard shortcut.\n",
				       evmap_path,
				       line_number);
				evmap_valid = false;
				break;
			}
		}
		if (evmap_valid == false) {
			continue;
		}
		if (strcmp(name_out, "NULL") == 0) {
			device->evmap[evmap_index].code_out = EVENTLIRCD_EVMAP_NULL;
		}
		else {
			if ((strncmp(name_out, "KEY_", strlen("KEY_")) != 0) &&
			    (strncmp(name_out, "BTN_", strlen("BTN_")) != 0)) {
				syslog(LOG_WARNING,
				       "%s:%u:<name-out>: '%s' is not a valid key name\n",
				       evmap_path,
				       line_number,
				       name_out);
				evmap_valid = false;
				continue;
			}
			for (i = 0 ; (event_name_to_code[i].name != NULL) && (strcmp(name_out, event_name_to_code[i].name) != 0) ; i++);
			if (event_name_to_code[i].name == NULL) {
				syslog(LOG_WARNING,
				       "%s:%u:<name-out>: '%s' is not a valid key name\n",
				       evmap_path,
				       line_number,
				       name_out);
				evmap_valid = false;
				continue;
			}
			device->evmap[evmap_index].code_out = event_name_to_code[i].code;
		}
		evmap_index++;
	}
	device->evmap_size = evmap_index;

	syslog(LOG_DEBUG,
	       "%s: using %u valid keyboard shortcut mappings\n",
	       evmap_path,
	       (unsigned int)device->evmap_size);

	/*
	 * Sort the event map so that later look-ups can be done with a binary search.
	 */
	qsort(device->evmap, device->evmap_size, sizeof(struct input_device_evmap), input_device_evmap_compare);

	free(line);
	fclose(fp);

	return 0;
}

static int input_device_evmap_run(struct input_device *device)
{
	struct input_device_evmap search;
	struct input_device_evmap *result;

	if (device == NULL) {
		errno = EINVAL;
		return -1;
	}

	device->current.event_out = device->current.event_in;

	if (device->evmap == NULL) {
		if (evkey_type[device->current.event_out.code] == EVENTLIRCD_EVKEY_TYPE_NULL) {
			device->current.event_out.code = (__u16)(EVENTLIRCD_EVMAP_NULL);
		}
		return 0;
	}

	search.code_in  = (uint32_t)(device->current.event_out.code);
	search.code_in |= (uint32_t)(device->current.event_out.type << 16);
	/*
	 * Lock and modifier states are applied to keys only.
	 */
	if (device->current.event_out.type == EV_KEY) {
		search.code_in |= device->modifier_state;
		search.code_in |= device->lock_state;
	}
	result = bsearch(&search, device->evmap, device->evmap_size, sizeof(struct input_device_evmap), input_device_evmap_compare);
	if (result == NULL) {
		if (evkey_type[device->current.event_out.code] == EVENTLIRCD_EVKEY_TYPE_NULL) {
			device->current.event_out.type = (__u16)(EVENTLIRCD_EVMAP_NULL);
		}
		return 0;
	}
	device->current.event_out.code = result->code_out;

	return 0;
}

static int input_device_event_update(struct input_device *device, const struct input_event *event)
{
	struct input_device_event *previous;
	long time_delta;

	if (device == NULL) {
		errno = EINVAL;
		return -1;
	}

	if (event == NULL) {
		errno = EINVAL;
		return -1;
	}

	device->current.event_in     = *event;
	device->current.event_out    = device->current.event_in;
	device->current.repeat_count = 0;
	device->current.next         = NULL;

	/*
	 * Map the current event.
	 */
	if (input_device_evmap_run(device) < 0) {
		return -1;
	}
	if (device->current.event_out.code == EVENTLIRCD_EVMAP_NULL) {
		memset(&(device->current.event_out), 0, sizeof(struct input_event));
		device->current.event_out.type = EVENTLIRCD_EV_NULL;
		device->current.repeat_count = 0;
		return 0;
	}

	/*
	 * When the device let's us know that the device's capslock, numlock or
	 * scrolllock state has changed, make sure that our state matches the
	 * device's state.
	 */
	if (device->current.event_in.type == EV_LED) {
		switch (device->current.event_in.code) {
		case LED_CAPSL:
			if (device->current.event_in.value == 0)
				device->lock_state &= ~EVENTLIRCD_EVMAP_LOCK_CAPS;
			else
				device->lock_state |=  EVENTLIRCD_EVMAP_LOCK_CAPS;
			device->current.event_out.type = EVENTLIRCD_EV_NULL;
			device->current.repeat_count = 0;
			return 0;
			break;
		case LED_NUML:
			if (device->current.event_in.value == 0)
				device->lock_state &= ~EVENTLIRCD_EVMAP_LOCK_NUM;
			else
				device->lock_state |=  EVENTLIRCD_EVMAP_LOCK_NUM;
			device->current.event_out.type = EVENTLIRCD_EV_NULL;
			device->current.repeat_count = 0;
			return 0;
			break;
		case LED_SCROLLL:
			if (device->current.event_in.value == 0)
				device->lock_state &= ~EVENTLIRCD_EVMAP_LOCK_SCROLL;
			else
				device->lock_state |=  EVENTLIRCD_EVMAP_LOCK_SCROLL;
			device->current.event_out.type = EVENTLIRCD_EV_NULL;
			device->current.repeat_count = 0;
			return 0;
			break;
		}
	}

	/*
	 * The remaining processing is for key events.
	 */
	if (device->current.event_in.type != EV_KEY) {
		device->current.event_out    = device->current.event_in;
		device->current.repeat_count = 0;
		return 0;
	}

	/*
	 * If it is a lock key code, then update the lock state, null
	 * the current output event (as it has been handled) and return.
	 */
	if (device->current.event_in.code == KEY_CAPSLOCK) {
		if (device->current.event_in.value == 1) {
			/*
			 * Toggle the capslock status.
			 */
			device->lock_state ^= EVENTLIRCD_EVMAP_LOCK_CAPS;
			/*
			 * Update the device's capslock status.
			 */
			if (device->led.capslock == true) {
				struct input_event event = {
					.type  = EV_LED,
					.code  = LED_CAPSL,
					.value = ((device->lock_state & EVENTLIRCD_EVMAP_LOCK_CAPS) == 0) ? 0 : 1
				};
				if (write(device->fd, &event, sizeof(event)) != sizeof(event)) {
					syslog(LOG_WARNING,
					       "failed to update capslock LED state for device %s: %s\n",
					       device->path,
					       strerror(errno));
				}
			}
		}
		device->current.event_out.type = EVENTLIRCD_EV_NULL;
		device->current.repeat_count = 0;
		return 0;
	}
	if (device->current.event_in.code == KEY_NUMLOCK) {
		if (device->current.event_in.value == 1) {
			/*
			 * Toggle the numlock status.
			 */
			device->lock_state ^= EVENTLIRCD_EVMAP_LOCK_NUM;
			/*
			 * Update the device's numlock status.
			 */
			if (device->led.numlock == true) {
				struct input_event event = {
					.type  = EV_LED,
					.code  = LED_NUML,
					.value = ((device->lock_state & EVENTLIRCD_EVMAP_LOCK_NUM) == 0) ? 0 : 1
				};
				if (write(device->fd, &event, sizeof(event)) != sizeof(event)) {
					syslog(LOG_WARNING,
					       "failed to update numlock LED state for device %s: %s\n",
					       device->path,
					       strerror(errno));
				}
			}
		}
		device->current.event_out.type = EVENTLIRCD_EV_NULL;
		device->current.repeat_count = 0;
		return 0;
	}
	if (device->current.event_in.code == KEY_SCROLLLOCK) {
		if (device->current.event_in.value == 1) {
			/*
			 * Toggle the scrolllock status.
			 */
			device->lock_state ^= EVENTLIRCD_EVMAP_LOCK_SCROLL;
			/*
			 * Update the device's scrolllock status.
			 */
			if (device->led.scrolllock == true) {
				struct input_event event = {
					.type  = EV_LED,
					.code  = LED_SCROLLL,
					.value = ((device->lock_state & EVENTLIRCD_EVMAP_LOCK_SCROLL) == 0) ? 0 : 1
				};
				if (write(device->fd, &event, sizeof(event)) != sizeof(event)) {
					syslog(LOG_WARNING,
					       "failed to update scrolllock LED state for device %s: %s\n",
					       device->path,
					       strerror(errno));
				}
			}
		}
		device->current.event_out.type = EVENTLIRCD_EV_NULL;
		device->current.repeat_count = 0;
		return 0;
	}

	/*
	 * If it is a modifier key code, then update the modifier state, null
	 * the current output event (as it has been handled) and return.
	 */
	if ((device->current.event_in.code == KEY_LEFTCTRL ) ||
		(device->current.event_in.code == KEY_RIGHTCTRL)) {
		if (device->current.event_in.value == 0)
			device->modifier_state &= ~EVENTLIRCD_EVMAP_MOD_CTRL;
		else
			device->modifier_state |=  EVENTLIRCD_EVMAP_MOD_CTRL;
		memset(&(device->current.event_out), 0, sizeof(struct input_event));
		device->current.event_out.type = EVENTLIRCD_EV_NULL;
		device->current.repeat_count = 0;
		return 0;
	}
	if ((device->current.event_in.code == KEY_LEFTSHIFT ) ||
		(device->current.event_in.code == KEY_RIGHTSHIFT)) {
		if (device->current.event_in.value == 0)
			device->modifier_state &= ~EVENTLIRCD_EVMAP_MOD_SHIFT;
		else
			device->modifier_state |=  EVENTLIRCD_EVMAP_MOD_SHIFT;
		memset(&(device->current.event_out), 0, sizeof(struct input_event));
		device->current.event_out.type = EVENTLIRCD_EV_NULL;
		device->current.repeat_count = 0;
		return 0;
	}
	if ((device->current.event_in.code == KEY_LEFTALT ) ||
		(device->current.event_in.code == KEY_RIGHTALT)) {
		if (device->current.event_in.value == 0)
			device->modifier_state &= ~EVENTLIRCD_EVMAP_MOD_ALT;
		else
			device->modifier_state |=  EVENTLIRCD_EVMAP_MOD_ALT;
		memset(&(device->current.event_out), 0, sizeof(struct input_event));
		device->current.event_out.type = EVENTLIRCD_EV_NULL;
		device->current.repeat_count = 0;
		return 0;
	}
	if ((device->current.event_in.code == KEY_LEFTMETA ) ||
		(device->current.event_in.code == KEY_RIGHTMETA)) {
		if (device->current.event_in.value == 0)
			device->modifier_state &= ~EVENTLIRCD_EVMAP_MOD_META;
		else
			device->modifier_state |=  EVENTLIRCD_EVMAP_MOD_META;
		memset(&(device->current.event_out), 0, sizeof(struct input_event));
		device->current.event_out.type = EVENTLIRCD_EV_NULL;
		device->current.repeat_count = 0;
		return 0;
	}

	/*
	 * Map the current event.
	 */
	if (input_device_evmap_run(device) < 0) {
		return -1;
	}
	if (device->current.event_out.code == EVENTLIRCD_EVMAP_NULL) {
		memset(&(device->current.event_out), 0, sizeof(struct input_event));
		device->current.event_out.type = EVENTLIRCD_EV_NULL;
		device->current.repeat_count = 0;
		return 0;
	}

	switch (device->current.event_out.value) {
	/*
	 * Process the key press event.
	 */
	case 1:
		device->current.repeat_count = 0;
		/*
		 * As this is a key press event, eventlircd will need later to map
		 * correctly any corresponding key repeat and key release events.
		 * Therefore, we push it onto the previous key press event list.
		 * If we fail, then we discard the event as we will not be able to
		 * map correctly any corresponding key repeat and key release
		 * events.
		 */
		if (input_device_previous_push(device) < 0) {
			memset(&(device->current.event_out), 0, sizeof(struct input_event));
			device->current.event_out.type = EVENTLIRCD_EV_NULL;
			device->current.repeat_count = 0;
			return -1;
		}
		break;
	/*
	 * Process the key repeat event.
	 */
	case 2:
		if ((previous = input_device_previous_get(device)) == NULL) {
			memset(&(device->current.event_out), 0, sizeof(struct input_event));
			device->current.event_out.type = EVENTLIRCD_EV_NULL;
			device->current.repeat_count = 0;
			return 0;
		}
		device->current.event_out.type = previous->event_out.type;
		device->current.event_out.code = previous->event_out.code;
		/*
		 * If the key repeat is too quick, then ignore it. The delay is
		 * longer for the first repeat in order to allow the user to release
		 * the key before repeating starts.
		 */
                if (device->repeat_filter == true)
                {
		     if (evkey_type[device->current.event_out.code] == EVENTLIRCD_EVKEY_TYPE_KEY) {
			     time_delta = 1000000 * (device->current.event_out.time.tv_sec  - previous->event_out.time.tv_sec ) +
			                            (device->current.event_out.time.tv_usec - previous->event_out.time.tv_usec);
			     if (((previous->repeat_count == 0) && (time_delta <  900000)) ||
			         ((previous->repeat_count == 1) && (time_delta <  500000)) ||
			         ((previous->repeat_count == 2) && (time_delta <  300000)) ||
			         ((previous->repeat_count == 3) && (time_delta <  200000)) ||
			         ((previous->repeat_count == 4) && (time_delta <  150000)) ||
			         ((previous->repeat_count >= 5) && (time_delta <  100000))) {
				     memset(&(device->current.event_out), 0, sizeof(struct input_event));
				     device->current.event_out.type = EVENTLIRCD_EV_NULL;
				     device->current.repeat_count = 0;
				     return 0;
			     }
		     }
                }
		previous->repeat_count++;
		previous->event_out.time = device->current.event_out.time;
		device->current.repeat_count = previous->repeat_count;
		break;
	/*
	 * Process the key release event.
	 */
	case 0:
		if ((previous = input_device_previous_get(device)) == NULL) {
			memset(&(device->current.event_out), 0, sizeof(struct input_event));
			device->current.event_out.type = EVENTLIRCD_EV_NULL;
			device->current.repeat_count = 0;
			return 0;
		}
		device->current.event_out.type = previous->event_out.type;
		device->current.event_out.code = previous->event_out.code;

		device->current.repeat_count = 0;
		input_device_previous_pop(device);
		break;
	default:
		memset(&(device->current.event_out), 0, sizeof(struct input_event));
		device->current.event_out.type = EVENTLIRCD_EV_NULL;
		device->current.repeat_count = 0;
		break;
	}

	return 0;
}

static bool input_device_event_is_key(struct input_device *device)
{
	if (device == NULL) {
		errno = EINVAL;
		return false;
	}
	if (device->current.event_out.type != EV_KEY) {
		return false;
	}
	if (device->current.event_out.code > KEY_MAX) {
		return false;
	}
	if (evkey_type[device->current.event_out.code] != EVENTLIRCD_EVKEY_TYPE_KEY) {
		return false;
	}
	return true;
}

static int input_device_handler(void *id)
{
	struct input_device *device;
	struct input_event event;

	if (id == NULL) {
		errno = EINVAL;
		return -1;
	}

	device = (struct input_device *)id;

	if (read(device->fd, &event, sizeof(event)) != sizeof(event)) {
		return 0;
	}

	input_device_event_update(device, &event);
	if (device->current.event_out.type == EVENTLIRCD_EV_NULL) {
		return 0;
	}

	/* 
	 * Send keys to lircd and send all other events to the output device
	 * (assuming it exists).
	 */
	if (input_device_event_is_key(device) == true) {
		if (lircd_send(&device->current.event_out, evkey_code_to_name[device->current.event_out.code], device->current.repeat_count, device->remote) != 0)
		{
			return -1;
		}
	} else if (device->output.fd != -1) {
		if (input_device_send(device, &device->current.event_out) != 0)
		{
			return -1;
		}
	}

	return 0;
}

static int input_device_close(struct input_device *device)
{
	int return_code;

	if (device == NULL) {
		errno = EINVAL;
		return -1;
	}

	return_code = 0;

	if (monitor_client_remove(device->fd) != 0) {
		return_code = -1;
	}

	if (device->output.fd != -1) {
		ioctl(device->output.fd, UI_DEV_DESTROY);
		close(device->output.fd);
		device->output.fd = -1;
		syslog(LOG_INFO,
		       "input device %s: output event device destroyed",
		       device->path);
	}
	if (device->remote == NULL) {
		free(device->remote);
	}
	input_device_evmap_exit(device);
	if (device->fd != -1) {
		close(device->fd);
		device->fd = -1;
		syslog(LOG_INFO,
		       "intput device %s: released",
		       device->path);
	}
	if (device->path != NULL) {
		free(device->path);
		device->path = NULL;
	}

	return return_code;
}

static int input_device_purge()
{
	struct input_device **device_ptr;
	struct input_device *device;
	int return_code;

	return_code = 0;

	device_ptr = &(eventlircd_input.device_list);
	while (*device_ptr != NULL) {
		device = *device_ptr;
		if (device->fd == -1) {
			*device_ptr = device->next;
			if (input_device_close(device) != 0) {
				free(device);
				return_code = -1;
			}
		} else {
			device_ptr = &((*device_ptr)->next);
		}
	}

	return return_code;
}

static int input_device_remove(struct udev_device *udev_device)
{
	const char* path = NULL;
	struct input_device *device;
	int return_code;

	if (udev_device == NULL) {
		errno = EINVAL;
		return -1;
	}

	path = udev_device_get_devnode(udev_device);
	if (path == NULL) {
		return 0;
	}

	return_code = 0;

	for (device = eventlircd_input.device_list ; device != NULL ; device = device->next) {
		if (device->path == NULL) {
			continue;
		}
		if (strncmp(device->path, path, PATH_MAX) == 0) {
			if (input_device_close(device) != 0) {
				return_code = -1;
			}
		}
	}
	if (input_device_purge() != 0) {
		return_code = -1;
	}

	return return_code;
}

static int input_device_add(struct udev_device *udev_device)
{
	const char *uinput_devname[] = {
		"/dev/uinput",
		"/dev/input/uinput",
		"/dev/misc/uinput",
		NULL
	};
	const char* name;
	const char* path;
	const char* enable;
	const char* evmap_file;
	const char* remote;
	struct input_device *device;
	unsigned long bit[BITFIELD_LONGS_PER_ARRAY(EV_MAX)];
	unsigned long bit_key[BITFIELD_LONGS_PER_ARRAY(KEY_MAX)];
	unsigned long bit_rel[BITFIELD_LONGS_PER_ARRAY(REL_MAX)];
	unsigned long bit_abs[BITFIELD_LONGS_PER_ARRAY(ABS_MAX)];
	unsigned long bit_msc[BITFIELD_LONGS_PER_ARRAY(MSC_MAX)];
	unsigned long bit_sw[BITFIELD_LONGS_PER_ARRAY(SW_MAX)];
	unsigned long bit_led[BITFIELD_LONGS_PER_ARRAY(LED_MAX)];
	unsigned long bit_snd[BITFIELD_LONGS_PER_ARRAY(SND_MAX)];
	unsigned long bit_ff[BITFIELD_LONGS_PER_ARRAY(FF_MAX)];
	unsigned long bit_ff_status[BITFIELD_LONGS_PER_ARRAY(FF_STATUS_MAX)];
	__u16 i;
	__u16 j;
	size_t z;
	bool output_active;
	__u16 type;
	__u16 code;
	uint32_t code_in;
	__u16 code_out;

	if (udev_device == NULL) {
		errno = EINVAL;
		return -1;
	}

	name = udev_device_get_property_value(udev_device_get_parent(udev_device), "NAME");
	if ((name != NULL) && (strncmp(name, "\"eventlircd\"", strlen("\"eventlircd\"")) == 0)) {
		return 0;
	}

	path = udev_device_get_devnode(udev_device);
	if (path == NULL) {
		return 0;
	}

	enable = udev_device_get_property_value(udev_device, "eventlircd_enable");
	if ((enable == NULL) ||(strncmp(enable, "true", sizeof("true")) != 0)) {
		return 0;
	}

	evmap_file = udev_device_get_property_value(udev_device, "eventlircd_evmap");

	for (device = eventlircd_input.device_list ; device != NULL ; device = device->next) {
		if (strncmp(device->path, path, PATH_MAX) == 0) {
			return 0;
		}
	}

	remote = udev_device_get_property_value(udev_device, "eventlircd_remote");
	if (remote == NULL) {
		remote = "devinput";
	}

	if ((device = calloc(1, sizeof(struct input_device))) == NULL) {
		syslog(LOG_ERR,
		       "input device %s: memory allocation failed: %s\n",
		       path,
		       strerror(errno));
		return -1;
	}

	device->path = NULL;
	device->fd = -1;
	device->evmap = NULL;
	device->remote = NULL;
	device->output.fd = -1;

	if ((device->path = strndup(path, PATH_MAX)) == NULL) {
		syslog(LOG_ERR,
		       "input device %s: memory allocation for path name failed: %s\n",
		       path,
		       strerror(errno));
		free(device);
		return -1;
	}
	if ((device->fd = open(device->path, O_RDWR)) < 0) {
		syslog(LOG_ERR,
		       "input device %s: device open failed: %s\n",
		       device->path,
		       strerror(errno));
		free(device->path);
		free(device);
		return -1;
	}
	if (ioctl(device->fd, EVIOCGRAB, 1) < 0) {
		syslog(LOG_ERR,
		       "input device %s: device grab failed: %s\n",
		       device->path,
		       strerror(errno));
		close(device->fd);
		free(device->path);
		free(device);
		return -1;
	}

	if (input_device_evmap_init(device, eventlircd_input.evmap_dir, evmap_file) != 0) {
		close(device->fd);
		free(device->path);
		free(device);
		return -1;
	}

        device->repeat_filter = eventlircd_input.repeat_filter;
	
	if ((device->remote = strndup(remote, PATH_MAX)) == NULL) {
		syslog(LOG_ERR,
		       "input device %s: memory allocation for remote name failed: %s\n",
		       path,
		       strerror(errno));
		input_device_evmap_exit(device);
		close(device->fd);
		free(device->path);
		free(device);
		return -1;
	}

	/*
	 * Query the input device for event types and codes that it supports.
	 */
	memset(bit, 0, sizeof(bit));
	ioctl(device->fd, EVIOCGBIT(0, EV_MAX), bit);
	for (i = 1 ; i < EV_MAX ; i++) {
		if (BITFIELD_TEST(i, bit)) {
			switch (i) {
			case EV_KEY:
				memset(bit_key, 0, sizeof(bit_key));
				ioctl(device->fd, EVIOCGBIT(EV_KEY, KEY_MAX), bit_key);
				break;
			case EV_REL:
				memset(bit_rel, 0, sizeof(bit_rel));
				ioctl(device->fd, EVIOCGBIT(EV_REL, REL_MAX), bit_rel);
				break;
			case EV_ABS:
				memset(bit_abs, 0, sizeof(bit_abs));
				ioctl(device->fd, EVIOCGBIT(EV_ABS, ABS_MAX), bit_abs);
				break;
			case EV_MSC:
				memset(bit_msc, 0, sizeof(bit_msc));
				ioctl(device->fd, EVIOCGBIT(EV_MSC, MSC_MAX), bit_msc);
				break;
			case EV_SW:
				memset(bit_sw, 0, sizeof(bit_sw));
				ioctl(device->fd, EVIOCGBIT(EV_SW, SW_MAX), bit_sw);
				break;
			case EV_LED:
				memset(bit_led, 0, sizeof(bit_led));
				ioctl(device->fd, EVIOCGBIT(EV_LED, LED_MAX), bit_led);
				break;
			case EV_SND:
				memset(bit_snd, 0, sizeof(bit_snd));
				ioctl(device->fd, EVIOCGBIT(EV_SND, SND_MAX), bit_snd);
				break;
			case EV_REP:
				break;
			case EV_FF:
				memset(bit_ff, 0, sizeof(bit_ff));
				ioctl(device->fd, EVIOCGBIT(EV_FF, FF_MAX), bit_ff);
				break;
			case EV_FF_STATUS:
				memset(bit_ff_status, 0, sizeof(bit_ff_status));
				ioctl(device->fd, EVIOCGBIT(EV_FF_STATUS, FF_STATUS_MAX), bit_ff_status);
				break;
			default:
				break;
			}
		}
	}

	/*
	 * Check for event types and codes that are not supported by eventlircd.
	 */
	for (i = 1 ; i < EV_MAX ; i++) {
		if (BITFIELD_TEST(i, bit)) {
			switch (i) {
			case EV_KEY:
				break;
			case EV_REL:
				break;
			case EV_ABS:
				break;
			case EV_MSC:
				syslog(LOG_DEBUG,
				       "input device %s: events of unsupported event type EV_MSC will be discarded\n",
				       device->path);
				for (j = 0 ; j < MSC_MAX ; j++) {
					if (BITFIELD_TEST(j, bit_msc) != 0) {
						syslog(LOG_DEBUG,
						       "input device %s: event code 0x%02x of unsupported event type EV_MSC will be discarded\n",
						       device->path,
						       (unsigned int)j);
					}
				}
				break;
			case EV_SW:
				syslog(LOG_DEBUG,
				       "input device %s: events of unsupported event type EV_SW will be discarded\n",
				       device->path);
				for (j = 0 ; j < SW_MAX ; j++) {
					if (BITFIELD_TEST(j, bit_sw) != 0) {
						syslog(LOG_DEBUG,
						       "input device %s: event code 0x%02x of unsupported event type EV_SW will be discarded\n",
						       device->path,
						       (unsigned int)j);
					}
				}
				break;
			case EV_LED:
				for (j = 0 ; j < LED_MAX ; j++) {
					if ((j == LED_CAPSL  ) ||
						(j == LED_NUML   ) ||
						(j == LED_SCROLLL)) {
						continue;
					}
					if (BITFIELD_TEST(j, bit_led) != 0) {
						syslog(LOG_DEBUG,
						       "input device %s: unsupported event code 0x%02x of event type EV_LED will be discarded\n",
						       device->path,
						       (unsigned int)j);
					}
				}
				break;
			case EV_SND:
				syslog(LOG_DEBUG,
				       "input device %s: events of unsupported event type EV_SND will be discarded\n",
				       device->path);
				for (j = 0 ; j < SND_MAX ; j++) {
					if (BITFIELD_TEST(j, bit_snd) != 0) {
						syslog(LOG_DEBUG,
						       "input device %s: event code 0x%02x of unsupported event type EV_SND will be discarded\n",
						       device->path,
						       (unsigned int)j);
					}
				}
				break;
			case EV_REP:
				syslog(LOG_DEBUG,
				       "input device %s: events of unsupported event type EV_REP will be discarded\n",
				       device->path);
				break;
			case EV_FF:
				syslog(LOG_DEBUG,
				       "input device %s: events of unsupported event type EV_FF will be discarded\n",
				       device->path);
				for (j = 0 ; j < FF_MAX ; j++) {
					if (BITFIELD_TEST(j, bit_ff) != 0) {
						syslog(LOG_DEBUG,
						       "input device %s: event code 0x%02x of unsupported event type EV_FF will be discarded\n",
						       device->path,
						       (unsigned int)j);
					}
				}
				break;
			case EV_PWR:
				syslog(LOG_DEBUG,
				       "input device %s: events of unsupported event type EV_PWR will be discarded\n",
				       device->path);
				break;
			case EV_FF_STATUS:
				syslog(LOG_DEBUG,
				       "input device %s: events of unsupported event type EV_FF_STATUS will be discarded\n",
				       device->path);
				for (j = 0 ; j < FF_STATUS_MAX ; j++)
				{
					if (BITFIELD_TEST(j, bit_ff_status) != 0) {
						syslog(LOG_DEBUG,
						       "input device %s: event code 0x%02x of unsupported event type EV_FF_STATUS will be discarded\n",
						       device->path,
						       (unsigned int)j);
					}
				}
				break;
			default:
				syslog(LOG_DEBUG,
				       "input device %s: events of unsupported event type 0x%02x will be discarded\n",
				       device->path,
				       (unsigned int)i);
				break;
			}
		}
	}

	device->led.capslock = false;
	device->led.numlock = false;
	device->led.scrolllock = false;
	if (BITFIELD_TEST(EV_LED, bit) != 0) {
		if (BITFIELD_TEST(LED_CAPSL, bit_led) != 0) {
			device->led.capslock = true;
		}
		if (BITFIELD_TEST(LED_NUML, bit_led) != 0) {
			device->led.numlock = true;
		}
		if (BITFIELD_TEST(LED_SCROLLL, bit_led) != 0) {
			device->led.scrolllock = true;
		}
	}
	device->lock_state = 0;

	device->modifier_state = 0;

	device->previous_list = NULL;
	memset(&(device->current.event_in), 0, sizeof(struct input_event));
	device->current.event_in.type = EVENTLIRCD_EV_NULL;
	memset(&(device->current.event_out), 0, sizeof(struct input_event));
	device->current.event_out.type = EVENTLIRCD_EV_NULL;
	device->current.repeat_count = 0;

	/*
	 * Create output event device for events that are not sent to the lircd socket.
	 */
	device->output.fd = -1;
	for (z = 0 ; (device->output.fd == -1) && (uinput_devname[z] != NULL) ; z++) {
		device->output.fd = open(uinput_devname[z], O_WRONLY | O_NDELAY);
	}
	if (device->output.fd == -1) {
		syslog(LOG_ERR,
		       "input device %s: unable to open event device: %s\n",
		       device->path,
		       strerror(errno));
		free(device->remote);
		input_device_evmap_exit(device);
		close(device->fd);
		free(device->path);
		free(device);
		return -1;
	}

	memset(&(device->output.dev), 0, sizeof(device->output.dev));

	device->output.syn_report = false;

	strncpy(device->output.dev.name, DEVICE_NAME, UINPUT_MAX_NAME_SIZE - 1);
	device->output.dev.name[UINPUT_MAX_NAME_SIZE - 1] = '\0';
	if (ioctl(device->fd, EVIOCGID, &(device->output.dev.id)) != 0) {
		syslog(LOG_WARNING,
		       "input device %s: unable to retreive id information: %s\n",
		       device->path,
		       strerror(errno));
		device->output.dev.id.bustype = 0;
		device->output.dev.id.vendor = 0;
		device->output.dev.id.product = 0;
		device->output.dev.id.version = 0;
	}

	if (ioctl(device->output.fd, UI_SET_PHYS, device->path) < 0) {
		syslog(LOG_ERR,
		       "input device %s: unable to set UI_SET_PHYS for output event device: %s\n",
		       device->path,
		       strerror(errno));
		free(device->remote);
		close(device->output.fd);
		input_device_evmap_exit(device);
		close(device->fd);
		free(device->path);
		free(device);
		return -1;
	}

	/*
	 * Configure mouse/joystick device with the mapped event types and codes
	 * that are supported by eventlircd.
	 */
	output_active = false;
	for (i = 1 ; i < EV_MAX ; i++) {
		if (BITFIELD_TEST(i, bit)) {
			if (i == 0) {
				continue;
			}
			switch (i) {
			case EV_KEY:
				for (j = 0 ; j < KEY_MAX ; j++) {
					type = i;
					code = j;
					if (BITFIELD_TEST(code, bit_key) != 0) {
						/*
						 * If the key code is a lock key code, then skip it
						 * as eventlircd consumes it as part of keyboard
						 * shortcut mapping.
						 */
						if ((code == KEY_CAPSLOCK  ) ||
						    (code == KEY_NUMLOCK   ) ||
						    (code == KEY_SCROLLLOCK)) {
							continue;
						}
						/*
						 * If the key code is a modifier key code, then skip
						 * it as eventlircd consumes it as part of keyboard
						 * shortcut mapping.
						 */
						if ((code == KEY_LEFTCTRL ) || (code == KEY_RIGHTCTRL ) ||
						    (code == KEY_LEFTSHIFT) || (code == KEY_RIGHTSHIFT) ||
						    (code == KEY_LEFTALT  ) || (code == KEY_RIGHTALT  ) ||
						    (code == KEY_LEFTMETA ) || (code == KEY_RIGHTMETA )) {
							continue;
						}
						/*
						 * Map the key code.
						 */
						device->current.event_in.type = type;
						device->current.event_in.code = code;
						input_device_evmap_run(device);
						/*
						 * The key code maps to NULL so move on to the next
						 * key code.
						 */
						code = device->current.event_out.code;
						if (code == EVENTLIRCD_EVMAP_NULL) {
							continue;
						}
						/*
						 * The mapped key code is a button, so mark it as
						 * supported by the mouse/joystick device.
						 */
						if (evkey_type[code] == EVENTLIRCD_EVKEY_TYPE_BTN) {
							if (ioctl(device->output.fd, UI_SET_EVBIT, EV_KEY) < 0) {
								syslog(LOG_ERR,
								       "input device %s: failed to set UI_SET_EVBIT EV_KEY for output event device: %s\n",
								       device->path,
								       strerror(errno));
							}
							if (ioctl(device->output.fd, UI_SET_KEYBIT, code) < 0) {
								syslog(LOG_ERR,
								       "input device %s: failed to set UI_SET_KEYBIT 0x%02x for output event device: %s\n",
								       device->path,
								       (unsigned int)code,
								       strerror(errno));
							}
							output_active = true;
						}
					}
				}
				break;
			case EV_REL:
				for (j = 0 ; j < REL_MAX ; j++) {
					type = i;
					code = j;
					if (BITFIELD_TEST(code, bit_rel) != 0) {
						/*
						 * Map the key code.
						 */
						device->current.event_in.type = type;
						device->current.event_in.code = code;
						input_device_evmap_run(device);
						/*
						 * The key code maps to NULL so move on to the next
						 * key code.
						 */
						code = device->current.event_out.code;
						if (code == EVENTLIRCD_EVMAP_NULL) {
							continue;
						}
						if (ioctl(device->output.fd, UI_SET_EVBIT, EV_REL) < 0) {
							syslog(LOG_ERR,
							       "input device %s: failed to set UI_SET_EVBIT EV_REL for output event device: %s\n",
							       device->path,
							       strerror(errno));
						}
						if (ioctl(device->output.fd, UI_SET_RELBIT, code) < 0) {
							syslog(LOG_ERR,
							       "input device %s: failed to set UI_SET_RELBIT 0x%02x for output event device: %s\n",
							       device->path,
							       (unsigned int)code,
							       strerror(errno));
						}
						output_active = true;
					}
				}
				break;
			case EV_ABS:
				for (j = 0 ; j < ABS_MAX ; j++) {
					type = i;
					code = j;
					if (BITFIELD_TEST(code, bit_abs) != 0) {
						/*
						 * Map the key code.
						 */
						device->current.event_in.type = type;
						device->current.event_in.code = code;
						input_device_evmap_run(device);
						/*
						 * The key code maps to NULL so move on to the next
						 * key code.
						 */
						code = device->current.event_out.code;
						if (code == EVENTLIRCD_EVMAP_NULL) {
							continue;
						}
						struct input_absinfo absinfo;
						if (ioctl(device->output.fd, UI_SET_EVBIT, EV_ABS) < 0) {
							syslog(LOG_ERR,
							       "input device %s: failed to set UI_SET_EVBIT EV_ABS for output event device: %s\n",
							       device->path,
							       strerror(errno));
						}
						if (ioctl(device->output.fd, UI_SET_ABSBIT, code) < 0) {
							syslog(LOG_ERR,
							       "input device %s: failed to set UI_SET_ABSBIT 0x%02x for output event device: %s\n",
							       device->path,
							       (unsigned int)code,
							       strerror(errno));
						}
						if (ioctl(device->fd, EVIOCGABS(code), &absinfo) < 0) {
							syslog(LOG_ERR,
							       "input device %s: failed to get ABS information for 0x%02x of output event device: %s\n",
							       device->path,
							       (unsigned int)code,
							       strerror(errno));
						} else {
							device->output.dev.absmax[code] = absinfo.maximum;
							device->output.dev.absmin[code] = absinfo.minimum;
							device->output.dev.absfuzz[code] = absinfo.fuzz;
							device->output.dev.absflat[code] = absinfo.flat;
						}
						output_active = true;
					}
				}
				break;
			case EV_MSC:
				break;
			case EV_SW:
				break;
			case EV_LED:
				break;
			case EV_SND:
				break;
			case EV_REP:
				break;
			case EV_FF:
				break;
			case EV_FF_STATUS:
				break;
			}
		}
	}
	/*
	 * Make sure that any buttos that are the result of keyboard shortcut
	 * mapping are included in the mouse/joystick device.
	 */
	if (BITFIELD_TEST(EV_KEY, bit) != 0) {
		for (z = 0 ; z < device->evmap_size ; z++) {
			code_in  = device->evmap[z].code_in;
			code_out = device->evmap[z].code_out;
			/*
			 * Skip keyboard shortcuts that map to NULL.
			 */
			if (code_out == EVENTLIRCD_EVMAP_NULL) {
				continue;
			}
			/*
			 * Ignore keyboard shortcuts that require keys the device
			 * does not support.
			 */
			if (((code_in & EVENTLIRCD_EVMAP_LOCK_CAPS) != 0) &&
			    (BITFIELD_TEST(KEY_CAPSLOCK, bit_key)   == 0)) {
				continue;
			}
			if (((code_in & EVENTLIRCD_EVMAP_LOCK_NUM) != 0) &&
			    (BITFIELD_TEST(KEY_NUMLOCK, bit_key)   == 0)) {
				continue;
			}
			if (((code_in & EVENTLIRCD_EVMAP_LOCK_SCROLL) != 0) &&
			    (BITFIELD_TEST(KEY_SCROLLLOCK, bit_key)   == 0)) {
				continue;
			}
			if (((code_in & EVENTLIRCD_EVMAP_MOD_CTRL) != 0) &&
			    (BITFIELD_TEST(KEY_LEFTCTRL, bit_key)  == 0) &&
			    (BITFIELD_TEST(KEY_RIGHTCTRL, bit_key) == 0)) {
				continue;
			}
			if (((code_in & EVENTLIRCD_EVMAP_MOD_SHIFT) != 0) &&
			    (BITFIELD_TEST(KEY_LEFTSHIFT, bit_key)  == 0) &&
			    (BITFIELD_TEST(KEY_RIGHTSHIFT, bit_key) == 0)) {
				continue;
			}
			if (((code_in & EVENTLIRCD_EVMAP_MOD_ALT) != 0) &&
			    (BITFIELD_TEST(KEY_LEFTALT, bit_key)  == 0) &&
			    (BITFIELD_TEST(KEY_RIGHTALT, bit_key) == 0)) {
				continue;
			}
			if (((code_in & EVENTLIRCD_EVMAP_MOD_META) != 0) &&
			    (BITFIELD_TEST(KEY_LEFTMETA, bit_key)  == 0) &&
			    (BITFIELD_TEST(KEY_RIGHTMETA, bit_key) == 0)) {
				continue;
			}
			if (BITFIELD_TEST(code_in & EVENTLIRCD_EVMAP_CODE_MASK, bit_key) == 0) {
				continue;
			}
			/*
			 * The output is a button so add it to mouse/joystick device.
			 */
			if (evkey_type[code_out] == EVENTLIRCD_EVKEY_TYPE_BTN) {
				if (ioctl(device->output.fd, UI_SET_EVBIT, EV_KEY) < 0) {
					syslog(LOG_ERR,
					       "input device %s: failed to set UI_SET_EVBIT EV_KEY for output event device: %s\n",
					       device->path,
					       strerror(errno));
				}
				if (ioctl(device->output.fd, UI_SET_KEYBIT, code_out) < 0) {
					syslog(LOG_ERR,
					       "input device %s: failed to set UI_SET_KEYBIT 0x%02x for output event device: %s\n",
					       device->path,
					       (unsigned int)code_out,
					       strerror(errno));
				}
				output_active = true;
			}
		}
	}
	/*
	 *
	 */
	if (output_active == true) {
		if (write(device->output.fd, &device->output.dev, sizeof(device->output.dev)) != sizeof(device->output.dev)) {
			syslog(LOG_ERR,
			       "input device %s: unable to write output event device: %s\n",
			       device->path,
			       strerror(errno));
			close(device->output.fd);
			free(device->remote);
			input_device_evmap_exit(device);
			close(device->fd);
			free(device->path);
			free(device);
			return -1;
		}
		if (ioctl(device->output.fd, UI_DEV_CREATE)) {
			syslog(LOG_ERR,
			       "input device %s: unable to create output event device: %s\n",
			       device->path,
			       strerror(errno));
			close(device->output.fd);
			free(device->remote);
			input_device_evmap_exit(device);
			close(device->fd);
			free(device->path);
			free(device);
			return -1;
		}
	} else {
		close(device->output.fd);
		device->output.fd = -1;
	}

	/*
	 * Make sure we recieve notifications when the device has changed state.
	 */
	if (monitor_client_add(device->fd, &input_device_handler, device) != 0) {
		close(device->output.fd);
		free(device->remote);
		input_device_evmap_exit(device);
		close(device->fd);
		free(device->path);
		free(device);
		return -1;
	}

	/*
	 * Make sure that our state matches the device's state for capslock, numlock
	 * and scrolllock.
	 */
	if ((device->led.capslock   == true) || 
		(device->led.numlock    == true) ||
		(device->led.scrolllock == true)) {
		int8_t bit[LED_MAX/8 + 1];
		memset(bit, 0, sizeof(bit));
		ioctl(device->fd, EVIOCGLED(sizeof(bit)), bit);
		if (device->led.capslock == true) {
			if (((bit[LED_CAPSL/8] >> (LED_CAPSL%8)) & 0x1) == 0)
				device->lock_state &= ~EVENTLIRCD_EVMAP_LOCK_CAPS;
			else
				device->lock_state |=  EVENTLIRCD_EVMAP_LOCK_CAPS;
		}
		if (device->led.numlock == true) {
			if (((bit[LED_NUML/8] >> (LED_NUML%8)) & 0x1) == 0)
				device->lock_state &= ~EVENTLIRCD_EVMAP_LOCK_NUM;
			else
				device->lock_state |=  EVENTLIRCD_EVMAP_LOCK_NUM;
		}
		if (device->led.scrolllock == true) {
			if (((bit[LED_SCROLLL/8] >> (LED_SCROLLL%8)) & 0x1) == 0)
				device->lock_state &= ~EVENTLIRCD_EVMAP_LOCK_SCROLL;
			else
				device->lock_state |=  EVENTLIRCD_EVMAP_LOCK_SCROLL;
		}
	}

	device->next = eventlircd_input.device_list;
	eventlircd_input.device_list = device;

	syslog(LOG_INFO,
	       "input device %s: grabbed",
	        device->path);
	if (device->output.fd != -1) {
		syslog(LOG_INFO,
		       "input device %s: created output event device",
		        device->path);
	}

	return 0;
}

static int input_handler(void* UNUSED(id))
{
	struct udev_device *udev_device;
	const char *action;

	if (eventlircd_input.udev.monitor == NULL)
	{
		return -1;
	}

	udev_device = udev_monitor_receive_device(eventlircd_input.udev.monitor);
	if (udev_device == NULL) {
		return -1;
	}

	action = udev_device_get_action(udev_device);
	if (action != NULL) {
		if      (strncmp(action, "add", strlen("add") + 1) == 0) {
			if (input_device_add(udev_device) != 0) {
				return -1;
			}
		} else if (strncmp(action, "remove", strlen("remove") + 1) == 0) {
			if (input_device_remove(udev_device) != 0) {
				return -1;
			}
		}
	}

	udev_device_unref(udev_device);

	return 0;
}

int input_exit()
{
	struct udev *udev = NULL;
	int return_code;
	struct input_device *device;

	return_code = 0;

	if (monitor_client_remove(eventlircd_input.udev.fd) != 0) {
		return_code = -1;
	}

	for (device = eventlircd_input.device_list ; device != NULL ; device = device->next) {
		if (input_device_close(device) != 0) {
			return_code = -1;
		}
	}
	if (input_device_purge() != 0) {
		return_code = -1;
	}

	if (eventlircd_input.udev.monitor != NULL) {
		udev = udev_monitor_get_udev(eventlircd_input.udev.monitor);
		udev_monitor_unref(eventlircd_input.udev.monitor);
		eventlircd_input.udev.monitor = NULL;
		if (udev != NULL) {
			udev_unref(udev);
		} else {
			return_code = -1;
		}
	}
	eventlircd_input.udev.fd = -1;

	if (eventlircd_input.evmap_dir != NULL) {
		free(eventlircd_input.evmap_dir);
		eventlircd_input.evmap_dir = NULL;
	}

	return return_code;
}

int input_init(const char *evmap_dir, const bool repeat_filter)
{
	struct udev *udev;
	struct udev_enumerate *enumerate;
	struct udev_list_entry *device_list;
	struct udev_list_entry *device;
	const char *syspath;
	struct udev_device *udev_device;

	eventlircd_input.evmap_dir = NULL;
	eventlircd_input.repeat_filter = false;
	eventlircd_input.udev.fd = -1;
	eventlircd_input.udev.monitor = NULL;
	eventlircd_input.device_list = NULL;

	if (evmap_dir == NULL) {
		errno = EINVAL;
		return -1;
	}

	if ((eventlircd_input.evmap_dir = strndup(evmap_dir, PATH_MAX + 1)) == NULL) {
		syslog(LOG_ERR,
		       "failed to allocate memory for the input device event map directory name %s: %s\n",
		       evmap_dir,
		       strerror(errno));
		input_exit();
		return -1;
	}

	eventlircd_input.repeat_filter = repeat_filter;

	if ((udev = udev_new()) == NULL) {
		syslog(LOG_ERR,
		       "failed to bind the udev monitor: %s\n",
		       strerror(errno));
		input_exit();
		return -1;
	}

	if ((eventlircd_input.udev.monitor = udev_monitor_new_from_netlink(udev, "udev")) == NULL) {
		syslog(LOG_ERR,
		       "failed to bind the udev monitor: %s\n",
		       strerror(errno));
		input_exit();
		return -1;
	}

	if ((eventlircd_input.udev.fd = udev_monitor_get_fd(eventlircd_input.udev.monitor)) == -1) {
		syslog(LOG_ERR,
		       "failed to get udev monitor file descriptor: %s\n",
		       strerror(errno));
		input_exit();
		return -1;
	}

	if (udev_monitor_filter_add_match_subsystem_devtype(eventlircd_input.udev.monitor, "input", NULL) < 0) {
		syslog(LOG_ERR,
		       "failed to bind the udev monitor: %s\n",
		       strerror(errno));
		input_exit();
		return -1;
	}

	if (udev_monitor_enable_receiving(eventlircd_input.udev.monitor)) {
		syslog(LOG_ERR,
		       "failed to bind the udev monitor: %s\n",
		       strerror(errno));
		input_exit();
		return -1;
	}

	if ((enumerate = udev_enumerate_new(udev)) == NULL) {
		syslog(LOG_ERR,
		       "failed to enumerate udev devices: %s\n",
		       strerror(errno));
		input_exit();
		return -1;
	}
	
	udev_enumerate_add_match_subsystem(enumerate, "input");
	udev_enumerate_scan_devices(enumerate);
	device_list = udev_enumerate_get_list_entry(enumerate);
	udev_list_entry_foreach(device, device_list) {
		if ((syspath = udev_list_entry_get_name(device)) == NULL) {
			input_exit();
			return -1;
		}
		if ((udev_device = udev_device_new_from_syspath(udev, syspath)) == NULL) {
			input_exit();
			return -1;
		}
		if (input_device_add(udev_device) != 0) {
			input_exit();
			return -1;
		}
		udev_device_unref(udev_device);
	}
	udev_enumerate_unref(enumerate);

	if (monitor_client_add(eventlircd_input.udev.fd, &input_handler, NULL) != 0) {
		input_exit();
		return -1;
	}

	return 0;
}
